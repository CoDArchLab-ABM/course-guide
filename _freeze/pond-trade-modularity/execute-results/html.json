{
  "hash": "42d6689b4c0761b7f5fa8c26a73ace9c",
  "result": {
    "engine": "knitr",
    "markdown": "# Identifying and formatting submodels {#pond-trade-submodelling}\n\nIn the early stages of model development, it is common to work within a **single `.nlogo` file**. This approach keeps all code‚Äîsetup, agent logic, data collection, and plotting‚Äîin one place, which is convenient for learning and experimentation. However, as models grow in complexity, maintaining a long monolithic file becomes difficult.\nTo make large projects easier to navigate, debug, and extend, **NetLogo allows modularisation** through the `__includes` directive.\n\n## Why Modularise?\n\nBreaking a model into smaller source files improves:\n\n* **Readability:** Each file focuses on a specific function (e.g., setup, environment, agent behaviour, data collection).\n* **Reusability:** Procedures can be shared across projects.\n* **Maintenance:** Updating or replacing a subsystem (e.g., weather generation) doesn‚Äôt require scrolling through hundreds of lines.\n* **Collaboration:** Multiple researchers can work on separate components concurrently.\n\nThese have great consequences for supporting **transparent and replicable research**. Instead of one opaque model file, a modular structure makes explicit where, for example, environmental data, agent rules, or calibration routines are defined‚Äîfacilitating peer review, teaching, and long-term model reuse.\n\n## The `__includes` Directive\n\nNetLogo allows a model to load additional source files (`.nls`, for *NetLogo Source*) at runtime.\nThe syntax, placed at the top of your main `.nlogo` file, is:\n\n```netlogo\n__includes [\n  \"modules/setup.nls\"\n  \"modules/agents.nls\"\n  \"modules/environment.nls\"\n  \"modules/data_collection.nls\"\n]\n```\n\n>*NOTE: Storing these files in a subdirectory, like 'modules', is not a requirement, but it will be preferable if the model directory contains anything besides a single `.nlogo` file (e.g., input or output data files, documentation, etc).*\n\nEach included file may contain any NetLogo code (procedures, reporters, variable declarations). They could even correspond to a single element each (e.g., \"setup.nls\" containing only the `setup` procedure). The criteria for splitting those elements and naming the files is ultimately for you to decide. You should aim to have not too much nor too little code in files, but this is no golden rule and there are many instances where grouping or separating elements is more desirable. Using a combination of function (e.g., \"setup\", \"data collection\"), object (e.g., \"patches\", a given breed of agent) and topic (e.g., vegetation growth, movement, communication) can make good intermediate solutions. Remember the reasons for going modular and think in terms of what helps you pursuing them.\n\nWhen the model (`.nlogo` file) loads, all included `.nls` files are **merged into a single shared namespace**, so procedures defined in one file are visible to all others. You may also consult and modify the source code directly in NetLogo since, once loaded, they will appear in the drop down list at the top of the \"Code\" tab.\n\n## Breaking Down The Pond Trade Model\n\nTo break down the **Pond Trade** model developed within one `.nlogo` file, we can refactor it into modules stored in a structured directory, for example:\n\n```\nPondTrade/\n‚îú‚îÄ‚îÄ PondTrade.nlogo              ; main file (interface + globals + includes)\n‚îî‚îÄ‚îÄ modules/\n    ‚îú‚îÄ‚îÄ main.nls                 ; stricly, setup and go procedures\n    ‚îú‚îÄ‚îÄ map.nls                  ; Map and terrain generation\n    ‚îú‚îÄ‚îÄ output.nls               ; Plotting, displays, outputs, and computing model statistics\n    ‚îú‚îÄ‚îÄ routes.nls               ; Route calculation, pathfinding, and connectivity logic.\n    ‚îú‚îÄ‚îÄ settlements.nls          ; Creating and managing settlements\n    ‚îî‚îÄ‚îÄ traders.nls              ; trader creation, activation, movement, and trading logic\n```\n\nInside the main model:\n\n```netlogo\n__includes [\n  \"modules/PondTrade/main.nls\"\n  \"modules/PondTrade/map.nls\"\n  \"modules/PondTrade/settlements.nls\"\n  \"modules/PondTrade/routes.nls\"\n  \"modules/PondTrade/traders.nls\"\n  \"modules/PondTrade/output.nls\"\n]\n```\n\nEach `.nls` file then contains code that is more closely related, even though they are inevitably connect to others. For example, `map.nls` stores `create-map` and `smooth-coast-line`, but while `smooth-coast-line` is only called by `create-map`, `create-map` in turn is called by `setup`.\n\nThis structure makes it easier to focus on specific model components, understand or modify them, without being overwhelmed by the entire codebase.\n\n### Shared Utilities\n\nAll included files share the same namespace.\nTherefore, **common utility functions** can be stored in a single shared file that can be referenced in the main `__includes` list of different models or `.nlogo` files.\n\nFor example, we can store `commonProcedure.nls` in a `utils` subdirectory insider a larger directory containing subdirectories for two models:\n\n```\nmy models/\n‚îú‚îÄ‚îÄPondTrade/\n|   ‚îú‚îÄ‚îÄ PondTrade.nlogo\n|   ‚îî‚îÄ‚îÄ modules/\n‚îî‚îÄ‚îÄOtherModel/\n|   ‚îú‚îÄ‚îÄ PondTrade.nlogo\n|   ‚îî‚îÄ‚îÄ modules/\n‚îî‚îÄ‚îÄutils/\n    ‚îî‚îÄ‚îÄcommonProcedure.nls\n```\n\nAnd then use it in \n\n```netlogo\n__includes [\n  ...\n  \"../utils/commonProcedure.nls\"\n  ...\n]\n```\n\n## Refactoring for a better modularity\n\nOnce we split our code into logical parts, we might already gain some useful insights about how to better respect modularity without changing the code behaviour. We have one such a case in `map.nls`.\n\nHere is the call paths involving the two procedures in this file:\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"grViz html-widget html-fill-item\" id=\"htmlwidget-108b86b70f40ac2615a5\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-108b86b70f40ac2615a5\">{\"x\":{\"diagram\":\"digraph procedureCalls {\\n  node [style=filled];\\n    \\n\\n  subgraph cluster_map {\\n    label = \\\"map\\\";\\n    color=blue\\n    smooth [label=\\\"smooth-coast-line\\\"];\\n    create [label=\\\"create-map\\\"];\\n  }\\n\\n  subgraph cluster_main {\\n    label = \\\"main\\\";\\n    node [style=filled];\\n    color=red\\n    setup;\\n    go;\\n  }\\n  \\n  subgraph cluster_routes {\\n    label=\\\"routes\\\";\\n    node [style=filled];\\n    color=green\\n    topproc [label=\\\"...\\\"];\\n    assignpc [label=\\\"assign-path-cost\\\"];\\n    bottomproc [label=\\\"...\\\"];\\n  }\\n  \\n  \\n  create -> setup;\\n  smooth -> create;\\n  topproc -> setup;\\n  bottomproc -> go;\\n  assignpc -> create;\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\nWe can see that `assign-path-cost` has a somewhat ambiguous position: it is clearly related to route calculation, but it is actually called in `map`, inside `create-map`, not in another procedure in `routes` or directly in `setup`. \n\n```\nto create-map\n\n  ...\n  \n  smooth-coast-line\n\n  assign-path-cost\n\n  ask patches [ paint-terrain ]\n\nend\n```\n\nThis makes our code a \"spaghetti code\". The refactoring measure that can solve this is straightforward: we move the call for `assign-path-cost` from `create-map` to `setup`. Since it was already positioned at the end of `create-map`, moving it immediately following the call for `create-map` in `setup` will not change the model behaviour. The cost is simply a slightly longer setup procedure.\n\n```\nto setup\n\n  clear-all\n  reset-ticks\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n  \n  set patchesCount count patches\n\n  create-map\n  \n  assign-path-cost\n\n  create-coastal-settlements\n\n  set-routes\n\n  create-traders-per-settlement\n\n  update-output\n\n  update-display\n\n  update-plots\n\nend\n```\n\nRefactoring is a process that never finishes. Do you see any other improvements to our implementation of the model so far? If so, please try them and if successful, create a pull request with your changes to our course-guide repository.\n\n---\n\n## üß† Activity\n\nRefactor another model using `__includes`. The *Artificial Anasazi* model offers a good case, but feel free to try another model.\n\nHere is short summary of the steps you should follow:\n\n### üß© **Step 1 ‚Äî Create the Folder Structure**\n\n1. Make a new directory.\n2. Inside it, create a `modules` subdirectory.\n3. Copy your original model `.nlogo` file.\n\n```\nnewModelDirectory/\n‚îú‚îÄ‚îÄ modelCopy.nlogo\n‚îî‚îÄ‚îÄ modules/\n```\n\n### ‚öôÔ∏è **Step 2 ‚Äî Add the `__includes` Statement**\n\nAt the very top of `modelCopy.nlogo`, add:\n\n```netlogo\n__includes [\n  \"modules/setup.nls\"\n  ...\n]\n```\n\nThis tells NetLogo to merge all these modules into one program when the model is loaded.\n\n### ‚úÇÔ∏è **Step 3 ‚Äî Split the Code**\n\nNow open `modelCopy.nlogo` and **move procedures**, one at a time, to new `.nls` files in `modules/` (create these as txt files, then change the file extension; opening the entire folder in an IDE will make this easier). With the `.nlogo` file always open, save and check for error every time a module is separated. \n\nHere are a few examples of modules:\n\n| Type of Procedure                     | Move it to file   | Example                                                   |\n| ------------------------------------- | ----------------- | --------------------------------------------------------- |\n| World setup and initialization        | `setup.nls`       | `to setup`                                                |\n| Agent behaviour (movement, decisions) | `turtles.nls`     | `to go`, `to forage`, `to trade`                          |\n| Environment updates                   | `environment.nls` | `to update-water`, `to grow-resources`                    |\n| Trade and interaction logic           | `trade.nls`       | `to exchange-goods`, `to evaluate-partner`                |\n| Data collection and plotting          | `data.nls`        | `to record-stats`, `to export-csv`                        |\n| Helper and math functions             | `utils.nls`       | `to-report clamp01 [x]`, `to-report random-between [a b]` |\n\nRemember ‚Äî **you do not need to re-declare globals** or interface variables in every file.\nAll modules share the same namespace once included.\n\nTo go fully modular, the final version of the new `.nlogo` file should contain only the `__includes` directive and all `breed` and variable declarations. \n\n### üß™ **Step 4 ‚Äî Test the Modular Model**\n\n1. Check that it runs exactly like the original version.\n2. If an error appears such as *‚ÄúNothing named CLAMP01‚Äù*, ensure that the file containing that procedure (`utils.nls`) is listed in the `__includes`.\n",
    "supporting": [
      "pond-trade-modularity_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/grViz-binding-1.0.11/grViz.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}