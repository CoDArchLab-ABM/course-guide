{"title":"Implementing mechanisms","markdown":{"headingText":"Implementing mechanisms","headingAttr":{"id":"pond-trade-mechanims","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nWe now reach the \"spicy\" part of the development of PondTrade. Until this point, settlements are completely static, and traders are only created in `setup`, then travel back and forth without any consequence to settlements.\n\nFirst, we want to implement the feedback loop described in the conceptual model, connecting settlement size, production, and trade inflow.\n\nLet us re-organise the behavioural cycle of traders into a new separate procedure `update-traders`:\n\n```NetLogo\nto update-traders\n\n  let tradersInBase traders with [is-in-base]\n  let tradersInDestination traders with [is-in-destination]\n\n  ; UPDATE LAST POSITION\n  ask traders\n  [\n    ; update lastPosition if in a patch center\n    if ((xcor = [pxcor] of patch-here) and (ycor = [pycor] of patch-here))\n    [\n      set lastPosition patch-here\n    ]\n  ]\n\n  ; UNLOAD\n  ask (turtle-set tradersInBase tradersInDestination) with [cargoValue > 0]\n  [\n    ; unload cargo (changes sizeLevel)\n    unload-cargo\n    ; load cargo (changes stock)\n    load-cargo\n  ]\n\n  ; CHOOSE DESTINATION\n  ask tradersInBase\n  [\n    ; update the destination whenever in the base settlement and there is cargo to transport\n    choose-destination\n  ]\n\n  ; FIND DIRECTION in route\n  ask (turtle-set tradersInBase tradersInDestination)\n  [\n    find-direction\n  ]\n\n  ; MOVE towards the next position in the route\n  ask traders\n  [\n    ; move following the route when there is cargo to transport\n    move-to-destination\n  ]\n\nend\n\nto choose-destination ; ego = trader\n\n  let thisTrader self\n\n  ; get routes connecting the base settlement\n  let routesFromBase get-routes-to-settlement [base] of thisTrader\n\n  ; order these routes by benefit/cost ratio\n  set routesFromBase sort-by [ [?1 ?2] -> benefit-cost-of-route ?1 > benefit-cost-of-route ?2 ] routesFromBase\n\n  ; print the options available\n;  foreach routesFromBase\n;  [\n;    print \"===============================================================\"\n;    print \"route between:\"\n;    print [who] of get-origin-and-destination ?\n;    print \"has the benefit-cost ratio of:\"\n;    print benefit-cost-of-route ?\n;  ]\n;  print \"-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x\"\n\n  ; select the one with higher benefit/cost ratio\n  set route first routesFromBase\n\n  ; get the settlement of destination\n  set destination one-of (get-origin-and-destination route) with [who != [who] of ([base] of thisTrader)]\n\nend\n\nto find-direction ; ego = trader\n\n  ; find where in the route list is the trader\n  let currentPosition position lastPosition route\n\n  ; set direction if in a settlement\n  ifelse (currentPosition = 0) ; in the first extreme of the route list\n  [\n    ; move in the route list towards larger index numbers\n    set direction 1\n  ]\n  [\n    if (currentPosition = (length route - 1)) ; in the last extreme of the route list\n    [\n      ; move in the route list towards smaller index numbers\n      set direction -1\n    ]\n  ]\n  ; else the trader is in route to either the base or the destination\n\nend\n\nto move-to-destination ; ego = trader\n\n  ; find where in the route list is the trader\n  let currentPosition position lastPosition route\n\n  ; move through the route following direction\n  let targetPatch item (currentPosition + direction) route\n  ;move-to targetPatch ; constant travel time (1 patch per tick)\n  facexy ([pxcor] of targetPatch) ([pycor] of targetPatch)\n  forward min (\n    list\n    (1 / [pathCost] of patch-here) ; the maximum distance in a tick in the current patch\n    (distancexy ([pxcor] of targetPatch) ([pycor] of targetPatch)) ; the distance to the target patch\n    )\n\nend\n\nto-report is-in-base ; ego = trader\n\n  report (xcor = [xcor] of base) and (ycor = [ycor] of base) ; if the trader arrived at the center of the base patch\n\nend\n\nto-report is-in-destination ; ego = trader\n\n  report (xcor = [xcor] of destination) and (ycor = [ycor] of destination) ; if the trader arrived at the center of the destination patch\n\nend\n```\n\nNotice that we refactor the previous code, splitting the former procedures into several more specialised parts.\n\nWe then define the new procedures to handle the interaction between traders and settlements:\n\n```NetLogo\ntraders-own [ base route destination direction lastPosition cargoValue ]\n\n...\n\nto unload-cargo ; ego = trader\n\n  let thisTrader self\n  let settlementHere one-of settlements-here\n\n  ; unload cargo\n  ask settlementHere [ add-trade-effect [cargoValue] of thisTrader ]\n\nend\n\nto load-cargo ; ego = trader\n\n  let settlementHere one-of settlements-here\n\n  ; load cargo\n  set cargoValue [sizeLevel] of settlementHere\n\nend\n\nto add-trade-effect [ value ] ; ego = settlement\n\n  set sizeLevel sizeLevel + value\n\nend\n\n```\n\nObserve that we are defining a very simple \"submodel\" , where the economic size units of one settlement produce an equivalent amount of transportable value (`cargoValue`), which is transferred by traders to another settlement, again as economic size units. However, with this mechanism, we are increasing the economic size of settlements in every trader trip but never decrease it. To avoid this, we must specify a second mechanism that \"decays\" economic size with time, up to a baseline arbitrary value (*i.e.*, 1).\n\nFor now, we implement this mechanism directly inside the `go`procedure, where we also call `update-traders`:\n\n```NetLogo\nto go\n\n  tick\n\n  update-traders\n\n  ; the size of settlements decays with a constant rate, up to 1 (minimum)\n  ask settlements\n  [\n    set sizeLevel max (list 1 (sizeLevel * (1 - (settlementSizeDecayRate / 100)) ) )\n  ]\n\n  update-display\n\nend\n```\n\nWe must add to the interface yet another parameter to regulate decay, `settlementSizeDecayRate` (from 0 to 25, by 0.01, default value of 5). This is expressed as the percentage of sizeLevel that is subtracted at each simulation step.\n\nTo better explore the effects of this feedback loop, it is time for us to start adding some plots to the interface. Select Plot in the dropdown menu and add two plot objects, as you have done with buttons, sliders, etc. Configure them as follows:\n\n|  |\n| --- |\n| <img src=\"assets/screenshots/BlockB_PondTrade_step08_adding-feedback-loops-1-plot1setting.png\" width=\"500\"> | \n| <img src=\"assets/screenshots/BlockB_PondTrade_step08_adding-feedback-loops-1-plot2setting.png\" width=\"500\"> |\n\nWe can now run the model with a few settlements and repeat `go` many times. Explore different `seed` numbers. Are settlements reacting to traders' dynamics at all? Is the value of `settlementSizeDecayRate` too high or low? What are we doing wrong?\n\n![Pond Trade step 8](assets/screenshots/BlockB_PondTrade_step08_adding-feedback-loops-1-interface.png)  \n*Pond Trade step 8*\n\nBefore moving to the second feedback loop, we must solve our problem. If you followed any of the different approaches for debugging (*e.g.*, inspecting agents, printing messages in mid-code), you have detected that traders are not transporting any cargoValue. The problem resides in how we have scheduled the calls for `unload-cargo`and `load-cargo`. Notice that we added `load-cargo` to a conditional call `ask (turtle-set tradersInBase tradersInDestination) with [cargoValue > 0]`, only relevant to traders *with cargo*, which is impossible for traders to fulfill initially.\n\nWe re-organise `update-traders`as follows:\n\n```NetLogo\nto update-traders\n  \n  ...\n\n  ; UNLOAD\n  ask (turtle-set tradersInBase tradersInDestination) with [cargoValue > 0]\n  [\n    ; unload cargo (changes sizeLevel)\n    unload-cargo\n  ]\n\n  ; LOAD\n  ask (turtle-set tradersInBase tradersInDestination)\n  [\n    ; load cargo (changes stock)\n    load-cargo\n  ]\n\n  ...\n\nend\n```\n\n![Pond Trade step 8 (after correction)](assets/screenshots/BlockB_PondTrade_step08_adding%20feedback%20loops%201%20interface_afterCorrection.png)  \n*Pond Trade step 8 (after correction)*\n\nWe can now see how, quite often, one or very few hubs emerge among settlements.\n\n---\n\nThe second positive feedback loop in our concept model relates settlement size, the number of traders per settlement, and trade inflow.\n\nThe key addition is that now we will have to differentiate, for each settlement, between `currentNumberOfTraders` and `potentialNumberOfTraders`, and update these according `sizeLevel`. To wrap up all this, we finally implement an update procedure specifically for settlements (`update-settlements`).\n\nWe will also need to manage the traders that are left outside the maximum value for its base settlement. We create the tag `isActivated`, in order to avoid creating and deleting too many traders in the same simulation run (*i.e.*, it might become a problem when `who` numbers start getting bigger and bigger).\n\n```NetLogo\nsettlements-own\n[\n  sizeLevel\n  currentNumberOfTraders potentialNumberOfTraders\n]\n\ntraders-own\n[\n  isActivated\n  base route destination direction lastPosition\n  cargoValue\n]\n\n...\n\n\nto create-traders-per-settlement\n\n  ask settlements\n  [\n    let thisSettlement self ; to avoid the confusion of nested agent queries\n\n    set potentialNumberOfTraders get-potential-number-of-traders\n\n    hatch-traders potentialNumberOfTraders ; use the sizeLevel variable as the number of traders based in the settlement\n    [\n      setup-trader thisSettlement\n    ]\n\n    set currentNumberOfTraders get-current-number-of-traders\n  ]\n\nend\n\nto setup-trader [ baseSettlement ]\n\n  set base baseSettlement\n  set isActivated true\n\n  ; give meaningful display related to base\n  set shape \"sailboat side\" ; import this shape from the library (Tools > Shape editor > import from library)\n  set color [color] of base\n  set size 3\n\n  choose-destination\n\nend\n\n...\n\nto update-settlements\n\n  ask settlements\n  [\n    let thisSettlement self\n\n    ; the sizeLevel of settlements decays with a constant rate, up to 1 (minimum)\n    set sizeLevel max (list 1 (sizeLevel * (1 - (settlementSizeDecayRate / 100)) ) )\n\n    ; determine the current and potential number of traders\n    set currentNumberOfTraders get-current-number-of-traders\n    set potentialNumberOfTraders get-potential-number-of-traders\n\n    ; conditions favors the creation of new traders\n    if (random-float 1 > currentNumberOfTraders / potentialNumberOfTraders )\n    [\n      ; create a new trader or activate an old one\n      repeat 1\n      [\n        ifelse (any? traders with [not isActivated])\n        [\n          ask one-of traders with [not isActivated]\n          [\n            setup-trader thisSettlement\n            move-to thisSettlement\n          ]\n        ]\n        [\n          hatch-traders 1\n          [\n            setup-trader thisSettlement\n          ]\n        ]\n      ]\n      set currentNumberOfTraders get-current-number-of-traders ; update currentNumberOfTraders\n    ]\n  ]\n\nend\n\n...\n\nto-report get-potential-number-of-traders ; ego = settlement\n\n  report (\n    1 +\n    (sizeLevel - 1)\n    )\n\nend\n\nto-report get-current-number-of-traders ; ego = settlement\n\n  let thisSettlement self\n  report count traders with [isActivated and base = thisSettlement ]\n\nend\n\n```\n\nSettlements will now calculate `potentialNumberOfTraders` at every simulation step as a number equal to its size and be allowed to create/reactivate or deactivate any traders accordingly.\n\nAdd a new Plot to visualise the count of traders through time, using the update command: `plot count traders with [isActivated]`\n\nOur second feedback loop is now up and running!\n\nHowever, our implementation is still rough on the edges and needs a bit of refactoring and model extensions.\n\nThe representation of the production process is overly simplistic. With no separable entity from sizeLevel, production value gets immediately replaced after traders load their cargo. We must introduce a new settlement variable, `stock`, to keep track of the flow of economic value and implement a more explicit representation of production and value decay, independent of size decay. For this, we introduce two new parameters, `productionRate` and `stockDecayRate` (use same interface configuration from `settlementSizeDecayRate`).\n\n```NetLogo\nsettlements-own\n[\n  ...\n  stock\n]\n\n...\n\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 ; the size level is initiated at minimum (i.e., 1)\n        set stock 0\n        set shape \"circle 2\"\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\n\n...\n\nto load-cargo ; ego = trader\n\n  let settlementHere one-of settlements-here\n\n  ; load cargo\n  set cargoValue [stock] of settlementHere\n  ask settlementHere [ set stock 0 ] ; empty the settlement stock\n\nend\n\n...\n\nto update-settlements\n\n  ask settlements\n  [\n    let thisSettlement self\n\n    ; the sizeLevel of settlements decays with a constant rate, up to 1 (minimum)\n    set sizeLevel max (list 1 (sizeLevel * (1 - (settlementSizeDecayRate / 100)) ) )\n    ; production in stock also decays with a constant rate\n    set stock stock * (1 - (stockDecayRate / 100))\n    ; prodution is generated in proportion to sizeLevel, following a constant rate\n    set stock stock + sizeLevel * (productionRate / 100)\n\n    ; determine the current and potential number of traders\n    set currentNumberOfTraders get-current-number-of-traders\n    set potentialNumberOfTraders get-potential-number-of-traders\n\n    ; conditions favors the creation of new traders\n    if (random-float 1 > currentNumberOfTraders / potentialNumberOfTraders )\n    [\n      ; create a new trader or activate an old one\n      repeat 1\n      [\n        ifelse (any? traders with [not isActivated])\n        [\n          ask one-of traders with [not isActivated]\n          [\n            setup-trader thisSettlement\n            move-to thisSettlement\n          ]\n        ]\n        [\n          hatch-traders 1\n          [\n            setup-trader thisSettlement\n          ]\n        ]\n      ]\n      set currentNumberOfTraders get-current-number-of-traders ; update currentNumberOfTraders\n    ]\n  ]\n\nend\n```\n\nIn `get-potential-number-of-traders`, there is a *hidden* magic number worth exploring. We name it `frequencyOverQuality`and make it a \"trait\" of settlements, setting it in `create-coastal-settlements` as a random number between 0 and 1:\n\n```NetLogo\nsettlements-own\n[\n  ...\n\n  frequencyOverQuality\n]\n\n...\n\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 ; the size level is initiated at minimum (i.e., 1)\n        set stock 0\n        set frequencyOverQuality random-float 1\n        set shape \"circle 2\"\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\n\nto-report get-potential-number-of-traders ; ego = settlement\n\n  report (\n    1 +\n    (sizeLevel - 1) * frequencyOverQuality\n    )\n\nend\n```\n\nAs its name tries to state, this trait's meaning is: \"how much the frequency of trade is prioritised over the quality of the cargo\". This is because the more traders a settlement has, the less cargo each will be able to get from `stock`, which will have less time to recover. Therefore, this trait represents an interesting aspect of how different settlements could organise trade.\n\nWe can now observe how the number of traders in our pond reaches an oscillating, stable low level most of the time. We can observe some exceptions by exploring higher values of `numberOfSettlements`. With enough settlements, our feedback loops push the dynamics towards the emergence of hubs, boosting the overall number of traders.\n\n![Pond Trade step 9](assets/screenshots/BlockB_PondTrade_step09_adding-feedback-loops-2-interface.png)  \n*Pond Trade step 9*\n\nWe reach the end of the implementation steps for the first-tier PondTrade model. Given all changes and extensions we made, we must go back to our conceptual model and update it accordingly.\n\n![Pond Trade conceptual model revised at step 9 (first tier)](images/0_conceptAtStep9_firstTier.png)  \n*Pond Trade conceptual model revised at step 9 (first tier)*\n\nThis graphical description is still far from the implementation code, as it should be. However, it is now adequate for the new conceptual changes we introduced in code. \n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"svg","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["assets/styles.css"],"output-file":"pond-trade-mechanism.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["references.bib"],"comments":{"hypothesis":true},"theme":"lumen"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}