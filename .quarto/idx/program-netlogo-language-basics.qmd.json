{"title":"NetLogo language basics","markdown":{"headingText":"NetLogo language basics","headingAttr":{"id":"netlogo-language-basics","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nIn this session, we will learn more about NetLogo's programming language. We will start with the very basics to ease you into it, in case you are not familiar with any type of programming.\n\n::: {.callout-caution}\n\n**NOTE**\n\nIn the explanation below I'm using `<UPPERCASE_TEXT>` to express the positions in the code to be filled by the name of entities, variables, and other elements, depending on the context. For instance, `<COLOR> <FRUIT>` would represent many possible phrases, such as \"red apple\", \"brown kiwi\", etc. Beware that these fragments are only place holders and are not NetLogo code.\n\nFor now, we will interact freely with the program, without a particular file or model. The code snippets shown here can sometimes be executed directly, but will often not run without a proper context in code.\n\n:::\n\n## Console interaction\n\nAs a preamble, important to anyone without previous experiences with programming languages, the very first thing one can do in NetLogo is give oneself a bit of encouragement. In the **NetLogo interface**, go to the bottom area named **'Command Center'** and type the following in the empty field on the right of **'observer>'** and press Enter:\n\n```NetLogo\nYou can do it!\n```\n\nThe console prints:\n\n```\nERROR: Nothing named YOU has been defined. \n```\n\nOops! NetLogo still doesn't know \"you\". Or is it that it cannot *understand* you? Well let us get you two properly introduced...\n\n## Entities\n\nThe (real) first thing one should learn about NetLogo, and most agent-based modeling systems, is that it handles *mainly* two types of entities/agents: `patches`, cells of a square grid, and `turtles`, which are proper \"agents\" (i.e., mobile, autonomous entities). Both entities have *primitives* (built-in, default properties), some of which can be modified by processes in your model. For example, you can't modify the position of a patch, but you can change its filling color.\n\n<p style=\"text-align: center;\">\n<a title=\"NetLogo world and entities (Figure 2 in Izquierdo et al. 2019)\" href=\"https://wisc.pb.unizin.org/agent-based-evolutionary-game-dynamics/\"><img width=\"400\" style=\"background-color: white\" alt=\"NetLogo entities\" src=\"https://wisc.pb.unizin.org/app/uploads/sites/28/2018/09/the-netlogo-world.png\"></a>\n<br>\n<i style=\"color: grey;\">NetLogo world and entities (Figure 2 in Izquierdo et al. 2019)</i>\n</p>\n\nAs seen in the figure above, NetLogo also includes a third type of entity, `links`, which has the particularity of describing a connection between two `turtles` and thus not having specific spatial coordinates of their own. We will deal with links later on, but for now we focus on the other entities, which are more commonly used in models.\n\nAll `patches` and `turtles` can be identified individually through primitives. Turtles have a unique numerical identifier (`who`) that is assigned automatically upon the creation of the turtle. Patches, in turn, have an unique combination of x and y integer coordinates in 2D space (`pxcor` and `pycor`), as they occupy each a single position in a grid (see **Grid**). To reference a specific turtle or patch:\n\n```NetLogo\nturtle <WHO_NUMBER>\npatch <PXCOR> <PYCOR>\n```\n\nNetLogo allows you to define types of `turtles` as if it where a primitive, declarings its name as a `breed`:\n\n```NetLogo\nbreed [<BREED_1_NAME_PLURAL> <BREED_1_NAME_SINGULAR>]\n\nbreed [<BREED_2_NAME_PLURAL> <BREED_2_NAME_SINGULAR>]\n```\n\nWe can then use the plural or singular form of the `breed` name directly, instead of referring to the generic `turtles`.\n\n```NetLogo\n<BREED_1_NAME_SINGULAR> <WHO_NUMBER>\n```\n\nThis is useful, of course, when there are more the one `breed`to be defined, so that they are easily distinguished and inteligible in the code.\n\nAgents can be specifically selected also without considering their specific IDs. The `one-of` primitive offers a easy way to randomly select one agent (`turtles` and `patches`) from all (or a subset of all) agents of a given type.\n\n```NetLogo\none-of <BREED_2_NAME_PLURAL>\none-of patches\n```\n\nLast, we should keep in mind that `turtles` can be created and destroyed on-the-fly during simulations, while `patches` are created in the background upon initialisation, according to the model settings (*e.g.* grid dimensions), but never destroyed during simulation runs.\n\nSee NetLogo's documentation on agents for further details (https://ccl.northwestern.edu/netlogo/docs/programming.html#agents).\n\n## Variables\n\nThe most fundamental elements of NetLogo, as in any programming language, is variables. To assign a value to a variable we use the general syntax or code structure:\n\n```NetLogo\nset <VARIABLE_NAME> <VALUE>\n```\n\nWhile variable names are fragments of contiguous text following a naming convention (*e.g.* `my-variable`, `myVariable`, `my_variable`, etc.), values can be of the following data types:\n\n- Number (*e.g.*, `1`, `4.5`, `1E-6`)\n- Boolean (*i.e.*, `true`, `false`)\n- String (effectively text, but enclosed by quote marks: *e.g.*, `\"1\"`, `\"my value\"`)\n- `turtles`, `patches` (*i.e.*, NetLogo's computation entities; see **Entities**)\n- AgentSet (a set of either `turtles` or `patches`; see **Entities**)\n- List (a list enclosed in squared brakets with values of any kind separated by spaces: *e.g.*, `[ \"1\" 1 false my-agents-bunch [\"my value\" true 4.5] ]`)\n\nBefore we assign a value to a variable, we must declare its scope and name, though not its data type, which is only defined when assigning an specific value. Variable declaration is typically done at the first section of a model script and its exact position will depend on if it is stored globally or inside entities. These types of declarations follow their own structures:\n\n```NetLogo\nglobals [ <GLOBAL_VARIABLE_NAME> ]\n\nturtles-own [ <TURTLE_VARIABLE_NAME> ]\n\n<BREED_1_NAME_PLURAL>-own\n[ \n  <BREED_1_VARIABLE_1_NAME>\n  <BREED_1_VARIABLE_2_NAME>\n]\n\npatches-own [ <PATCHES_VARIABLE_NAME> ]\n```\n\nAs an exception to this general rule, variables can also be declared \"locally\" using the following syntaxes:\n\n```NetLogo\nlet <VARIABLE_NAME> <VALUE>\n```\n\nAs in other programming languages, having a variable declared locally means it is inside a temporary computation environment, such as a procedure (see below). Once the environment is closed, the variable is automatically discarded in the background.\n\n## Expressing equations\n\nAs we will see examples further on, the values of variables can be transformed in different ways, using different syntaxes, depending on their type. Possibly the most straightforward case is to perform basic arithmetic operations over numerical variables, expressing equations. These can be writen using the special characters normally used in most programming languages (`+`, `-`, `*`, `/`, `(`, etc.):\n\n```NetLogo\nset myVariable (2 + 2) * 10 / ((2 + 2) * 10)\n```\n\nNotice that arithmetic symbols and numbers must be separated by spaces and that the order of operations can be structured using parentheses.\n\nNetLogo allow line breaks, which can help you read expressions that are too long because they hold several operations. However, too many operation at a time can become hard to read and verify, even with line breaks. The best and safer practice to overcome this is to use parentheses abundantly to ensure the right sequence of operations is performed:\n\nValid\n```NetLogo\nset myVariable (\n  (\n    (2 + 2) * \n    10\n  ) / (\n    (2 + 2) * \n    10\n  )\n)\n```\n\nAdditionally, as proper equations, such expressions in NetLogo will also accept variables names representing their current value. Equations can then serve to create far reaching dependencies between different parts of the model code:\n\n```NetLogo\nset myVariable 2\nset myOtherVariable 10\n\n<...>\n\nlet myTemporaryVariable 2 * myVariable * myOtherVariable\n\nset myVariable myTemporaryVariable / myTemporaryVariable\n```\n\nIt will normally be better to keep operations in separate lines. However, be aware that NetLogo accepts sequential commands in the same line, as long as their syntax is correct:\n\n```NetLogo\nset myVariable 2 set myOtherVariable 10 let myTemporaryVariable 2 * myVariable * myOtherVariable set myVariable myTemporaryVariable / myTemporaryVariable\n```\n\nKnowing this, is particularly useful whenever you want to test the outcome of a longer command sequence in NetLogo's console (\"Command Center\"). \n\n## Logic operators\n\nAs most programming languages, NetLogo can evaluate equalities and inequalities and return a Boolean value (`true` or `false`). The related logical operators are:\n\n- `=`: \"equals\".  \n- `!=`: \"not equal to\".  \n- `>`: \"greater than\".  \n- `>=`: \"greater than or equal to\".  \n- `<`: \"less than\".  \n- `<=`: \"less than or equalt to\".\n\nFor example, try:\n\n```NetLogo\n1 >= 0\n```\n\n```NetLogo\n100 >= 100 + 1\n```\n\nEquality and inequality operators can also be used with other data types, though beware of the different implications. Some operations will return an error.\n\nFor example, you can compare Boolean values with `=` or `!=`:\n\n```NetLogo\ntrue = false\n```\n\nbut not with quantitative comparisons:\n\n```NetLogo\ntrue >= false\n```\n\nThe same applies to **lists** and **agent sets**, but not to **strings** or **entities** (turtles, patches, links):\n\nValid: check if the two lists are exactly the same.\n```NetLogo\n[1 2 3] = [ 1 ]\n```\nInvalid: a quantitative comparison between lists is not interpreted from this. \n```NetLogo\n[1 2 3] > [ 1 ]\n```\nValid: check if strings are exactly the same.\n```NetLogo\n\"apple\" = \"banana\"\n```\nValid: compares the length of the strings.\n```NetLogo\n\"apple\" >= \"banana\"\n```\nValid: checks if entities are the same (useful when entities are referenced indirectly by variables)\n```NetLogo\npatch 0 0 != patch 1 1\n```\nValid, but not recommended: compares the internal ID of entities, which express the creation order, which is often arbitrary.\n```NetLogo\nturtle 0 < turtle 1\npatch 0 0 > patch 1 1\n```\n\nNote that in other programming languages the equal sign might be reserved to setting the value of a variable. For example, `\"a\" = \"b\"` will return `false` in NetLogo, while in R it will assign a value \"b\" to an variable named \"a\". By the way, to acheive the same in R, we should write `\"a\" == \"b\"`.\n\n## Procedures\n\nIn NetLogo, any action we want to perform, that is not manually typed in the console, must be enclosed within a procedure that is declared in the model script (the text in **'Code'** tab in the user interface). Similarly to 'functions' or 'methods' in other programming languages, a procedure is the code scripted inside the following structure:\n\n```NetLogo\nto <PROCEDURE_NAME>\n  <PROCEDURE_CODE>\nend\n```\n\nAny procedure can be executed by typing `<PROCEDURE_NAME>` + Enter in the NetLogo's console at the bottom of the 'Interface' tab. The \"Hello World\" program, a typical minimum exercise when learning a programming language, correspond to the following procedure `hello-world`:\n\n```NetLogo\nto hello-world\n  print \"Hello World!\"\nend\n```\n\nwhich generates the following \"prints\" in the console:\n\n```\nobserver> hello-world\nHello World!\n```\n\nProcedures are particularly useful to group and enclose a sequence of commands that are semantically connected for the programmer. For example, the following procedure declares a temporary (local) variable, assigns to it a number as value, and prints it in the console:\n\n```NetLogo\nto set-it-and-show-me\n  let thisVariableOfMine 42\n  print thisVariableOfMine\nend\n```\n\nProcedures can then be used elsewhere by writing its name (more complications to come). A procedure can be included as a step in another procedure: \n\n```NetLogo\nto <PROCEDURE NAME>\n  <PROCEDURE_1>\n  <PROCEDURE_2>\n  <PROCEDURE_3>\n  ...\nend\n```\n\nNetLogo's interface editor allows us to create buttons that can execute one or multiple procedures (or even a snippet of *ad hoc* code). The interface system is quite straightforward. First, at the top of the interface tab, click \"Add\" and select a type of element in the drop-down list. Click anywhere in the window below to place it. Select it with click-dragging or using the \"Select\" option in the right-click pop-up menu. You can edit the element by selecting \"Edit\", also in the right-click pop-up menu. For any doubts on how to edit the interface tab, please refer to NetLogo's documentation (https://ccl.northwestern.edu/netlogo/docs/interfacetab.html).\n\n## Logic bifurcations: `if` and `ifelse`\n\n>The code exemplifies how to create conditional rules according to predefined general conditions using if/else statements, which in NetLogo can be written as `if` or `ifelse`:\n\n```NetLogo\nif (<CONDITION_1_IS_TRUE>)\n[\n  <DO_ACTION_A>\n]\n\nifelse (<CONDITION_2_IS_TRUE>)\n[\n  <DO_ACTION_B>\n]\n[\n  <DO_ACTION_C>\n]\n```\n\n## Iterators (*loops*)\n\nUsing `while`, we can use a structure similar to bifurcations, to reiterate over the same code a number of times as long as a logical condition is true:\n\n```NetLogo\nwhile [<CONDITION_1_IS_TRUE>]\n[\n  <DO_ACTION>\n]\n```\n\nNotice the use of square brackets to surround the condition (`[<CONDITION_1_IS_TRUE>]`).\n\nA variant of this is the primitive `loop`, where there is no condition, meaning that the action within will be repeated forever until the code inside stop the flow explicitly (`stop` or `report`), or the user interrupts NetLogo.\n\n```NetLogo\nloop\n[\n  <DO_SOMETHING>\n]\n```\n\n::: {.callout-caution}\n\n**ALERT**\n\nAvoid using `while` or `loop` until you are confident with you code. A loop hidden inside you code, that might go forever in a few cases, can become a headache when performing simulation experiments in batches.\n\n:::\n\nA more useful iterator is `repeat`, which will reiterate code a certain number of times:\n\n```NetLogo\nrepeat <NUMBER_OF_TIMES>\n[\n  <DO_SOMETHING>\n]\n```\n\nYou may quickly test it in the console with:\n\n```NetLogo\nlet counter 0 repeat 10 [  set counter counter + 1 ] print counter\n```\n\nA especial type of iterator abundantly used in NetLogo is `ask`. You can `ask` all or any subset of entities to perform specific commands by following the structure:\n\n```NetLogo\nask <ENTITIES>\n[ \n  <DO_SOMETHING>\n]\n```\n\n## Entities with variables, logic operations, and procedures\n\nCommands inside the `ask` structure can be both direct variable operations and procedures. For instance:\n\n```NetLogo\nask <BREED_1_NAME_PLURAL>\n[ \n  set <BREED_1_VARIABLE_2> <VALUE>\n  <PROCEDURE_1>\n  <PROCEDURE_2>\n  <PROCEDURE_3>\n]\n```\n\nHowever, all variables referenced inside these structures must be properly related to their scope, following NetLogo's syntax. For example, an agent is only able to access the variable in another agent if it we use the following kind of structure:\n\n```NetLogo\nask <BREED_1_NAME_PLURAL>\n[ \n  print [<BREED_1_VARIABLE_2>] of <BREED_2_NAME_SINGULAR> <WHO_NUMBER>\n]\n```\n\nIt is possible to select a subset of any set of entities through logic clauses to be checked separately for each individual entity. For example, to get all agents with a certain numeric property greater than a given threshold:\n\n```NetLogo\n<TYPE_NAME_PLURAL> with [ <VARIABLE_NAME_1> > <THRESHOLD> ]\n```\n\nWhen operating from the inside an `ask` command, we can also make sure to filter-out the agent currently performing the call, by using the primitive `other`:\n\n```NetLogo\nask <BREED_1_NAME_PLURAL>\n[\n  ask other <BREED_1_NAME_PLURAL>\n  [\n    print <WHO_NUMBER>\n  ]\n]\n```\n\nAll this can be combined to form quite complex rules of behaviour, yet keeping itself generally readable:\n\n```NetLogo\nto celebrate-birthday\n\n  ask people\n  [\n    if (today = my-birthday)\n    [\n      ask other people with [presents > 0]\n      [\n        give-present\n      ]\n    ]\n  ]\n\nend\n```\n\n## Grid\n\nOne should spend some time understanding the grid structure and associated syntax. It is recommendable to consult the \"settings\" pop-up window in the \"interface tab\":\n\n![The settings pop-up window in NetLogo](https://ccl.northwestern.edu/netlogo/docs/images/interfacetab/settings.gif)  \n*The settings pop-up window in NetLogo*\n\nThe default configuration is a 33x33 grid with the position (0,0) at the centre. Both dimensions and centre can be easily edited for each particular model. Moreover, we can specify agents behaviour at the borders by ticking the \"wrap\" options. Wrapping the world limits means that, for instance, under the default setting mentioned above, the position (-16,0) is adjacent to (16,0). In the console, we can \"ask\" the patch at (-16,0) to print its distance to the patch at (16,0), using the primitive function `distance` (https://ccl.northwestern.edu/netlogo/docs/dictionary.html#distance):\n\n```\nobserver> ask patch -16 0 [ print distance patch 16 0 ]\n1\n```\n\nWrapping one dimension represents a cylindrical surface while wrapping two depicts a strange toroidal object (Doughnut!). Although this aspect is relatively hidden among the options, it can have great importance if spatial relations play any part in a model. So if you want your grid to represent a geographical map, make sure to unpick the wrapping features.\n\n## Commenting code\n\nAnnotations or comments (i.e., text that should be ignored when executing the code) can be added to the code by using the structure:\n\n```NetLogo\n<CODE>\n; <FREE_TEXT>\n<CODE>\n```\n\nor\n\n```NetLogo\n<CODE> ; <FREE_TEXT>\n```\n\n## Dictionary\n\nOne of the most useful resources of NetLogo's documentation is the *dictionary* that can be accessed in the \"Help\" menu. This is true at any moment throughout your learning curve; even when you know all *primitives* and built-in functions by heart. Moreover, all documentation is present with any copy of NetLogo, so it is fully available offline. \n\nThe dictionary is particularly useful whenever you are learning by example, as in our case. For instance, regarding the earlier mention of `distance`, you could have searched it in the dictionary directly. Whenever you find yourself reading NetLogo code with violet or blue words that you do not understand, take the habit of searching them in NetLogo's *dictionary*.\n\nFor **more information** consult [NetLogo Programming Guide](https://ccl.northwestern.edu/netlogo/docs/programming.html).\n\n## Other platforms and languages\n\nConsider yourself introduced to NetLogo! However, please remember that ABM is not limited to this language and platform. It is highly recommended that you learn and practice with other programming languages to experience ABM models beyond NetLogo implementations.\n\nPotentially, any programming language can be used to implement an ABM model. However, it is useful to count on specific support software in most cases. A few of the most relevant platforms and libraries to know about are: [RePast](https://en.wikipedia.org/wiki/Repast_(modeling_toolkit)), [AnyLogic](https://www.anylogic.com/), [Mesa](https://mesa.readthedocs.io/), [Agents.jl](https://juliadynamics.github.io/Agents.jl/stable/), and [Pandora](http://xrubio.github.io/pandora/). See many others in [this list by SWARM.org](http://www.swarm.org/wiki/ABM_Resources).\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"svg","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["assets/styles.css"],"output-file":"program-netlogo-language-basics.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["references.bib"],"comments":{"hypothesis":true},"theme":"lumen"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}