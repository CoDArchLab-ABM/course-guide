{"title":"Calculating water flow accumulation","markdown":{"headingText":"Calculating water flow accumulation","headingAttr":{"id":"messara-water-flow","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n## Water flow algorithm\n\nTowards our calculation of land productivity, we advance using our GIS data in combination with parts of the Land submodel in the [Indus Village model](https://github.com/Andros-Spica/indus-village-model) (Angourakis 2021). Our objective in this step is to reach a flow accumulation value for each patch according to their relative elevation within the terrain. This will serve as a proxy of the region hydrology beyond the data we have on rivers.\n\nThe submodel is based on the algorithm described in Jenson & Domingue (1988) through the implementation used by Huang & Lee (2015).\n\n> Jenson, S. K., and J. O. Domingue. 1988. ‘Extracting Topographic Structure from Digital Elevation Data for Geographic Information System Analysis’. Photogrammetric Engineering and Remote Sensing 54 (11): 1593–1600.\n\n> Huang, Pin Chun, and Kwan Tun Lee. 2015. ‘A Simple Depression-Filling Method for Raster and Irregular Elevation Datasets’. Journal of Earth System Science 124 (8): 1653–65. https://doi.org/10.1007/s12040-015-0641-2.\n\n## Adding the main procedures\n\nThe algorithm uses a numeric codification of the eight neighbour directions and a tag that classifies patches as \"start\", \"pending\", \"done\", progressively converting the formers into the latter. Patches on the edge of the map are directed automatically towards the outside. Because this is an significant piece of code based on a specific reference, we will enclose all related procedures within a especial commentary note:\n\n```NetLogo\nglobals\n[\n  ...\n\n  ;;; variables\n  maxFlowAccumulation\n]\n\n...\n\npatches-own\n[\n  elevation ; elevation above sea level [m]\n\n  flow_direction        ; the numeric code for the (main) direction of flow or\n                        ; drainage within the land unit.\n                        ; Following Jenson & Domingue (1988) convention:\n                        ; NW = 64,   N = 128,        NE = 1,\n                        ; W = 32,     <CENTRE>,   E = 2,\n                        ; SW = 16,     S = 8,          SE = 4\n\n  flow_receive          ; Boolean variable stating whether or not the land unit receives\n                        ; the flow of a neighbour.\n\n  flow_accumulation     ; the amount of flow units accumulated in the land unit.\n                        ; A Flow unit is the volume of runoff water flowing from one land unit\n                        ; to another (assumed constant and without losses).\n  flow_accumulationState ; the state of the land unit regarding the calculation of flow\n                        ; accumulation (auxiliary variable).\n\n  isRiver\n]\n\n...\n\n;=======================================================================================================\n;;; START of algorithms based on:\n;;; Jenson, S. K., & Domingue, J. O. (1988).\n;;; Extracting topographic structure from digital elevation data for geographic information system analysis.\n;;; Photogrammetric engineering and remote sensing, 54(11), 1593-1600.\n;;; ===BUT used elsewhere, such as in the algorithms based on:\n;;; Huang, P., Lee, K.T. A simple depression-filling method for raster and irregular elevation datasets.\n;;; J Earth Syst Sci 124, 1653–1665 (2015). https://doi.org/10.1007/s12040-015-0641-2\n;=======================================================================================================\n\nto-report get-drop-from [ aPatch ] ; ego = patch\n\n  ; \"Distance- weighted drop is calculated by subtracting the neighbor’s value from the center cell’s value\n  ; and dividing by the distance from the center cell, √2 for a corner cell and one for a noncorner cell.\" (p. 1594)\n\n  report ([elevation] of aPatch - elevation) / (distance aPatch)\n\nend\n\nto-report is-at-edge ; ego = patch\n\n  report any? neighbors with [elevation = noElevationDataTag]\n\nend\n\nto-report has-flow-direction-code ; ego = patch\n\n  if (member? flow_direction [ 1 2 4 8 16 32 64 128 ]) [ report true ]\n\n  report false\n\nend\n\nto-report flow-direction-is [ centralPatch ]\n\n  if (flow_direction = get-flow-direction-encoding ([pxcor] of centralPatch - pxcor) ([pycor] of centralPatch - pycor))\n  [ report true ]\n\n  report false\n\nend\n\nto-report get-flow-direction-encoding [ x y ]\n\n  if (x = -1 and y = -1) [ report 16 ] ; Southwest\n  if (x = -1 and y = 0) [ report 32 ]  ; West\n  if (x = -1 and y = 1) [ report 64 ]  ; Northwest\n\n  if (x = 0 and y = -1) [ report 8 ]   ; South\n  if (x = 0 and y = 1) [ report 128 ]  ; North\n\n  if (x = 1 and y = -1) [ report 4 ]   ; Southeast\n  if (x = 1 and y = 0) [ report 2 ]    ; East\n  if (x = 1 and y = 1) [ report 1 ]    ; Northeast\n\nend\n\nto-report get-patch-in-flow-direction [ neighborEncoding ] ; ego = patch\n\n  ; 64 128 1\n  ; 32  x  2\n  ; 16  8  4\n\n  if (neighborEncoding = 16) [ report patch (pxcor - 1) (pycor - 1) ]\n  if (neighborEncoding = 32) [ report patch (pxcor - 1) (pycor) ]\n  if (neighborEncoding = 64) [ report patch (pxcor - 1) (pycor + 1) ]\n\n  if (neighborEncoding = 8) [ report patch (pxcor) (pycor - 1) ]\n  if (neighborEncoding = 128) [ report patch (pxcor) (pycor + 1) ]\n\n  if (neighborEncoding = 4) [ report patch (pxcor + 1) (pycor - 1) ]\n  if (neighborEncoding = 2) [ report patch (pxcor + 1) (pycor) ]\n  if (neighborEncoding = 1) [ report patch (pxcor + 1) (pycor + 1) ]\n\n  report nobody\n\nend\n\nto-report flow-direction-is-loop ; ego = patch\n\n  let thisPatch self\n  let dowstreamPatch get-patch-in-flow-direction flow_direction\n  ;print (word \"thisPatch: \" thisPatch \"dowstreamPatch: \" dowstreamPatch)\n\n  if (dowstreamPatch != nobody)\n  [ report [flow-direction-is thisPatch] of dowstreamPatch ]\n\n  report false\n\nend\n\nto set-flow-directions\n\n  ask patchesWithElevationData\n  [\n    ifelse (is-at-edge)\n    [\n      ifelse ( pxcor = min-pxcor )\n      [ set flow_direction 32 ] ; west\n      [\n        ifelse ( pxcor = max-pxcor )\n        [ set flow_direction 2 ] ; east\n        [\n          ifelse ( pycor = min-pycor )\n          [ set flow_direction 8 ] ; south\n          [ set flow_direction 128 ] ; north\n        ]\n      ]\n    ]\n    [\n      set-flow-direction\n    ]\n  ]\n\nend\n\nto set-flow-direction ; ego = patch\n\n  let thisPatch self\n\n  let downstreamPatch max-one-of neighbors with [elevation > noElevationDataTag] [get-drop-from thisPatch]\n  set flow_direction get-flow-direction-encoding ([pxcor] of downstreamPatch - pxcor) ([pycor] of downstreamPatch - pycor)\n\nend\n\nto set-flow-accumulations\n\n  ; From Jenson, S. K., & Domingue, J. O. (1988), p. 1594\n  ; \"FLOW ACCUMULATION DATA SET\n  ; The third procedure of the conditioning phase makes use of the flow direction data set to create the flow accumulation data set,\n  ; where each cell is assigned a value equal to the number of cells that flow to it (O’Callaghan and Mark, 1984).\n  ; Cells having a flow accumulation value of zero (to which no other cells flow) generally correspond to the pattern of ridges.\n  ; Because all cells in a depressionless DEM have a path to the data set edge, the pattern formed by highlighting cells\n  ; with values higher than some threshold delineates a fully connected drainage network.\"\n\n  ; identify patches that receive flow and those that do not (this makes the next step much easier)\n  ask patchesWithElevationData\n  [\n    set flow_receive false\n    set flow_accumulationState \"start\"\n    ;set pcolor red\n  ]\n\n  ask patchesWithElevationData with [has-flow-direction-code]\n  [\n    let patchInFlowDirection get-patch-in-flow-direction flow_direction\n    if (patchInFlowDirection != nobody)\n    [\n      ask patchInFlowDirection\n      [\n        set flow_receive true\n        set flow_accumulationState \"pending\"\n        ;set pcolor yellow\n      ]\n    ]\n  ]\n\n  let maxIterations 100000 ; just as a safety measure, to avoid infinite loop\n  while [count patchesWithElevationData with [flow_accumulationState = \"pending\" and not flow-direction-is-loop] > 0 and maxIterations > 0 and count patchesWithElevationData with [flow_accumulationState = \"start\"] > 0 ]\n  [\n    ask one-of patchesWithElevationData with [flow_accumulationState = \"start\"]\n    [\n      let downstreamPatch get-patch-in-flow-direction flow_direction\n      let nextFlow_accumulation flow_accumulation + 1\n\n      set flow_accumulationState \"done\"\n      ;set pcolor orange\n\n      if (downstreamPatch != nobody)\n      [\n        ask downstreamPatch\n        [\n          set flow_accumulation flow_accumulation + nextFlow_accumulation\n          if (count neighbors with [\n            elevation > noElevationDataTag and\n            get-patch-in-flow-direction flow_direction = downstreamPatch and\n            (flow_accumulationState = \"pending\" or flow_accumulationState = \"start\")\n            ] = 0\n          )\n          [\n            set flow_accumulationState \"start\"\n            ;set pcolor red\n          ]\n        ]\n      ]\n    ]\n\n    set maxIterations maxIterations - 1\n  ]\n\nend\n\n;=======================================================================================================\n;;; END of algorithms based on:\n;;; Jenson, S. K., & Domingue, J. O. (1988).\n;;; Extracting topographic structure from digital elevation data for geographic information system analysis.\n;;; Photogrammetric engineering and remote sensing, 54(11), 1593-1600.\n;;; ===BUT used in the algorithms based on:\n;;; Huang P C and Lee K T 2015\n;;; A simple depression-filling method for raster and irregular elevation datasets\n;;; J. Earth Syst. Sci. 124 1653–65\n;=======================================================================================================\n```\n\nOutside this enclosed section, we add the two main procedures `set-flow-directions` and `set-flow-accumulations` inside a higher level `setup-flows`:\n\n```NetLogo\nto setup-flows\n\n  fill-sinks\n  \n  set-flow-directions\n\n  set-flow-accumulations\n\n  ; set maximum flow accumulation as a reference\n  set maxFlowAccumulation max [flow_accumulation] of patchesWithElevationData\n\nend\n```\n\nWe add a last step to get `maxFlowAccumulation`, which we will need for scaling purposes.\n\n## Visualisation\n\nAs usual, we need to implement some extra code to be able to visualise the outcome. In this case, however, we would like to observe simultaneously flow direction, flow accumulation *and* elevation. For this, we will use an accessory agent type whose only function is representing the flow of patches on top of its colour.\n\n```NetLogo\nbreed [ flowHolders flowHolder ]\n\n...\n\nto display-flows\n\n  if (not any? flowHolders)\n  [\n    ask patchesWithElevationData [ sprout-flowHolders 1 [ set hidden? true ] ]\n  ]\n\n  ifelse (show-flows)\n  [\n    ask patchesWithElevationData\n    [\n      let flow_directionHere flow_direction\n      let nextPatchInFlow get-patch-in-flow-direction flow_direction\n      if (not [((elevation <= 0) or (elevation >= 0))] of nextPatchInFlow) [ set nextPatchInFlow nobody ]\n      let flow_accumulationHere flow_accumulation\n\n      ask one-of flowHolders-here\n      [\n        ifelse (nextPatchInFlow != nobody)\n        [\n          if (link-with one-of [flowHolders-here] of nextPatchInFlow = nobody)\n          [ create-link-with one-of [flowHolders-here] of nextPatchInFlow ]\n\n          ask link-with one-of [flowHolders-here] of nextPatchInFlow\n          [\n            set hidden? false\n            let multiplier 1E100 ^ (1 - flow_accumulationHere / (max [flow_accumulation] of patchesWithElevationData)) / 1E100\n            set color 92 + (5 * multiplier)\n            set thickness 0.4 * ( 1 - ((color - 92) / 5))\n          ]\n        ]\n        [\n          set hidden? false\n          let multiplier 1E100 ^ (1 - flow_accumulationHere / (max [flow_accumulation] of patchesWithElevationData)) / 1E100\n          set color 92 + (5 * multiplier)\n          if (color <= 97) [ set shape \"line half\" ]\n          if (color < 95) [ set shape \"line half 1\" ]\n          if (color < 93) [ set shape \"line half 2\" ]\n          set heading get-angle-in-flow-direction flow_direction\n        ]\n      ]\n    ]\n  ]\n  [\n    ask flowHolders\n    [\n      set hidden? true\n      ask my-links [ set hidden? true ]\n    ]\n  ]\n\nend\n\nto-report get-angle-in-flow-direction [ neighborEncoding ]\n\n  ; 64 128 1\n  ; 32  x  2\n  ; 16  8  4\n\n  if (neighborEncoding = 16) [ report 225 ]\n  if (neighborEncoding = 32) [ report 270 ]\n  if (neighborEncoding = 64) [ report 315 ]\n\n  if (neighborEncoding = 8) [ report 180 ]\n  if (neighborEncoding = 128) [ report 0 ]\n\n  if (neighborEncoding = 4) [ report 135 ]\n  if (neighborEncoding = 2) [ report 90 ]\n  if (neighborEncoding = 1) [ report 45 ]\n\n  report nobody\n\nend\n```\n\nNow, press \"setup\". The calculation of variables is made relatively fast, but displaying all flowHolders will take some time. \n\n![View of flow direction and accumulation, calculated with 'flows' module](assets/screenshots/BlockC_module2_flows.png)  \n*View of flow direction and accumulation, calculated with 'flows' module*\n\n## Assessing fit\n\nTo better visualise how much `flow_accumulation` actually gets accumulated, let us run the following \"highlight\" command directly in the console:\n\n```NetLogo\nask patches with [flow_accumulation > 10] [ set pcolor red ]\n```\n\n![Highlight of patches with flow accumulation greater than 10](assets/screenshots/BlockC_module2_flows-accumulation-more-than-10.png)  \n*Highlight of patches with flow accumulation greater than 10*\n\n\n*Focus view on a sample of patches:*  \n|  |  |\n| --- | --- |\n| patch 70 145 | <img src=\"assets/screenshots/BlockC_module2_flows-detail-patch-70-145.png\" width=\"200\"> |\n| patch 179 69 | <img src=\"assets/screenshots/BlockC_module2_flows-detail-patch-179-69.png\" width=\"200\"> |\n| patch 70 145 | <img src=\"assets/screenshots/BlockC_module2_flows-detail-patch-70-145.png\" width=\"200\"> |\n| patch 201 108 | <img src=\"assets/screenshots/BlockC_module2_flows-detail-patch-201-108.png\" width=\"200\"> |\n| patch 125 99 | <img src=\"assets/screenshots/BlockC_module2_flows-detail-patch-125-99.png\" width=\"200\"> |\n| patch 54 76 | <img src=\"assets/screenshots/BlockC_module2_flows-detail-patch-54-106.png\" width=\"200\"> |\n\nOur approximation of the region's hydrological system is definitely not perfect. As a minimum, we want the main river, Lithaíos, to emerge, even if following an approximated path. The problem is most likely generated by our previous step: reducing the resolution of the original DEM. The height map we are using has many \"sinks\" in it (*i.e.*, patches not at the edge with the lowest elevation among its neighbours).\n\nWorse, it might be that the roughness of the terrain escapes even the lowest of the resolutions treatable at this scale, to a point where the pathways of rivers cannot be retraced using height maps. Let us work with the first hypothesis and address the sinks in our processed height map.\n\n## Improving fit with `fill-sink`\n\nOur result could be improved by using the `fill-sink` procedure in the original Land model implementation (see code in the [Indus Village repository](https://github.com/Andros-Spica/indus-village-model/tree/master/03-land-model)), which is based on Huang & Lee (2015).\n\nThis procedure fills up the elevation of \"sink\" patches so flow can continue moving, until it reaches the edge of the map.\n\nFirst, we can identify sink patches with the following procedure:\n\n```NetLogo\nto-report is-sink ; ego = patch\n\n  let thisPatch self\n\n  report (not is-at-edge) and (elevation <= min [elevation] of neighbors with [((elevation <= 0) or (elevation >= 0))])\n\nend\n```\n\nWe then used it together with our previous \"highlight\" command in the console:\n\n```NetLogo\nask patches with [is-sink] [ set pcolor red ]\n```\n\n![Highlight of sink patches](assets/screenshots/BlockC_module2_flows-sinks.png)  \n*Highlight of sink patches*\n\nWe then implement the `fill-sinks` algorithm:\n\n```Netlogo\nto fill-sinks\n\n  while [ count patchesWithElevationData with [is-sink] > 0 ]\n  [\n    ask patchesWithElevationData with [is-sink]\n    [\n      set elevation [elevation] of min-one-of neighbors [elevation] + 1E-1\n    ]\n  ]\n\nend\n```\n\nAfter running `setup` again, we obtain a much better result. We can now clearly identify what should be the Lithaíos river and its path is not too far from our original river data.\n\n![View of flow direction and accumulation, calculated with 'flows' module with the `fill-sinks` procedure](assets/screenshots/BlockC_module2_flows_withFillSinks.png)  \n*View of flow direction and accumulation, calculated with 'flows' module with the `fill-sinks` procedure*\n\n![Highlight of patches with flow accumulation greater than 10](assets/screenshots/BlockC_module2_flows_withFillSinks_accumulation-more-than-10.png)  \n*Highlight of patches with flow accumulation greater than 10, after we include the `fill-sinks` procedure*\n\nWe should remember that this algorithm modifies our original DEM heightmap and costs more computation resources/time.\n\n## Implementing a feature to export and import `world`\n\nWe do not want to repeat this every time we initialise a simulation run. Therefore, we will export the entire map configuration to a file for later use. We do this quickly with \"File > Export... > Export World\" and selecting the data folder. We could write procedures specific for exporting (and importing) a subset of data. Still, this option is much faster, given that this is the initial spatial data we want for all further versions.\n\nStill, if you need to do this several times and want to keep track of the directory and file you are using, you can add a button to the interface with the following code, which is equivalent to the built-in option in the menu:\n\n```Netlogo\nexport-world \"data/terrainWithFlows/BlockC_module2_flows world.csv\"\n```\n\nThe same can be done to import the same file. Inside a new button, add:\n\n```Netlogo\nclear-all\nimport-world \"data/terrainWithFlows/BlockC_module2_flows world.csv\"\n```\n\nNow, you should be able to export and import your map with flows.\n\nSee the fully implemented version of this module: `BlockC_module2_flows.nlogo`.\n\nFor the sake of this example, we will assume our approximation to be sufficient. Still, tackling this kind of problem exploring other solutions in your own time could be an excellent exercise for improving your skills.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"svg","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["assets/styles.css"],"output-file":"messara-water-flow.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["references.bib"],"comments":{"hypothesis":true},"theme":"lumen"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}