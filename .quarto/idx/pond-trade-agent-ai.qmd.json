{"title":"Programming agent AI","markdown":{"headingText":"Programming agent AI","headingAttr":{"id":"pond-trade-agent-ai","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n## Modelling behaviour\n\nWe advance into implementing the behaviour rules, *i.e.* Artificial Inteligence, of each agent type, particularly `traders`. The conceptual model specifies the following: \n\n- `settlements`: produce goods according to their size and a productivity term. They create or destroy traders according to their current size. \n- `traders`: take some goods from their base and deliver them to another settlement, which is chosen based on the size of other settlements and the distance between these and the base settlement. Traders will then return with goods from that settlement back to the base and restart the cycle.\n\nImplementing this will take us several steps in development (up to step 9). Given the importance and potential complexity of these behaviours, let us start by implementing the most fundamental aspect: the traders' criterium for choosing a destination settlement. We have mentioned \"distance\", yet how should traders measure such distance in a heterogeneous terrain?\n\n## Implementing path finding\n\nIn the original repository of the PondTrade model, you will notice an initial attempt to approach this aspect through a simple network implementation, using NetLogo's `links` ([PondTrade_step07_agent AI v1_links.nlogo](https://github.com/Andros-Spica/PondTrade/blob/master/PondTrade_step07_agent%20AI%20v1_links.nlogo)). This approach is similar to other ABM and network-based models applied to topics of trade and settlement interactions.\n\nHowever, as you may know, there can be a significant difference between a straight line measurement (Euclidean distance) and a more complex path cost calculation that uses terrain data. As the PondTrade model eventually did, we will to \"complicate\" our design and make a proper \"least-cost route\" calculation using this as a perfect excuse for learning.\n\nBut how should we implement a least-cost path algorithm in NetLogo? We follow our modular philosophy, search and find an implementation of the [A* (A-star) algorithm in NetLogo User Community Models](http://ccl.northwestern.edu/netlogo/models/community/Astardemo1). We get the main fragment of the code and adapt it to our purposes, making sure we keep a clear reference to the source as a commentary header:shown. Do the same to check the information about this trader `base`. This time, however, write the `inspect settlement <WHO NUMBER>` directly into the console. You can now verify that the trader and settlement were assigned the same colour.\n\n```NetLogo\npatches-own\n[\n  isLand\n  pathCost\n  \n  ;;; path-finding related\n  parent-patch ; patch's predecessor\n  f ; the value of knowledge plus heuristic cost function f()\n  g ; the value of knowledge cost function g()\n  h ; the value of heuristic cost function h()\n]\n\n...\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; A* path finding algorithm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; modified from Meghendra Singh's Astardemo1 model in NetLogo User Community Models\n; http://ccl.northwestern.edu/netlogo/models/community/Astardemo1\n; modified lines/fragments are marked with \";-------------------------------*\"\n; In this version, patches have different movement cost.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n; the actual implementation of the A* path finding algorithm\n; it takes the source and destination patches as inputs\n; and reports the optimal path if one exists between them as output\nto-report find-a-path [ source-patch destination-patch]\n\n  ; initialize all variables to default values\n  let search-done? false\n  let search-path []\n  let current-patch 0\n  let open [] ;-------------------------------*\n  let closed [] ;-------------------------------*\n\n  ;-------------------------------*\n  ask patches with [ f != 0 ]\n  [\n    set f 0\n    set h 0\n    set g 0\n  ]\n  ;-------------------------------*\n\n  ; add source patch in the open list\n  set open lput source-patch open\n\n  ; loop until we reach the destination or the open list becomes empty\n  while [ search-done? != true]\n  [\n    ifelse length open != 0\n    [\n      ; sort the patches in open list in increasing order of their f() values\n      set open sort-by [ [?1 ?2] -> [f] of ?1 < [f] of ?2 ] open\n\n      ; take the first patch in the open list\n      ; as the current patch (which is currently being explored (n))\n      ; and remove it from the open list\n      set current-patch item 0 open\n      set open remove-item 0 open\n\n      ; add the current patch to the closed list\n      set closed lput current-patch closed\n\n      ; explore the Von Neumann (left, right, top and bottom) neighbors of the current patch\n      ask current-patch\n      [\n        ; if any of the neighbors is the destination stop the search process\n        ifelse any? neighbors4 with [ (pxcor = [ pxcor ] of destination-patch) and (pycor = [pycor] of destination-patch)] ;-------------------------------*\n        [\n          set search-done? true\n        ]\n        [\n          ; the neighbors should not already explored patches (part of the closed list)\n          ask neighbors4 with [ (not member? self closed) and (self != parent-patch) ] ;-------------------------------*\n          [\n            ; the neighbors to be explored should also not be the source or\n            ; destination patches or already a part of the open list (unexplored patches list)\n            if not member? self open and self != source-patch and self != destination-patch\n            [\n              ;set pcolor 45 ;-------------------------------*\n\n              ; add the eligible patch to the open list\n              set open lput self open\n\n              ; update the path finding variables of the eligible patch\n              set parent-patch current-patch\n              set g [g] of parent-patch + pathCost ;-------------------------------*\n              set h distance destination-patch\n              set f (g + h)\n            ]\n          ]\n        ]\n;        if self != source-patch ;-------------------------------*\n;        [\n;          set pcolor 35\n;        ]\n      ]\n    ]\n    [\n      ; if a path is not found (search is incomplete) and the open list is exhausted\n      ; display a user message and report an empty search path list.\n      user-message( \"A path from the source to the destination does not exist.\" )\n      report []\n    ]\n  ]\n\n  ; if a path is found (search completed) add the current patch\n  ; (node adjacent to the destination) to the search path.\n  set search-path lput current-patch search-path\n\n  ; trace the search path from the current patch\n  ; all the way to the source patch using the parent patch\n  ; variable which was set during the search for every patch that was explored\n  let temp first search-path\n  while [ temp != source-patch ]\n  [\n;    ask temp ;-------------------------------*\n;    [\n;      set pcolor 85\n;    ]\n    set search-path lput [parent-patch] of temp search-path\n    set temp [parent-patch] of temp\n  ]\n\n  ; add the destination patch to the front of the search path\n  set search-path fput destination-patch search-path\n\n  ; reverse the search path so that it starts from a patch adjacent to the\n  ; source patch and ends at the destination patch\n  set search-path reverse search-path\n\n  ; report the search path\n  report search-path\nend\n```\n\nBecause our model assigns different path costs for each patch (*i.e.*, land or water), we must create a new procedure that assigns these costs and add a call to it just after the other steps in `create-map`:\n\n```NetLogo\nto create-map\n\n  ...\n\n  assign-path-cost\n\n  paint-patches\n\nend\n\n...\n\nto assign-path-cost\n\n  ask patches\n  [\n    ifelse (isLand = false)\n    [ set pathCost 1 ] ; arbitrary unit for now\n    [ set pathCost relativePathCostInLand ] ; defined by parameter in relation to the cost of path in water (i.e., 1)\n  ]\n\nend\n```\n\nWe are forced then to introduce another parameter, `relativePathCostInLand`, which specifies how much the movement on land costs in relation to the movement on the water. Add a slider in the interface (from 0 to 100, by 0.01, default value at 50).\n\nGiven the special circumstance of traders arriving and leaving settlements, let us introduce a differential value for `pathCost` in patches with settlements. For this we should modify `create-coastal-settlements` and introduce the parameter `relativePathCostInPort` (from 0 to 100, by 0.01, default value at 10):\n\n```NetLogo\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 + random 10 ; sets a random arbitrary size level for the settlement (between 1 and 10)\n\n        ; give meaningful display proportional to size\n        set shape \"circle 2\"\n        set size 1 + sizeLevel / 3\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\n```\n\nNotice that `relativePathCostInPort` will generally not affect A* results since routes will always have two patches with this `pathCost`. However, it does matter because routes will more likely avoid going through a third settlement if a path through water is available.\n\n## Testing the algorithm\n\nYou can now experiment with the A* algorithm by running `setup`as it is, and then `find-a-path` between two patches of your choosing. To observe how the algorithm works, you can \"uncomment\" the lines, including code about colouring patches within the algorithm code. Then, reduce the simulation speed in the interface and rerun the procedure.\n\n|  |  |  |  |\n| --- | --- | --- | --- |\n| <img src=\"assets/screenshots/BlockB_PondTrade_step07_agent AI v2_AStar view-process0.png\" width=\"100\"> | <img src=\"assets/screenshots/BlockB_PondTrade_step07_agent AI v2_AStar view-process1.png\" width=\"100\"> | <img src=\"assets/screenshots/BlockB_PondTrade_step07_agent AI v2_AStar view-process2.png\" width=\"100\"> | <img src=\"assets/screenshots/BlockB_PondTrade_step07_agent AI v2_AStar view-process3.png\" width=\"100\"> |\n\nNotice how the large difference in path cost between land and water (x50) makes A* avoid drawing a route through land, practically until all adjacent water patches are explored.\n\n## Adapting model schedule\n\nNow that we have confirmed the code we just introduced let us implement everything we will need to call A* and keep track of all routes between settlements. Given that A* takes time to compute, we should make everything possible to avoid repeating the calculation of routes.\n\n```NetLogo\nglobals [ routes ]\n\n...\n\nto setup\n\n  reset-timer\n  clear-all\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n\n  create-map\n\n  create-coastal-settlements\n\n  set-routes\n\n  create-traders-per-settlement\n\n  update-display\n\n  output-print (word \"Set up took \" timer \" seconds.\")\n\nend\n\n...\n\nto set-routes\n\n  set routes [] ; initialize/reset the routes as an empty list\n\n  let settlementsWithoutRoutes settlements ; helper variable to keep track of which settlement already searched for routes\n\n  ask settlements\n  [\n    let thisSettlement self\n\n    ask other settlementsWithoutRoutes\n    [\n      let optimalRoute find-a-path ([patch-here] of thisSettlement) ([patch-here] of self) ; find the optimal route to this settlement\n      set routes lput optimalRoute routes ; add the optimal route to the end of the routes list\n\n      ; paint route patches in shades of red depending on route frequency\n      foreach optimalRoute\n      [ ?1 ->\n        ask ?1\n        [\n          ifelse (pcolor = 106 or pcolor = 54) ; if its the first route crossing the patch\n          [\n            set pcolor 11\n          ]\n          [\n            set pcolor min (list (pcolor + 1) (19)) ; sets a maximum at 19 (the brightest)\n          ]\n        ]\n      ]\n    ]\n\n    set settlementsWithoutRoutes other settlementsWithoutRoutes\n\n  ]\n\nend\n```\n\nRunning the code as it is will generate the maximum number of routes given the settlements present (*e.g.*, if `numberOfSettlements = 10`, it will be 45 or 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1). We store each route as a `list` of `patches`, and all routes as a `list` of routes (`routes`). These will be globally accessible by all traders in our model.\n\nNotice that it takes a considerable time to calculate all possible routes, and the number of settlements increases this time exponentially. At this point, we should be aware of how to stop NetLogo while still running a long command. Go to Tools > Halt. This might not work if NetLogo interface is unresponsive. Then the only options are to wait or quit or force-quit NetLogo.\n\n## Decision making\n\nHaving the calculation of routes solved, we now must use them to inform the decision of traders. Let us create a procedure to be called by traders named `choose-destination`, for which we will need to implement a few \"helper\" procedures:\n\n```NetLogo\ntraders-own [ base route destination direction lastPosition ]\n\n...\n\nto choose-destination ; ego = trader\n\n  let thisTrader self\n\n  ; get routes connecting the base settlement\n  let routesFromBase get-routes-from-settlement [base] of thisTrader\n\n  ; order these routes by benefit/cost ratio\n  set routesFromBase sort-by [ [?1 ?2] -> benefit-cost-of-route ?1 > benefit-cost-of-route ?2 ] routesFromBase\n\n  ; print the options available\n;  foreach routesFromBase\n;  [\n;    print \"===============================================================\"\n;    print \"route between:\"\n;    print [who] of get-origin-and-destination ?\n;    print \"has the benefit-cost ratio of:\"\n;    print benefit-cost-of-route ?\n;  ]\n;  print \"-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x\"\n\n  ; select the one with higher benefit/cost ratio\n  set route first routesFromBase\n\n  ; mark the most effective route\n  foreach route\n  [ ?1 ->\n    ask ?1 [ set pcolor yellow ]\n  ]\n\n  ; get the settlement of destination\n  set destination one-of (get-origin-and-destination route) with [who != [who] of ([base] of thisTrader)]\n\nend\n\n...\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Get and set routes (helper 'to-report' procedures) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\nto-report get-route [ settlement1 settlement2 ] ; accepts two settlements and returns a route\n\n  ; get routes connecting settlement1\n  let routesFromSettlement1 filter\n  [ ?1 ->\n    ([one-of settlements-here] of first ?1 = settlement1) or\n    ([one-of settlements-here] of last ?1 = settlement1)\n  ] routes\n\n  ; get the route connecting settlement2 from the previous list\n  let routeFromSettlement1ToSettlement2 filter\n  [ ?1 ->\n    ([one-of settlements-here] of first ?1 = settlement2) or\n    ([one-of settlements-here] of last ?1 = settlement2)\n  ] routesFromSettlement1\n\n  report first routeFromSettlement1ToSettlement2\n\nend\n\nto-report get-routes-from-settlement [ aSettlement ] ; accepts a settlement and return a list of routes\n\n  report filter\n  [ ?1 ->\n    ([one-of settlements-here] of first ?1 = aSettlement) or\n    ([one-of settlements-here] of last ?1 = aSettlement)\n  ] routes\n\nend\n\nto-report get-origin-and-destination [ aRoute ] ; accepts a route and returns a turtle-set with two settlements\n\n  report (turtle-set ([ one-of settlements-here ] of first aRoute) ([one-of settlements-here ] of last aRoute))\n\nend\n\nto-report benefit-cost-of-route [ aRoute ] ; accepts a route and returns a number (the benefit/cost ratio of the route)\n\n  let cost 0\n\n  foreach aRoute ; for every patch in the given route\n  [ ?1 ->\n    set cost cost + [pathCost] of ?1\n  ]\n\n  let originAndDestination get-origin-and-destination aRoute\n  let benefit 0\n  ask originAndDestination [ set benefit benefit + sizeLevel ] ; the benefit is the sum of the sizeLevel of the two settlements\n\n  report benefit / cost\n\nend\n```\n\nNotice that `get-route` is only helpful for debugging and querying the information in `routes`.\n\nTo inform the traders' decisions, we specify a very simple calculation of the potential gain of a route (sum of sizeLevel of origin and destination) and calculate a ratio between the benefit and cost of routes. Traders will then compare these ratios for all possible routes from its base settlement and choose the one with the highest value.\n\n## Movement\n\nOnce a destination is decided, traders must move towards it and then, once there, start the return trip. We implement this behaviour assuming that movement must go through each patch center in the route and that traders move at a maximum speed of `1 / [pathCost] of patch-here`, meaning they will be delayed in proportion to the local value of `pathCost`. \n\n```NetLogo\nto move-to-destination ; ego = trader\n\n  ; update lastPosition if in a patch center\n  if ((xcor = [pxcor] of patch-here) and (ycor = [pycor] of patch-here))\n  [\n    set lastPosition patch-here\n  ]\n  ; find where in the route list is the trader\n  let currentPosition position lastPosition route\n\n  ; set direction if in a settlement\n  ifelse (currentPosition = 0) ; in the first extreme of the route list\n  [\n    set direction 1 ; move in the route list towards larger index numbers\n  ]\n  [\n    if (currentPosition = (length route - 1)) ; in the last extreme of the route list\n    [\n      set direction -1 ; move in the route list towards smaller index numbers\n    ]\n  ]\n  ; else the trader is in route to either the base or the destination\n\n  ; move through the route following direction\n  let targetPatch item (currentPosition + direction) route\n  ;move-to targetPatch ; constant travel time (1 patch per tick)\n  facexy ([pxcor] of targetPatch) ([pycor] of targetPatch)\n  forward min (\n    list\n    (1 / [pathCost] of patch-here) ; the maximum distance in a tick in the current patch\n    (distancexy ([pxcor] of targetPatch) ([pycor] of targetPatch)) ; the distance to the target patch\n    )\n\nend\n```\n\nWe wrap up this development step by finally implementing our preliminary model cycle, ordering the behaviour of traders within the conventional `go` procedure:\n\n```NetLogo\nto go\n\n  ask traders\n  [\n    if (patch-here = [patch-here] of base) ; update the destination whenever in the base settlement\n    [\n      choose-destination\n    ]\n    move-to-destination\n  ]\n\nend\n```\n\nAs we specified in our conceptual model, traders will choose a destination whenever they are at their base and move towards their current destination.\n\n## Enhancing visualisation\n\nTo help visualise routes, implement the following version of `update-display`, call it at the end of `setup`, and add two switches, `showRoutes` and `showActiveRoutes` to the interface:\n\n```NetLogo\nto setup\n\n  clear-all\n  reset-ticks\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n\n  create-map\n\n  create-coastal-settlements\n\n  set-routes\n\n  create-traders-per-settlement\n\n  update-display\n\nend\n\n...\n\nto update-display\n\n  paint-routes\n  paint-active-routes\n\n  ; scale the size of settlements according to their dynamic free-scaled sizeLevel\n  let maxSettlementSize max [sizeLevel] of settlements\n\n  ask settlements\n  [\n    set hidden? not showSettlements\n    set size 1 + (sizeLevel / maxSettlementSize) * 9\n  ]\n\nend\n\nto paint-routes\n\n  ; resets route patches to the terrain color\n  foreach routes\n  [ ?1 ->\n    let aRoute ?1\n\n    foreach aRoute\n    [ ??1 ->\n      ask ??1 [ paint-terrain ]\n    ]\n  ]\n\n  ; paint route patches in shades of red depending on route frequency\n  foreach routes\n  [ ?1 ->\n    let aRoute ?1\n\n    foreach aRoute\n    [ ??1 ->\n      ask ??1\n      [\n        if (showRoutes)\n        [\n          ifelse (pcolor < 11 or pcolor > 19) ; if its the first route crossing the patch\n          [\n            set pcolor 11\n          ]\n          [\n            set pcolor min (list (pcolor + 1) (19)) ; sets a maximum at 19 (the brightest)\n          ]\n        ]\n      ]\n    ]\n  ]\n\nend\n\nto paint-active-routes\n\n  ask traders\n  [\n    foreach route\n    [ ?1 ->\n      ask ?1\n      [\n        ifelse (showActiveRoutes)\n        [\n          set pcolor yellow\n        ]\n        [\n          if (not showRoutes) ; if not displaying all routes\n          [\n            ; resets to the patch terrain color\n            paint-terrain\n          ]\n        ]\n      ]\n    ]\n  ]\n\nend\n```\n\n## Testing agent behaviour\n\nAs a temporary \"hack\", replace the code `create-traders-per-settlement` with the following:\n\n```NetLogo\nto create-traders-per-settlement\n\n  ; For now, we create only one trader to better control its behaviour\n  ask one-of settlements\n  [\n    let thisSettlement self\n\n    hatch-traders 1\n    [\n      set base thisSettlement\n\n      set shape \"sailboat side\" ; import this shape from the library (Tools > Shape editor > import from library)\n      set color [color] of base\n      set size 3\n    ]\n  ]\n\n; the previous code for creating traders can be commented out\n; by adding ';' at the beggining of each line, or\n; by selecting several lines and either selecting 'Edit > Comment' or pressing 'ctrl + ;'.\n;  ask settlements\n;  [\n;    let thisSettlement self ; to avoid the confusion of nested agent queries\n;    hatch-traders round sizeLevel ; use the sizeLevel variable as the number of traders based in the settlement\n;    [\n;      set base thisSettlement\n;\n;      ; give meaningful display related to base\n;      set shape \"sailboat side\" ; import this shape from the library (Tools > Shape editor > import from library)\n;      set color [color] of base\n;      set size 3\n;\n;      ; place it somewhere in the pond, randomly for now (if not, the command \"hatch-breed\" will place them in the same patch of the settlement)\n;      move-to one-of patches with [isLand = false]\n;    ]\n;  ]\n\nend\n```\n\nReduce `numberOfSettlements`, vary `seed`, and run `setup` again. Run `go` repeatedly to observe the behaviour of the loner trader.\n\n![Pond Trade step 7](assets/screenshots/BlockB_PondTrade_step07_agent AI-v2_AStar-interface.png)  \n*Pond Trade step 7*\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"svg","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["assets/styles.css"],"output-file":"pond-trade-agent-ai.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["references.bib"],"comments":{"hypothesis":true},"theme":"lumen"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}