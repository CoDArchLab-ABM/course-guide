[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Agent-based modelling for archaeologists. From concept to application and publication",
    "section": "",
    "text": "Course overview\nAgent-based modelling for archaeologists. From concept to application and publication (14436.0398)\nTime slot: Monday, 10:00-11:30\nPlace: Küpperstift, Kerpener Str., 30, 2nd floor (125/02) CoDArchLab\nCourse instructor: Andreas Angourakis",
    "crumbs": [
      "Course overview"
    ]
  },
  {
    "objectID": "index.html#course-summary",
    "href": "index.html#course-summary",
    "title": "Agent-based modelling for archaeologists. From concept to application and publication",
    "section": "Course summary",
    "text": "Course summary\nThis course introduces the basic concepts and workflow of simulation and agent-based modelling (ABM), as used in archaeology.\nMore specifically, we will cover the prototyping of a conceptual model into a working simulation model, the ‘refactoring’ of code (cleaning, restructuring, optimizing), the re-use of published model parts and algorithms, the exploration of alternative designs, and the use of geographic, climatic and archaeological data to frame the model in a specific case study.\nThis tutorial uses NetLogo, a flexible well-established modelling platform known for its relatively low-level entry requirements in terms of programming experience. It has been particularly used in social sciences and ecology for research and educational purposes.\nThe course offers implementation examples of least path cost algorithms, hydrological and land productivity modelling, network dynamics, and cultural evolution. Additionally, we learn the basics of Git and GitHub for version control, which will help us organize, maintain, and share models and related materials.",
    "crumbs": [
      "Course overview"
    ]
  },
  {
    "objectID": "index.html#course-schedule",
    "href": "index.html#course-schedule",
    "title": "Agent-based modelling for archaeologists. From concept to application and publication",
    "section": "Course schedule",
    "text": "Course schedule\n\n\n\n\n\n\n\n\n\n\n\nDate\nTopic\n\n\n\n\n1\n2025-10-20\nIntroduction\n\n\n2\n2025-10-27\nLearning to model processes\n\n\n3\n2025-11-03\nPreparing as a software developer\n\n\n4\n2025-11-10\nProgramming for simulation modelling\n\n\n5\n2025-11-17\nPond Trade (I): basics and cellular automata\n\n\n6\n2025-11-24\nPond Trade (II): agents and mechanisms\n\n\n7\n2025-12-01\nPond Trade (III): advanced mechanisms, output stats and modularity\n\n\n8\n2025-12-08\nMessara Trade (I): case, design and spatial input data\n\n\n9\n2025-12-15\nMessara Trade (II): time-series input data and plugging modules\n\n\n10\n2026-01-05\nMessara Trade (III): verification, optimisation, refactoring and extension\n\n\n11\n2026-01-12\nDesigning and running Simulation experiments\n\n\n12\n2026-01-19\nAnalysis of simulation results\n\n\n13\n2026-01-26\nfree practice\n\n\n14\n2026-02-02\nfree practice",
    "crumbs": [
      "Course overview"
    ]
  },
  {
    "objectID": "index.html#evaluation",
    "href": "index.html#evaluation",
    "title": "Agent-based modelling for archaeologists. From concept to application and publication",
    "section": "Evaluation",
    "text": "Evaluation\nAttendance and completion of small exercises, individually or as a group.",
    "crumbs": [
      "Course overview"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Agent-based modelling for archaeologists. From concept to application and publication",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThe conception of the course structure, as well as the short summaries, exercises, and images shown in each chapter, greatly benefited from Large Language Models used as companion writer and programmer. As such, we own greatly to the current richness of reference information freely available on Internet.\nThe models and services used are:\n\nChatGPT (GPT-4o) by OpenAI for brainstorming, text and code drafting and writing suggestions, code refactoring and documentation, and collection and articulation of references.\n\nGoogle NotebookLM for summary of references and text writing suggestions.\nWebChatGPT, a free browser extension that enhances ChatGPT by providing Internet access directly within the chat interface, used to aid Internet search.\nLeonardo.ai (user tokens) for generating purely aesthetic visual assets.",
    "crumbs": [
      "Course overview"
    ]
  },
  {
    "objectID": "intro-abm.html",
    "href": "intro-abm.html",
    "title": "1  Introduction to ABM",
    "section": "",
    "text": "1.1 A teaser: Schelling’s segregation model\nAgent-based modelling (ABM) is a powerful tool for studying complexity by creating dynamic simulations using formal definitions, rules, and populations, resulting in the study of emergent properties in social and ecological systems. By adopting a bottom-up perspective, it allows for a deeper understanding of the processes that shape real-world phenomena.\nTo better contextualise ABM, we start by positioning this modelling approach in relation to other modelling approaches. We then describe ABM’s central concepts, including what makes it often more intuitive and adequate for representing certain types of phenomena, particularly social interactions, yet paradoxically being more complex and unpredictable than other simulation models.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm.html#abm-as-a-tool-for-complexity",
    "href": "intro-abm.html#abm-as-a-tool-for-complexity",
    "title": "1  Introduction to ABM",
    "section": "1.2 ABM as a tool for complexity",
    "text": "1.2 ABM as a tool for complexity\nAgent-based modelling (ABM) is a tool that can be used to explore phenomena through the lens of complexity science, that is as manifestations of complex systems. Complex systems are characterized by a high number and diversity of causal relationships, non-linearity (feedback loops), self-organization, self-similarity, and path dependence. Complex adaptive systems are a special case of complex systems, one that is considered able to adapt to (and learn from) its environment. Such systems are better understood through its smaller parts and their interaction.\n\nABM is a methodological framework that allows researchers to simulate the dynamics of complex systems. The approach involves:\n\nFormalizing definitions of elements within the system.\nDefining rules as algorithms to govern interactions between elements.\nSimulating a population as distributed processes.\nCreating a bottom-up approach to modelling to study emergent properties.\nIncorporating stochasticity to generate probabilistic results.\n\nGame of Life - breeder\n Flocking behaviour in ‘Behavioral systems’ by Danil Nagy in ‘Generative Design’, medium.com\nABM is a type of simulation that is particularly useful for modelling social systems because it allows for the representation of human agency and interaction. In ABM, a phenomenon is modelled through populations of autonomous agents and their interactions. This approach contrasts with other modelling techniques that represent causal components as aggregated variables and parameters. The use of distributed computation allows for the generation of complex dynamics that are not reducible to analytical solutions. ABM is also useful for exploring the emergence of social patterns and structures from the bottom up.\nABM is a modular approach that can integrate parts from other modelling approaches, allowing for a more comprehensive representation of complex systems. For example, ABM can integrate environmental and spatial aspects, the agency of individuals and institutions, group formation, cooperation and competition, cognitive processes, and communication. In archaeology and other disciplines such as geography and environmental sciences, this multi-paradigm approach has been favoured. The approach aligns well with the study of socio-ecological systems (SES) which acknowledges the interrelationships between natural and artificial worlds.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm.html#abm-as-mathematical-models",
    "href": "intro-abm.html#abm-as-mathematical-models",
    "title": "1  Introduction to ABM",
    "section": "1.3 ABM as mathematical models",
    "text": "1.3 ABM as mathematical models\nAgent-based models, like all simulation models, are a type of mathematical model. As the term is used in science, we can define models as representations of a system or a phenomenon through its essential characteristics, often involving elements, relationships, and underlying assumptions. Mathematical models are simply more advanced in their logical definition through the process of formalisation. The informal or less formal models are those that are defined only through natural language speech (e.g., in a live discussion), text (e.g., in an article or book), or through certain graphical pieces (e.g., infographics, diagrams).\nDespite this distinction, there is no genuine opposition between models with different levels of formalisation. Mathematical formalisation is mainly used to implement and test the logic models stated less formally. Among the advantages of mathematical formalisation, the most important are univocity (i.e., things have a single definition) and commensurability (i.e. things can be measured or counted). These properties set formal models apart from models formulated purely with natural languages, among other things, allowing for a significant improvement in the robustness of our reasoning. Keep in mind, though: formalisation can also harm the intelligibility of our models, because they move away from natural languages.\nWithin the large family of mathematical models, ABM models lie typically within a category that can be characterised as explicative or mechanistic. Explicative models are focused on an explanation, expressing processes through realistic causal relationships between variables, often including assumptions. Non-explicative or descriptive mathematical models are used more strictly to describe, reproduce or extrapolate the relationship between variables (i.e., most statistical models). The latter models are about patterns or trends in data, while the former are about the mechanisms underlying data, at least as we can define them based on our current understanding of the phenomena’s domain. Unlike descriptive models, explanatory models seek to explain why a phenomenon occurs by formalizing mechanisms through causal relationships.\n\nThe line between these categories is blurred and confounded by many models and model users. Notice, for example, that the very term “explanation” is widely used in non-mechanistic ways (e.g., when it is said that the educational level of a person explains that person’s income). However, the bulk of models on each side is considerable, and ABM models, in particular, have traits that are undeniably linked to the formulation of mechanisms.\nTo help understand this distinction, we can think about one of the most simple and popular descriptive models used today: the linear regression model.\n\nWe use this regression models to summarise the relationship between two variables in a dataset by finding a line that best fit the point distribution. In the case of the simple linear regression, we define a parametric equation that corresponds to a straight line in an Cartesian two-dimensional space:\n\ny = a + b·x\n\n\nGeometric representation of a linear regression model\nA linear regression model has two variables, x and y, which define two orthogonal dimensions, and two parameters, a and b, which determine the value of y when x = 0 and the tangent of the angle formed by the line with the x dimension. These are “meaningless” (semantically empty) in the model design, even if we deliberately choose x as the “independent” variable, despite how they are interpreted at a higher level of analysis.\nThe semantic emptiness of descriptive models might seem irrelevant at first. A linear regression does help us to understand data and can make effective predictions. However, the meaning of these understandings and predictions comes from our explanatory models, which are only loosely connected to the equation we use. Assuming descriptive model and interpretation are directly connected can lead to misrepresenting data, or, worse, lead to faulty reasoning about the underlying phenomenon.\n\nTo put an archaeological example, imagine we have two variables measured in a collection of sites, the estimated maximum area and the count of potsherds on the surface. Imagine that we can define a regression model that states a positive correlation exists between them. Assuming our dataset is large enough and not radically biased, we could probably interpret that built area influences (i.e., causes, in a weak sense) the abundance of potsherds on the surface. It would not be necessarily illogical to conclude this. Yet, the relationship described in the model is ultimately a correlation (no archaeologist would think that one is directly causing the other).\n\n\n\n\n\n\nNote\n\n\n\n\n\nTarget reality:\n \n\n\nObservations:\n\n\n\nDescriptive model:\n\nA model that return the output given the input\n\n\nExplanatory model:\n \nA model that returns the output given the input and the definition of a mechanism\n\n\n\n\n\nThe trend expressed by the linear model is but a “hint” of the mechanisms that are or could be postulated to explain it. Any hypotheses about the reason behind the correlation must be formulated outside the model, before or after its creation, for instance, by combining it with a natural language model. Thus, a descriptive model is inherently incomplete as an analytic tool and remains trivial unless it is associated with an external explicative model, formal or informal.\nStill, descriptive mathematical models have been proven to be very useful and are widely adopted. Consider that in the field of artificial intelligence, the success of the descriptive models encompassed by machine learning have pushed aside other modelling approaches that uses programmed or procedural rules, from which ABM has branched. Within the exploration of data-driven methods, some scholars have even started to question the concept of “explanation” itself, posing that it might be a well-hidden fallacy of human cognition. On the other hand, it is still debatable how much human understanding can come from descriptive models alone.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm.html#abm-as-simulation-models",
    "href": "intro-abm.html#abm-as-simulation-models",
    "title": "1  Introduction to ABM",
    "section": "1.4 ABM as simulation models",
    "text": "1.4 ABM as simulation models\n\n“a situation in which a particular set of conditions is created artificially in order to study or experience something that could exist in reality.” Oxford Advanced American Dictionary\n\n\n“a: the imitative representation of the functioning of one system or process by means of the functioning of another a computer simulation of an industrial process\nb: examination of a problem often not subject to direct experimentation by means of a simulating device” simulation, Merrian-Webster\n\n\n“A simulation is an imitative representation of a process or system that could exist in the real world. In this broad sense, simulation can often be used interchangeably with model. Sometimes a clear distinction between the two terms is made, in which simulations require the use of models; the model represents the key characteristics or behaviors of the selected system or process, whereas the simulation represents the evolution of the model over time. Another way to distinguish between the terms is to define simulation as experimentation with the help of a model.” Simulation, Wikipedia\n\n\n1.4.1 Algorithmic process\nSimulation is a numerical approach to solve mathematical models. Simulation models are mathematical models that describe a mechanism and when iterated or repeated can represent a process, i.e. change through time caused by the mechanism. They are particularly useful for studying complex systems with non-linear relationships and feedback loops, and can help to generate data that can be used to test the validity of the model. There is a large variety of approaches in simulation; however, they all share this fundamental intent of representation of a process.\n\n\n\n\n\n\nNote\n\n\n\n\n\nFruit-in-the-basket simulation model\nentities: basket, fruits, us (basket-fillers).\nmechanism: a basket can contain \\(N\\) fruits (fruit-basket relationship), we can add fruits to the basket (us-fruit and us-basket relationships).\nsimulation step: if the basket is not full, we add \\(X\\) fruits or less to the basket.\nprocess or dynamics: an empty basket will get full with \\(N\\) fruits after \\(T\\) steps have passed, where \\(T={ceiling}(N/X)\\).\nexplanatory meaning: Why the basket has \\(N\\) fruits? Because (a) it can only hold \\(N\\) fruits, and (b) we have added \\(X\\) fruits \\(T\\) times.\n\n\n\n\n\n\n\n\n\n\nPseudo-code for the Gale–Shapley algorithm to solve the Stable Marriage Problem\n\n\n\n\n1.4.2 Distributed processes\nSocial simulation models, specifically, apply these methods to social science topics, emphasizing the role of human agency and distributed computation. Agent-based modelling (ABM) is a common technique in social simulation, representing a phenomenon through populations of autonomous agents and their interactions.\nGalan et al. 2009\nHeppenstall and Crooks 2016\nRebaudo et al. 2011\nIn contrast with other mechanistic and dynamic mathematical modelling approaches, ABM seeks to represent a phenomenon by explicitly modelling its parts. Therefore, ABM involves the expectation that the phenomenon at the macro-level emerges (can be deduced) from the dynamics at the micro-level. Moreover, ABM implies that the parts, the agents, constitute ‘populations’, i.e., they share common properties and behavioural rules. The ‘agency’ behind the term ‘agent’ also implies that these parts have certain autonomy with respect to each other and the environment, which justifies simulating their behaviour at an individual level.\nIn practice, ‘autonomy’ often translates as the agents’ ability to take action, move, decide, or even think and remember. Decision-making is a central aspect of agents and most agent designs can be sufficiently expressed as flowcharts. Nevertheless, agent-based models also include entities that are technically agents (on the terms of multi-agent systems), but lack many of such abilities or are not considered real/material discrete entities. The most common case is to represent space sectors as agents fixed to unique positions in a grid to facilitate the implementation of distributed spatial processes (e.g., the growth of vegetation dependent on local factors). This type of agent is more commonly named as “cellular automaton” (cellular automata, in plural), In NetLogo, these entities are predefined as patches and are extensively used in combination with mobile agents in models in ecology and geography.\n\n\n1.4.3 Stochasticity\nAn important and distinctive aspect of agent-based models is that they are unavoidably stochastic, i.e., at least some processes are fed by random sequences. By definition, the order in which agents of a type perform their processes should not be predefined and, overall, should not be the same followed every iteration of the model. Thus, the only unbiased way of scheduling processes in ABM is to randomize all distributed sequences. This is (usually) not the case in models based on differential/difference equations, where the equations calculating variables are solved following a particular fixed order.\nMethodologically, introducing randomness is a way of accounting for the entire spectrum of possibilities, whenever a certain aspect of the model is undertheorised or cannot be controlled in real scenarios. More importantly, it is justified whenever the modeller believes that the intended behaviour is independent of a specific value or order.\nFor those with no previous experience with computer science: note that “random” for a computer is not like “rolling dices”. We are getting values of a preordered sequence presumably unrelated to the process at hand. The programs creating these sequences are called pseudorandom number generator or RNG, for short. Sequences will be different every time we run our program (i.e., simulation), unless we preset the RNG using a specific ‘seed’, an integer often spanning a massive range of positive and negative numbers. Setting a particular RNG seed is, in fact, good practice, and helps enforce the reproducibility of simulation results.\nThis technique is also helpful in creating variation within a population of agents or between the global conditions of simulation runs. Such a thing is accomplished by drawing the values of variables from probability distributions, defined through hyperparameters (e.g., drawing the age of individuals in a classroom from a normal distribution defined by two parameters, age_mean and age_standardDeviation). Unfortunately, a typical bad practice is not exposing such hyperparameters, having these ‘hard-coded’ as if their value were an intrinsic part of the model and thus the mechanisms it represents. This bad coding element, often called “magic numbers”, can and should be addressed during model implementation.\n\n\n1.4.4 A point of comparison: Lotka-VolterraPredator-prey model\nCompared to other modelling and simulation approaches, ABM is more intuitive but also more complex.\nFor example, the Lotka-Volterra predator-prey model in ecology is a pair of differential equations that are relatively simple and conceptually straightforward.\n\\[\n\\frac{dx}{dt}=\\alpha x-\\beta xy\n\\] \\[\n\\frac{dy}{dt}=\\gamma y+\\delta xy\n\\]\nwhere \\(x\\) and \\(y\\) are the population density of prey and predator, respectively. \\(\\alpha\\) and \\(\\gamma\\) are the maximum intrinsic growth rate of each population and \\(\\beta\\) and \\(\\delta\\) are the effect of the presence of predators on prey and of prey on predators. Note that the first effect is negative and the second is positive.\nThis simple model has became very famous for being able to express the following dynamics:\n\nassumption: prey population grows based on unspecified resources (intrinsic growth rate)\nmore prey → more food for predators, so more predators will survive and reproduce\nmore predators → more prey will be killed, so less prey will survive and reproduce\nless prey → less food for predators, so fewer predators will survive and reproduce\nfewer predators → less prey will be killed, so more prey will survive and reproduce\nmore prey → more food … (the cycle begins again)\n\n\n  Example of Lotka Volterra dynamics\n\nThe same model can also be implemented with ABM (see the comparison in NetLogo’s Model Library Wolf-Sheep Predation (Docked Hybrid)). The ABM implementation requires many additional specifications on how predator and prey agents should behave individually. Even though it is not strictly necessary to represent the core mechanism, ABM variations of the Lotka-Volterra model often aim to include more complexity. In the case of the Wolf-Sheep model mentioned, there is an explicit account of the base resource (i.e., the prey of the prey), named grass, which is implemented as a property of spatial units. These additional specifications normally help the model be more intuitive and realistic but also significantly complicate the model design and implementation, even though generating similar aggregate dynamics as the equation-based version (i.e., oscillation harmony between prey and predator populations).\n\n  NetLogo user interface running the Wolf-Sheep Predation model",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm.html#abm-its-probably-multiparadigm-modelling",
    "href": "intro-abm.html#abm-its-probably-multiparadigm-modelling",
    "title": "1  Introduction to ABM",
    "section": "1.5 ABM? It’s probably multiparadigm modelling",
    "text": "1.5 ABM? It’s probably multiparadigm modelling\nLast, another significant advantage of ABM is that it can include parts (algorithms, submodels) that belong to other modelling approaches. For example, we can quickly devise a model where a population of agents runs in parallel with a full-fledged Dynamic Systems model through a set of difference equations. Commonly, ABM models are ensembles created with parts that technically are not ABM. This is why some ABM modellers and modelling platforms use terms like “multiparadigm modelling” or “hybrid modelling”, which is more precise for many cases. Unfortunately, these were not adopted more widely and “agent-based modelling” continues to be the most common term, particularly in archaeology.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm-arch.html",
    "href": "intro-abm-arch.html",
    "title": "2  ABM in archaeology",
    "section": "",
    "text": "2.1 A transdisciplinary approach\nABM has conceptual roots and applications in other fields relatively early, hand-to-hand with the history of computer science. However, this methodology was formed as it is today and introduced more broadly into social sciences only in the 1990s.\nABM has been exceptionally well-accepted by archaeologists, given its pre-adaptation towards distributed and stochastic processes. Most phenomena of interest for archaeology can be represented with ABM, to the satisfaction of archaeologists. Other modelling and simulation approaches (e.g., Dynamic Systems) were and still are used but often encounter great resistance due to their higher abstraction and simplification.\nABM flexibility is also very much appreciated by researchers involved in archaeology, given that it is a discipline both historically and thematically positioned in between other disciplines in the overlap of the so-called natural and artificial worlds. An ABM model can handle multiple layers of entities and relationships, allowing it to integrate entire models under the same hood.\nThe same advantage was exploited by disciplines such as ecology, environmental science, and geography. The approach used by these disciplines has been the main motor driving the development of models in archaeology for more than two decades. Some authors have named this transdisciplinary framework as the research of socio-ecological systems (SES), which has been defined in close relationship with the more general complexity science approach. One of the first cases of public success of ABM in archaeology, the model that become known as Artificial Anasazi model (Axtell et al. 2002), emerged from this approach and as a collaboration between researchers orbiting the Santa Fe Institute.\nDespite its positive influence in pushing the field forward, the SES approach has also limited the diversity of scope and theory used with ABM in archaeology. ABM under SES aligns particularly well, for example, with research questions related to landscape and environmental archaeology and formulated from a perspective biased towards processualism. This tutorial is no exception. To the potential “new blood” in this field, I recommend always keeping the mind open to all questions and theoretical frameworks, particularly those you are already invested in.\nABM in archaeology has been a prolific field, despite being still enclosed in a small community. Here, we will only cover a small part of the field, specifically from my perspective. For a broader introduction to the multitude of contributions in this field, I refer to any of the many introductions included in References. I recommend the recent textbook by Romanowska, Wren & Crabtree (2021), which also includes many practical exercises in NetLogo, using a programming style and philosophy significantly different from this tutorial.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ABM in archaeology</span>"
    ]
  },
  {
    "objectID": "intro-abm-arch.html#domains-of-application-and-examples",
    "href": "intro-abm-arch.html#domains-of-application-and-examples",
    "title": "2  ABM in archaeology",
    "section": "2.2 Domains of application and examples",
    "text": "2.2 Domains of application and examples\nHere is a non-exhaustive list of examples of simulation and ABM in archaeology organised by topics:\n\nPhysico-chemical dynamics\n\nArtefact production: operational chain (chaîne opératóire), authorship and style, material transformations during manufacturing (Sorensen and Scherjon 2018), use and deposition (Gravel-Miguel and Wren 2018).\n\nSite formation: distribution of artefacts and structures (Gravel-Miguel and Wren 2018), preservation, strata formation and taphonomy (Davies, Holdaway, and Fanning 2016), sample bias.\n\nEcological dynamics\n\nClimate patterns: seasonality (Angourakis, Bates, et al. 2022), regional variations, climate change (Bocquet-Appel et al. 2014).\n\nSoils: erosion and sediment accumulation (Kabora, Stump, and Wainwright 2020; Robinson et al. 2018; Ullah, Chang, and Tourtellotte 2019).\nHydrological dynamics: water availability, run-off, irrigation (Altaweel and Watanabe 2012a; Altaweel and Watanabe 2012b).\nVegetation: plant domestication (Angourakis, Alcaina-Mateos, et al. 2022), crop dynamics (Angourakis, Bates, et al. 2022; Baum et al. 2016; Boogers and Daems 2022; Christiansen and Altaweel 2006; Joyce 2019; Robinson et al. 2018), deforestation and fires (Boogers and Daems 2022; Nikulina et al. 2024; Snitker 2021, 2018).\n\nNon-human animal behaviour: dynamics of wild populations under human influence (Morrison and Allen 2017), domestic animal population dynamics (Günther et al. 2021), herd behaviour, animal husbandry, transhumance (Günther et al. 2021) (See also the Dairy-versus-Transhumance model, my own work, still under development).\n\nAnthropological dynamics\n\nIndividuals: pedestrian dynamics (M. Lake 2001), foraging (Brantingham 2006; Oestmo, Janssen, and Marean 2016), metabolism, kinship (Rogers 2013), health and population dynamics (mating and marriage, reproduction, mortality) (Verhagen 2019), cognition (memory, rationality and learning) (Mokom 2015; Premo and Tostevin 2016; Sousa, Correia, and Garcia-marques 2019; Acerbi, Mesoudi, and Smolla 2020), individual-to-individual cooperation and competition (Graham 2009; Sousa, Correia, and Garcia-marques 2019; White 2013).\nGroups: household organization and microeconomics (Christiansen and Altaweel 2006; Joyce 2019), emergence of alliances and organisations (Cioffi-Revilla, Honeychurch, and Rogers 2015; White 2013), group-to-group cooperation and competition (Angourakis et al. 2014, 2015, 2017; Cioffi-Revilla, Honeychurch, and Rogers 2015; Rogers 2013), group mobility (Rogers 2013; Santos et al. 2015), logistics and military tactics (Rubio Campillo, Cela, and Hernàndez Cardona 2012; Rubio-Campillo, Cela, and Cardona 2014; Verhagen 2019), prestige, reward and punishment, social learning, cultural transmission and norm emergence (Gower-Winter 2022; Mokom 2015; Premo and Tostevin 2016; Drost and Vander Linden 2018; Acerbi, Mesoudi, and Smolla 2020).\nSettlements: population dynamics (Verhagen 2019; Crema 2014), resource exploitation (Boogers and Daems 2022), trade (Carrignon, Brughmans, and Romanowska 2020; Chliaoutakis and Chalkiadakis 2020; Lawall and Graham 2018; Ortega et al. 2014; Sakahira et al. 2021), migration, macro-economics, urbanisation, cultural evolution (Carrignon, Brughmans, and Romanowska 2020; Gower-Winter 2022; M. W. Lake and Crema 2012; Mokom 2015; Sakahira et al. 2021), settlement patterns and land use (Altaweel, Palmisano, and Hritz 2015; Chliaoutakis and Chalkiadakis 2020; Angourakis et al. 2014, 2017; Boogers and Daems 2022; Joyce 2019; Robinson et al. 2018; Rogers 2013; Snitker 2018; Ullah, Chang, and Tourtellotte 2019), politogenesis (Cioffi-Revilla, Honeychurch, and Rogers 2015; Rogers 2013; Turchin 2018), catastrophic collapse or abandonment (Kohler and Varien 2012; McAnany et al. 2015).\nRegional to global: cooperation and competition between territorial states (Turchin 2018), trade routes (Chliaoutakis and Chalkiadakis 2020; Lawall and Graham 2018; Ortega et al. 2014), human species dispersal (Callegari et al. 2013) and genetic and cultural diffusions (Bocquet-Appel et al. 2014; Kovacevic et al. 2015; Mokom 2015)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ABM in archaeology</span>"
    ]
  },
  {
    "objectID": "intro-abm-arch.html#examples",
    "href": "intro-abm-arch.html#examples",
    "title": "2  ABM in archaeology",
    "section": "2.3 Examples",
    "text": "2.3 Examples\n\n“Artificial Anasazi” (Axtell et al. 2002; Janssen 2009)\n\n\n\n\nArtificial Anasazi model in NetLogo\n\n\nThe Artificial Anasazi model was developed to explore population dynamics in Long House Valley, Arizona. The model represents a population of households, with a simplified food economy based on maize cultivation. By simulating this system, researchers were able to test the hypothesis that climate change was the main cause of the abandonment of the valley.\n  \n\n“HOMINIDS” (Griffith, Long, and Sept 2010)\n\n\n\n\n\n\nGriffin et al. 2010, Fig. 1\n\n\n\n\n\n\n\nGriffin et al. 2010, Fig. 6b\n\n\n\n\n\n“MedLanD” (Barton et al. 2012)\n\n\n\n\n\n\nBarton et al. 2012, Fig. 2\n\n\n\n\n\n\n\nBarton et al. 2012, Fig. 12\n\n\n\n\n\n“HouseholdsWorld” (Rogers et al. 2012)\n\n\n\n\n\n\nRogers et al. 2012, Fig. 2\n\n\n\n\n\n\n\nRogers et al. 2012, Fig. 12\n\n\n\n\n\nMayaSim (Heckbert 2013)\n\n\n\n\n\n\n\n\n\n\n“Indus Village” (Angourakis 2021; Angourakis et al. 2020; Angourakis, Bates, et al. 2022; Angourakis, Baudouin, and Petrie 2025)\n\n\n\n\n\n\n\n\n\nrepository: https://github.com/Andros-Spica/indus-village-model",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ABM in archaeology</span>"
    ]
  },
  {
    "objectID": "intro-abm-arch.html#unfinished-business-representation-and-validation",
    "href": "intro-abm-arch.html#unfinished-business-representation-and-validation",
    "title": "2  ABM in archaeology",
    "section": "2.4 Unfinished business: representation and validation",
    "text": "2.4 Unfinished business: representation and validation\nDespite the relative success and proliferation of agent-based modelling in archaeology, there is still an unsolved debate over the epistemological nature of simulation models as explanatory.\nTo be explanatory, models must connect to a process as a phenomenon, as it is defined to the best of our knowledge (representation), and the evidence we raise and select as relevant (validation). Both archaeologists and non-simulation modellers sometimes dismiss agent-based models in archaeology as faring too far from the realm of archaeological evidence. Why should we dare (or even bother) to simulate past processes that cannot be observed through material remains?\nIt is, unfortunately, too easy to ignore the difference between descriptive and explicative models and leave archaeological interpretations imposed on descriptive models unchecked by formalisation. When a descriptive mathematical model is used, a good validation result (fit given an evidence set) does not guarantee that the interpretative model represents the process to which it is attributed. More importantly, good validation can be confused with a good representation.\nFor example, imagine we, as archaeologists, are convinced that humans were able to feed on a certain kind of rock at some remote point in the past. When applying the most robust methods in cartography and inferential statistics on the evidence of human presence and findings of such rocks, we might find that a positive correlation confirms our belief. However, the representation link between our interpretation and the reality of the past process is weak. Our belief would only hold while impermeable to formalisation and a larger knowledge background. Alternatively, perhaps, we would quickly realise the metabolic constraints of stone digestion.\nModelling is about structuring your thoughts about the world, and mathematical modelling does that with extra discipline. Explanatory and, particularly, simulation modelling, however, is doing that specifically for reconstructing processes, stories, or, in other words, the mechanisms or webs of causality that we presume to be behind the semi-static reality we observe (e.g., archaeological materials).\nNon-simulation computational modelling in archaeological research \nSimulation modelling in archaeological research \nWe will practice the distinction between phenomena, evidence and mechanism when designing our own conceptual model.\n\n\n\n\nAcerbi, Alberto, Alex Mesoudi, and Marco Smolla. 2020. “Individual-Based Models of Cultural Evolution. A Step-by-Step Guide Using R.” OSF. https://doi.org/10.31219/osf.io/32v6a.\n\n\nAltaweel, Mark, Alessio Palmisano, and Carrie Hritz. 2015. “Evaluating Settlement Structures in the Ancient Near East Using Spatial Interaction Entropy Maximization.” Structure and Dynamics: eJournal of Anthropological and Related Sciences 8 (1). https://doi.org/10.5070/SD981028281.\n\n\nAltaweel, Mark, and Chikako Watanabe. 2012a. “Salinization MASS Model Version.” https://doi.pangaea.de/10.1594/PANGAEA.778611.\n\n\nAltaweel, Mark, and Chikako E. Watanabe. 2012b. “Assessing the Resilience of Irrigation Agriculture: Applying a Social–Ecological Model for Understanding the Mitigation of Salinization.” Journal of Archaeological Science 39 (4): 1160–71. https://doi.org/10.1016/j.jas.2011.12.020.\n\n\nAngourakis, Andreas. 2021. “Two-Rains/Indus-Village-Model: The Indus Village Model Development Files (May 2021).” Zenodo. https://doi.org/10.5281/zenodo.4814255.\n\n\nAngourakis, Andreas, Jonas Alcaina-Mateos, Marco Madella, and Debora Zurro. 2022. “Human-Plant Coevolution: A Modelling Framework for Theory-Building on the Origins of Agriculture.” PLOS ONE 17 (9): e0260904. https://doi.org/10.1371/journal.pone.0260904.\n\n\nAngourakis, Andreas, Jennifer Bates, Jean-Philippe Baudouin, Alena Giesche, M Cemre Ustunkaya, Nathan Wright, Ravindra N Singh, and Cameron A Petrie. 2020. “How to ‘Downsize’ a Complex Society: An Agent-Based Modelling Approach to Assess the Resilience of Indus Civilisation Settlements to Past Climate Change.” Environmental Research Letters 15 (11): 115004. https://doi.org/10.1088/1748-9326/abacf9.\n\n\nAngourakis, Andreas, Jennifer Bates, Jean-Philippe Baudouin, Alena Giesche, Joanna R. Walker, M. Cemre Ustunkaya, Nathan Wright, Ravindra Nath Singh, and Cameron A. Petrie. 2022. “Weather, Land and Crops in the Indus Village Model: A Simulation Framework for Crop Dynamics Under Environmental Variability and Climate Change in the Indus Civilisation.” Quaternary 5 (2): 25. https://doi.org/10.3390/quat5020025.\n\n\nAngourakis, Andreas, Jean-Philippe Baudouin, and Cameron A. Petrie. 2025. “The Weather Model (Indus Village): Procedural Generation of Daily Weather for the Simulation of Small-Scale Socioecological Systems.” Environmental Modelling & Software 193 (September): 106634. https://doi.org/10.1016/j.envsoft.2025.106634.\n\n\nAngourakis, Andreas, Bernardo Rondelli, Sebastian Stride, Xavier Rubio-Campillo, Andrea L. Balbo, Alexis Torrano, Verònica Martinez, Marco Madella, and Josep M. Gurt. 2014. “Land Use Patterns in Central Asia. Step 1: The Musical Chairs Model.” Journal of Archaeological Method and Theory 21 (2): 405–25. https://doi.org/10.1007/s10816-013-9197-0.\n\n\nAngourakis, Andreas, Matthieu Salpeteur, Verònica Martínez Ferreras, Josep Maria Gurt Esparraguera, Verònica Martínez Ferreras, and Josep Maria Gurt Esparraguera. 2017. “The Nice Musical Chairs Model: Exploring the Role of Competition and Cooperation Between Farming and Herding in the Formation of Land Use Patterns in Arid Afro-Eurasia.” Journal of Archaeological Method and Theory 24 (4): 1177–1202. https://doi.org/10.1007/s10816-016-9309-8.\n\n\nAngourakis, Andreas, José Ignacio Santos, José Manuel Galán, and Andrea L. Balbo. 2015. “Food for All: An Agent-Based Model to Explore the Emergence and Implications of Cooperation for Food Storage.” Environmental Archaeology 20 (4): 349–63. https://doi.org/10.1179/1749631414Y.0000000041.\n\n\nAxtell, Robert L., Joshua M. Epstein, Jeffrey S. Dean, George J. Gumerman, Alan C. Swedlund, Jason Harburger, Shubha Chakravarty, Ross Hammond, Jon Parker, and Miles Parker. 2002. “Population Growth and Collapse in a Multiagent Model of the Kayenta Anasazi in Long House Valley.” Proceedings of the National Academy of Sciences 99 (Supplement 3): 7275–79. https://doi.org/10.1073/pnas.092080799.\n\n\nBarton, C. Michael, Isaac I. T. Ullah, Sean M. Bergin, Helena Mitasova, and Hessam Sarjoughian. 2012. “Looking for the Future in the Past: Long-Term Change in Socioecological Systems.” Ecological Modelling 241 (August): 42–53. https://doi.org/10.1016/J.ECOLMODEL.2012.02.010.\n\n\nBaum, Tilman, Claas Nendel, Stefanie Jacomet, Miquel Colobran, and Renate Ebersbach. 2016. “‘Slash and Burn’ or ‘Weed and Manure’? A Modelling Approach to Explore Hypotheses of Late Neolithic Crop Cultivation in Pre-Alpine Wetland Sites.” Vegetation History and Archaeobotany 25 (6): 611–27. https://doi.org/10.1007/s00334-016-0583-x.\n\n\nBocquet-Appel, Jean-Pierre, Jérôme Dubouloz, Richard Moussa, Jean-François Berger, Anne Tresset, Elena Ortu, Jean-Denis Vigne, et al. 2014. “Multi-Agent Modelling of the Trajectory of the LBK Neolithic: A Study in Progress.” In Early Farmers: The View from Archaeology and Science, edited by Alasdair Whittle and Penny Bickle, 0. British Academy. https://doi.org/10.5871/bacad/9780197265758.003.0004.\n\n\nBoogers, Stef, and Dries Daems. 2022. “SAGAscape: Simulating Resource Exploitation Strategies in Iron Age to Hellenistic Communities in Southwest Anatolia.” Journal of Computer Applications in Archaeology 5 (1): 169–87. https://doi.org/10.5334/jcaa.90.\n\n\nBrantingham, P. Jeffrey. 2006. “Measuring Forager Mobility.” Current Anthropology 47 (3): 435–59. https://doi.org/10.1086/503062.\n\n\nCallegari, Simone, John David Weissmann, Natalie Tkachenko, Wesley P. Petersen, George Lake, Marcia Ponce De León, and Christoph P. E. Zollikofer. 2013. “An Agent-Based Model of Human Dispersals at a Global Scale.” Advances in Complex Systems 16 (04n05): 1350023. https://doi.org/10.1142/S0219525913500239.\n\n\nCarrignon, Simon, Tom Brughmans, and Iza Romanowska. 2020. “Tableware Trade in the Roman East: Exploring Cultural and Economic Transmission with Agent-Based Modelling and Approximate Bayesian Computation.” Edited by Sergi Lozano. PLOS ONE 15 (11): e0240414. https://doi.org/10.1371/journal.pone.0240414.\n\n\nChliaoutakis, Angelos, and Georgios Chalkiadakis. 2020. “An Agent-Based Model for Simulating Intersettlement Trade in Past Societies.” JASSS 23 (3). https://doi.org/10.18564/jasss.4341.\n\n\nChristiansen, John H., and Mark R Altaweel. 2006. “Simulation of Natural and Social Process Interactions.” Social Science Computer Review 24 (2): 209–26. https://doi.org/10.1177/0894439305281500.\n\n\nCioffi-Revilla, Claudio, William Honeychurch, and J. Daniel Rogers. 2015. “MASON Hierarchies: A Long-Range Agent Model of Power, Conflict, and Environment in Inner Asia.” In The Complexity of Interaction Along the Eurasian Steppe Zone in the First Millennium AD: Empires, Cities, Nomads and Farmers, 39–63. Bonn: Bonn University Press. http://krasnow.gmu.edu/socialcomplexity/files/2015/09/Cioffi-Revilla-et-al.Hierarchies-2015.pdf.\n\n\nCrema, Enrico R. 2014. “A Simulation Model of Fission-Fusion Dynamics and Long-Term Settlement Change.” Journal of Archaeological Method and Theory 21 (2): 385–404. https://doi.org/10.1007/s10816-013-9185-4.\n\n\nDavies, Benjamin, Simon J Holdaway, and Patricia C Fanning. 2016. “Modelling the Palimpsest: An Exploratory Agent-Based Model of Surface Archaeological Deposit Formation in a Fluvial Arid Australian Landscape.” The Holocene 26 (3): 450–63. https://doi.org/10.1177/0959683615609754.\n\n\nDrost, Cornelis J., and Marc Vander Linden. 2018. “Toy Story: Homophily, Transmission and the Use of Simple Simulation Models for Assessing Variability in the Archaeological Record.” Journal of Archaeological Method and Theory 25 (4): 1087–1108. https://doi.org/10.1007/s10816-018-9394-y.\n\n\nGower-Winter, Brandon. 2022. “Self-Adapting Simulated Artificial Societies.” Master’s thesis, Cape Town: University of Cape Town. https://sit.uct.ac.za/sites/default/files/media/documents/sit_uct_ac_za/2591/2022-self-adapting_simulated_artificial_societies.pdf.\n\n\nGraham, Shawn. 2009. “Behaviour Space: Simulating Roman Social Life and Civil Violence.” Digital Studies / Le Champ Numérique 1 (2). https://doi.org/10.16995/dscn.109.\n\n\nGravel-Miguel, Claudine, and Colin D. Wren. 2018. “Agent-Based Least-Cost Path Analysis and the Diffusion of Cantabrian Lower Magdalenian Engraved Scapulae.” Journal of Archaeological Science 99 (November): 1–9. https://doi.org/10.1016/j.jas.2018.08.014.\n\n\nGriffith, Cameron S., Byron L. Long, and Jeanne M. Sept. 2010. “HOMINIDS: An Agent-Based Spatial Simulation Model to Evaluate Behavioral Patterns of Early Pleistocene Hominids.” Ecological Modelling 221 (5): 738–60. https://doi.org/10.1016/j.ecolmodel.2009.11.009.\n\n\nGünther, Gerrit, Thomas Clemen, Rainer Duttmann, Brigitta Schütt, and Daniel Knitter. 2021. “Of Animal Husbandry and Food Production—A First Step Towards a Modular Agent-Based Modelling Platform for Socio-Ecological Dynamics.” Land 10 (12): 1366. https://doi.org/10.3390/land10121366.\n\n\nHeckbert, Scott. 2013. “MayaSim.” Journal of Artificial Societies & Social Simulation 16 (4): 11. http://jasss.soc.surrey.ac.uk/16/4/11.html.\n\n\nJanssen, Marco A. 2009. “Understanding Artificial Anasazi.” Jasss 12 (4): 13. https://doi.org/13.\n\n\nJoyce, James A. 2019. “Farming Along the Limes: Using Agent-Based Modelling to Investigate Possibilities for Subsistence and Surplus-Based Agricultural Production in the Lower Rhine Delta Between 12BCE and 270CE.” Ph.{D}., Vrije Universiteit Amsterdam. http://dare.ubvu.vu.nl/handle/1871/55924.\n\n\nKabora, T. K., D. Stump, and J. Wainwright. 2020. “How Did That Get There? Understanding Sediment Transport and Accumulation Rates in Agricultural Landscapes Using the ESTTraP Agent-Based Model.” Journal of Archaeological Science: Reports 29 (February): 102115. https://doi.org/10.1016/j.jasrep.2019.102115.\n\n\nKohler, Timothy A., and Mark D. Varien. 2012. Emergence and Collapse of Early Villages: Models of Central Mesa Verde Archaeology. University of California Press.\n\n\nKovacevic, Mirna, Stephen Shennan, Marian Vanhaeren, Francesco d’Errico, and Mark G. Thomas. 2015. “Simulating Geographical Variation in Material Culture: Were Early Modern Humans in Europe Ethnically Structured?” In Learning Strategies and Cultural Evolution During the Palaeolithic, edited by Alex Mesoudi and Kenichi Aoki, 103–20. Replacement of Neanderthals by Modern Humans Series. Tokyo: Springer Japan. https://doi.org/10.1007/978-4-431-55363-2_8.\n\n\nLake, Mark. 2001. “The Use of Pedestrian Modelling in Archaeology, with an Example from the Study of Cultural Learning.” Environment and Planning B: Planning and Design 28 (3): 385–403. https://doi.org/10.1068/b2726.\n\n\nLake, Mark W., and Enrico R. Crema. 2012. “The Cultural Evolution of Adaptive-Trait Diversity When Resources Are Uncertain and Finite.” Advances in Complex Systems 15 (01n02): 1150013. https://doi.org/10.1142/S0219525911003323.\n\n\nLawall, Mark L., and Shawn Graham. 2018. “Netlogo Simulations and the Use of Transport Amphoras in Antiquity.” In Maritime Networks in the Ancient Mediterranean World, edited by Leidwanger and Carl Knappett, 163–83. Cambridge: Cambridge University Press.\n\n\nMcAnany, Patricia A., Jeremy A. Sabloff, M. Lamoureux St-Hilaire, and Gyles Iannone. 2015. “Leaving Classic Maya Cities: Agent-Based Modeling and the Dynamics of Diaspora.” In Social Theory in Archaeology and Ancient History: The Present and Future of Counternarratives., edited by Emberling, 13:231–58. Cambridge: Cambridge University Press. https://www.cambridge.org/core/books/social-theory-in-archaeology-and-ancient-history/leaving-classic-maya-cities-agentbased-modeling-and-the-dynamics-of-diaspora/F068BF029E6359205F9321A114157F54?utm_campaign=shareaholic&utm_medium=copy_link&utm_source=bookmark.\n\n\nMokom, Felicitas. 2015. “Modeling the Evolution of Artifact Capabilities in Multi-Agent Based Simulations.” Electronic Theses and Dissertations, January. https://scholar.uwindsor.ca/etd/5711.\n\n\nMorrison, Alex E., and Melinda S. Allen. 2017. “Agent-Based Modelling, Molluscan Population Dynamics, and Archaeomalacology.” Quaternary International 427 (January): 170–83. https://doi.org/10.1016/j.quaint.2015.09.004.\n\n\nNikulina, Anastasia, Katharine MacDonald, Anhelina Zapolska, Maria Antonia Serge, Didier M. Roche, Florence Mazier, Marco Davoli, et al. 2024. “Hunter-Gatherer Impact on European Interglacial Vegetation: A Modelling Approach.” Quaternary Science Reviews 324 (January): 108439. https://doi.org/10.1016/j.quascirev.2023.108439.\n\n\nOestmo, Simen, Marco A. Janssen, and Curtis W. Marean. 2016. “Testing Brantingham’s Neutral Model: The Effect of Spatial Clustering on Stone Raw Material Procurement.” In Simulating Prehistoric and Ancient Worlds, edited by Juan A. Barceló and Florencia Del Castillo, 175–88. Cham: Springer International Publishing. https://doi.org/10.1007/978-3-319-31481-5_4.\n\n\nOrtega, David, Juan José Ibañez, Lamya Khalidi, Vicenç Méndez, Daniel Campos, and Luís Teira. 2014. “Towards a Multi-Agent-Based Modelling of Obsidian Exchange in the Neolithic Near East.” Journal of Archaeological Method and Theory 21 (2): 461–85. https://doi.org/10.1007/s10816-013-9196-1.\n\n\nPremo, L. S., and Gilbert B. Tostevin. 2016. “Cultural Transmission on the Taskscape: Exploring the Effects of Taskscape Visibility on Cultural Diversity.” PLOS ONE 11 (9): e0161766. https://doi.org/10.1371/journal.pone.0161766.\n\n\nRobinson, Derek T., Alan Di Vittorio, Peter Alexander, Almut Arneth, C. Michael Barton, Daniel G. Brown, Albert Kettner, et al. 2018. “Modelling Feedbacks Between Human and Natural Processes in the Land System.” Earth System Dynamics 9 (2): 895–914. https://doi.org/10.5194/esd-9-895-2018.\n\n\nRogers, J. Daniel. 2013. “Pastoralist Mobility and Social Controls In Inner Asia: Experiments Using Agent-Based Modeling.” Structure and Dynamics: eJournal of Anthropological and Related Sciences 6 (2). https://escholarship.org/uc/item/7rg669rm.\n\n\nRogers, J. Daniel, Teresa Nichols, Theresa Emmerich, Maciej Latek, and Claudio Cioffi-Revilla. 2012. “Modeling Scale and Variability in Human-Environmental Interactions in Inner Asia.” Ecological Modelling 241: 5–14. https://doi.org/10.1016/j.ecolmodel.2011.11.025.\n\n\nRomanowska, Iza, Colin D. Wren, and Stefani A. Crabtree. 2021. Agent-Based Modeling for Archaeology. Electronic. SFI Press. https://doi.org/10.37911/9781947864382.\n\n\nRubio Campillo, Xavier, Jose María Cela, and Francesc Xavier Hernàndez Cardona. 2012. “Simulating Archaeologists? Using Agent-Based Modelling to Improve Battlefield Excavations.” Journal of Archaeological Science 39 (2): 347–56. https://doi.org/10.1016/j.jas.2011.09.020.\n\n\nRubio-Campillo, X., J. M. Cela, and F. X. H. Cardona. 2014. “The Development of New Infantry Tactics During the Early Eighteenth Century: A Computer Simulation Approach to Modern Military History.” In Agent-Based Modeling and Simulation, edited by Simon J. E. Taylor, 208–30. The OR Essentials Series. London: Palgrave Macmillan UK. https://doi.org/10.1057/9781137453648_11.\n\n\nSakahira, Fumihiro, Yuji Yamaguchi, Ryoya Osawa, Toshifumi Kishimoto, Taka’aki Okubo, Takao Terano, and Hiro’omi Tsumura. 2021. “Generating Hypotheses on Prehistoric Cultural Transformation with Agent-Based Evolutionary Simulation.” In Proceedings of the Winter Simulation Conference, 194–205. WSC ’20. Orlando, Florida: IEEE Press.\n\n\nSantos, José Ignacio, María Pereda, Débora Zurro, Myrian Álvarez, Jorge Caro, José Manuel Galán, and Ivan Briz i Godino. 2015. “Effect of Resource Spatial Correlation and Hunter-Fisher-Gatherer Mobility on Social Cooperation in Tierra Del Fuego.” PloS One 10 (4): e0121888. https://doi.org/10.1371/journal.pone.0121888.\n\n\nSnitker, Grant. 2018. “Identifying Natural and Anthropogenic Drivers of Prehistoric Fire Regimes Through Simulated Charcoal Records.” Journal of Archaeological Science 95 (July): 1–15. https://doi.org/10.1016/j.jas.2018.04.009.\n\n\n———. 2021. “Evaluating the Influence of Neolithic Agropastoral Land Use on Holocene Fire Regimes Through Simulated Sedimentary Charcoal Records.” In Simulating Transitions to Agriculture in Prehistory, edited by Salvador Pardo-Gordó and Sean Bergin, 165–93. Computational Social Sciences. Cham: Springer International Publishing. https://doi.org/10.1007/978-3-030-83643-6_9.\n\n\nSorensen, Andrew C., and Fulco Scherjon. 2018. “fiReproxies: A Computational Model Providing Insight into Heat-Affected Archaeological Lithic Assemblages.” PLOS ONE 13 (5): e0196777. https://doi.org/10.1371/journal.pone.0196777.\n\n\nSousa, David Naves, Luís Correia, and Leonel Garcia-marques. 2019. “The Importance of Memory for the Success of Cooperation Under Ecological Adversity.” Adaptive Behavior 28 (4): 1–4. https://doi.org/10.1177/1059712319872518.\n\n\nTurchin, Peter. 2018. Historical Dynamics: Why States Rise and Fall. Princeton University Press. https://doi.org/10.1515/9781400889310.\n\n\nUllah, Isaac I. T., Claudia Chang, and Perry Tourtellotte. 2019. “Water, Dust, and Agro-Pastoralism: Modeling Socio-Ecological Co-Evolution of Landscapes, Farming, and Human Society in Southeast Kazakhstan During the Mid to Late Holocene.” Journal of Anthropological Archaeology 55 (September): 101067. https://doi.org/10.1016/j.jaa.2019.101067.\n\n\nVerhagen, Philip. 2019. “Modelling the Dynamics of Demography in the Dutch Roman Limes Zone: A Revised Model.” In Finding the Limits of the Limes: Modelling Demography, Economy and Transport on the Edge of the Roman Empire, edited by Philip Verhagen, Jamie Joyce, and Mark R. Groenhuijzen, 43–59. Computational Social Sciences. Cham: Springer International Publishing. https://doi.org/10.1007/978-3-030-04576-0_3.\n\n\nWhite, Andrew A. 2013. “Subsistence Economics, Family Size, and the Emergence of Social Complexity in Hunter–Gatherer Systems in Eastern North America.” Journal of Anthropological Archaeology 32 (1): 122–63. https://doi.org/10.1016/j.jaa.2012.12.003.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>ABM in archaeology</span>"
    ]
  },
  {
    "objectID": "intro-readings.html",
    "href": "intro-readings.html",
    "title": "3  Reading an ABM paper",
    "section": "",
    "text": "As a complement to this brief introduction, select one of the references mentioned in the previous session, containing details about a agent-based model in archaeology. Preferably, chose one that deals with topics that are familiar to you, so that the challenge resides on understanding the model description and its results and/or discussion.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reading an ABM paper</span>"
    ]
  },
  {
    "objectID": "intro-abm-method.html",
    "href": "intro-abm-method.html",
    "title": "4  How to do ABM",
    "section": "",
    "text": "4.1 Modelling “steps”\nIn the remaining sections of the Introduction, we will go deeper in describing the workflow of ABM. First, we lay out this workflow as it is commonly declared by practitioners, as a sequence of well-ordered steps that may be iterated in a revision cycle. Then, we introduce a few elements ‘behind the scene’ that stretch the ‘steps’ metaphor to its limits. We then review a few practical recommendations that, hopefully, will aid future ABM modellers. These include the verification-refactoring cycle in programming, the use of modular code, and the importance of remaining explorative while designing a model.\nModelling with ABM can be divided into steps, most of which are identified by the community of practitioners as either normative or recommended phases of model development. With minor variations, these are also recognised in other simulation and non-simulation modelling approaches.\nThe steps are:\nFurthermore, a few authors, myself included, also like to highlight two additional steps that are generally not acknowledged:",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How to do ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm-method.html#modelling-steps",
    "href": "intro-abm-method.html#modelling-steps",
    "title": "4  How to do ABM",
    "section": "",
    "text": "Definition of the research question and phenomenon. To define a research question and the phenomena involved, we must think in terms of systems, identifying and defining a set of elements we deem relevant and their interrelationships. In this initial step, the key is to delimitate the target system, within which external, undefined factors do not overly determine the interaction of elements. Here, we must decide on what is relevant for us and set aside the rest. Ideally, we should move to the next step only once we have a hypothetical mechanism to focus on, formulated roughly but in detail enough so we can formalise it later. We will call this our conceptual model.\n\n\nDesign or conceptualisation. Designing a model is essentially to find a formal definition able to represent the phenomena, as we have defined in the previous step. In this step, we go from a vague text description of the natural system we observe and its expected dynamics to a mathematical or algorithmic representation of the artificial system we want to build. At this stage, it is critical to define our model’s main variables, including any inputs and outputs. The latter will be particularly important to how simulation results can be compared to empirical data to validate the model. During model design, our conceptual model is formalised progressively, ideally up to the point where implementation is made immediate.\n\n\nImplementation. To implement the model is to effectively write down our model design as a piece of software (i.e., through programming). While other mathematical models could remain unimplemented, ABM models are hardly useful if not able to be solved through computer simulation. However, a model implementation carries much extra baggage, and many possible implementations exist for the same model. Therefore, modellers and their audience must differentiate between the model and its implementation.\n\n\nVerification. To verify a model implementation, we run a series of tests on the model code and compare the results with our expectations as model designers. If we wrote a fragment of code to calculate “2 + 2” expecting “4”, we should get “4” after running it. On the other hand, verifying a model (not its implementation) can only be done by running an implementation, which we assume is correctly representing the model. If our model states that “2 + 2 = 4”, and our implementation returns “4”, then we would conclude that the logic behind our model is correct.\n\n\nValidation. To validate a model is to iteratively match the conditions of our model (assumptions, parameter values, etc.) to measurable conditions in the targeted system and the results of simulations to equivalent variables measured in the targeted system. ABM modellers often regard validation as an extra, lengthy process, usually separable from the tasks involved in defining, implementing, and exploring a model. Validation is never an absolute term: it will depend on the amount of data available and the specific criteria chosen. A validated model is not a “correct” model, nor a model failing validation is a “useless” model.\n\n\nPrediction. A model that is robust in validation might be further considered as reliable to predict new evidence. In fact, validation is often made through approaches that emulate prediction by reserving a set or type of data to be compared with the model output.\n\n\n\nUnderstanding. The modeller must understand the model, know the variety of dynamics it can generate, and be aware of its limitations regarding the representation of the target system.\n\n\nCommunicating or Documenting. The understanding obtained by the modeller at one point is of little use to others and, eventually, her or himself in the long-term future. To ensure that such an understanding is passed through, we must invest significant time in documenting the model’s conceptual design and source code. Note that this is not equivalent to an academic publication, especially because most scientific journals push for a greater emphasis on the results rather than the bits and pieces of simulation models.\n\n\n\n\nOverview of modelling steps",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How to do ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm-method.html#modelling-missteps",
    "href": "intro-abm-method.html#modelling-missteps",
    "title": "4  How to do ABM",
    "section": "4.2 Modelling “(mis)steps”",
    "text": "4.2 Modelling “(mis)steps”\nHowever, building an ABM model is, in practice, a process that is significantly more complicated than the steps listed above. There are many shortcuts, such as finding a model or piece of code that can save months of work, but, more often, there are obstacles that test ABM modellers and the teams of researchers working with them. Some modellers (myself included) have characterized this as a ‘reiterative’ process, often drawing diagrams showing these steps in well-planned cycles. However, it might be more exact to lose the walking metaphor altogether.\nThe first problematic situation that comes to mind is, of course, the “technical issues”. Developing ABM models requires a set of skills that are rare and hard to obtain and maintain meanwhile doing other research tasks. Probably the most prominent skill of a modeller is programming, which involves conceptual abstraction and certain agility with the software being used. The latter is made even more relevant when the software used is poorly documented or requires a particular set up upon installation. This is undoubtedly the first entry toll of the ABM community for researchers in the humanities and social sciences. Still, the hardships on this side usually are surpassable with continuous training, support from more experienced modellers, and choosing the right software. Still, it is undeniably a long-term commitment.\nUnfortunately, issues related to ABM go deeper than code and software. For example, during the model design process, researchers might need to ask inconvenient and trivial questions about the phenomena represented, which raise a surprising amount of controversy and doubt and can even challenge some of the core assumptions behind a study. In archaeology, this may come as aspects that are considered out of the scope of empirical research due to the limiting nature of archaeological data compared to disciplines that focus on contemporary observations (e.g., anthropology, sociology, geography). Should an archaeological ABM model include mechanisms that cannot be validated by archaeological data (at least not in the same sense as experimental sciences)? This is probably the most important unresolved question in this field and possibly the one most responsible for hindering the use of ABM in archaeology.\nThese complications can be considered problems and opportunities, depending on if and how they are eventually resolved. In some cases, the difficulty will present a new idea or approach. In contrast, in other cases, dealing with it might cost valuable time and delay the research outcomes beyond any external deadlines (e.g., project funding, dissertation submission). The exercises in this course are presented in the spirit of safeguarding modellers in training from being stopped short by some obstacles while pursuing their research agendas using ABM.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How to do ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm-method.html#best-practices",
    "href": "intro-abm-method.html#best-practices",
    "title": "4  How to do ABM",
    "section": "4.3 Best practices",
    "text": "4.3 Best practices\nBefore jumping into practice, let us go over three general strategies that can offer a way out to at least some of the problems mentioned here. These strategies are: version control, refactoring regularly, enforcing modularity and being explorative.\n\n4.3.1 Version control\nSince modelling an ABM model eventually involves creating a piece of software (implementation), it is important to use version control to keep track of changes and to be able to revert to previous versions if necessary. This is especially important when working in a team, but also when working alone. Version control is also useful for keeping track of changes in the documentation and for keeping track of changes in the data used for the model. This kind of technology is an essential part of the software development process and we will dedicate a whole day to it, later in the course.\n\n\n4.3.2 Refactoring regularly\nBy definition, refactoring means that your code change but remains capable of producing the same result. Refactoring encompasses all tasks aiming to generalize the code, make it extendible, and also make it cleaner (more readable) and faster.\nHowever, there is a trade-off between these three goals. For example, replacing default values with calculations or indirect values will probably increase processing time. In practice, this trade-off is irrelevant until your model is very complex, populated (many entities), or must be simulated for many different conditions. I recommend always being attentive to the readability, commentary, and documentation of your code. Assuming you are interested in creating models for academic discussion (i.e., science rather than engineering), the priority is to communicate your models to others.\nThere are many actions in code that can be considered refactoring. Too many for us to enumerate here. Probably the best and more educational approach is to encounter examples of practices, both good and bad, think about them, and try to do better. In this sense, we will go over several examples along with the tutorial that hopefully will illustrate when and how you should refactor your model code.\n\n\n4.3.3 Enforcing modularity\nOne of the most critical aspects related to refactoring is code modularity. The so-called Single Responsibility Principle (SRP) has been established in software engineering and serves as an excellent guiding principle for building complex code.\nIn software like ABM models, modularity also has application at a higher level, in the form of submodels. Creating models as assembles of submodels enables researchers to focus on their areas of interest and expertise without necessarily over reducing the complexity of everything else.\nABM has been, and still is, often critisised for being a too complex and arbitrary approach in its aim and domain. Truthfully, ABM models tend to overgrow in detail regarding certain aspects while bluntly simplifying other elements. This is primarily a combined effect of the internal limitations of the modellers and their teams (time, budget, expertise, etc.) and the lack of opportunities for code reuse. Modularity offers an exit to this.\nModules can be built as original contributions, implemented from published model specifications, reimplemented from another programming language, or taken and modified as code snippets. We will encounter all these cases later on in this tutorial.\n\n\n\n\n\n\nNoteWhere to find modules\n\n\n\nThere are many sources of potential modules. The most direct source is, of course, your relevant bibliography. Despite the number of models and modellers, the likely scenario is that the modules you need are still not available as usable implementations. In such cases, you might need to translate model specifications, with a varied level of formalisation, into a working piece of code. The less formalise is the original contribution, the harder will be the challenge. Thankfully, there are a few alternatives where modules can be taken almost without extra coding.\nWhen using NetLogo, we first count with the Netlogo’s Models Library, a collection of implementation examples classified by discipline and domain. All files are included in the installation of NetLogo and can be accessed through File &gt; Models Library. If you are interested in taking an evolutionary perspective, it is also worth checking the OpenEvo NetLogo Models. a collection of models made for learning by Max Planck Institute for Evolutionary Anthropology.\nThe wide community of NetLogo users also hosts two extra libraries, the NetLogo User Community Models and the NetLogo Modelling Commons, where modellers from different disciplines can upload their models, and share and discuss them with others.\nA similar initiative was created from modellers more strongly associated with the SES framework. Today named as CoMSES Model Library, former openABM, it holds almost the same amount of models as NetLogo Modelling Commons and, despite being cross-platform, the majority of entries are implemented in NetLogo. CoMSES also hosts a curated bibliographic database, which can help search subject-related models. Even though massive, it does not represent all ABM and related modelling being done worldwide. CoMSES relies on voluntary work, as most scientific associations do, and its updates rely on a relatively small community.\nMore recently, a growing group of researchers involved in ABM in archaeology, including myself, have created an initiative, Network for Agent-based modelling of Socio-ecological Systems in Archaeology (NASSA), whose principal goal is to create and maintain a public library of modules (i.e., formatted as modules). You are welcome to join our activities and help create this community asset (write me an e-mail!).\n\n\n\n\n4.3.4 Being explorative\nThe last general recommendation to be made about doing ABM is: to be explorative. As mentioned, some have criticised ABM for being too speculative and arbitrary. Yes, ABM models often require many specifications to work, some of which escape the modeller’s expertise entirely. In front of this, we can either avoid ABM altogether or accept it, going the proverbial extra mile in making most “free decisions” based on a deeper study of possible design alternatives.\nSimilar to how we can use stochasticity, creating and exploring design alternatives is always a good idea to better understand our conceptual model’s weak points. Observing the differences in dynamics generated by those alternatives will help us decide how to define those uncertain areas further while reducing the risk of unconsciously running over important modelling decisions. In the tutorial, we will illustrate a few strategies for implementing and handling design alternatives.\n\n\n4.3.5 Documentation\nA short disclaimer before we start: the approach used here for conceptual modelling and model documentation is not considered a standard in the ABM community.\nIn the bibliography, you will find many other recommendations and examples, particularly those converging into the practices closer to Computer Science and Ecology. For example, many consider a necessary standard to be the Unified Modeling Language (UML), which includes many types of diagrams.\n  Derfel73; Pmerson, Public domain, via Wikimedia Commons\n  Use case diagram. Jvlivs, Copyrighted free use, via Wikimedia Commons\nThe Overview-Design-Details (ODD) protocol is also quite strongly advocated by ABM practitioners and constantly revisited and updated (Grimm et al. 2006, 2010, 2020; Müller et al. 2013).\n    Grimm et al. (2020)\nAfter years of creating and reviewing ABM models, I would argue that these are not as useful or applicable as hoped, especially when the intended audience is greatly oblivious to simulation modelling and, of course, such standards. Consider that in other disciplines, a minimal knowledge of mathematical modelling, including simulation modelling, and programming is a common curricular requirement at the undergraduate level. For those of us pursuing this approach in archaeology and history, having ourselves an academic track in the Humanities, the time spent in learning documentation standards could be better used to improve one’s programming skills, for example. However, any student of ABM should be aware of these proposed standards and judge for themselves. Being informed about them, and effectively using them, will always get you into a better place as a modeller. I use simple text and generic graphs for this course, on the other hand emphasising the importance of maximum clarity in the code.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How to do ABM</span>"
    ]
  },
  {
    "objectID": "intro-abm-method.html#learning-resources",
    "href": "intro-abm-method.html#learning-resources",
    "title": "4  How to do ABM",
    "section": "4.4 Learning resources",
    "text": "4.4 Learning resources\nTextbook (Romanowska, Wren, and Crabtree 2021)\n\n\n\n\n\nGrimm, Volker, Uta Berger, Finn Bastiansen, Sigrunn Eliassen, Vincent Ginot, Jarl Giske, John Goss-Custard, et al. 2006. “A Standard Protocol for Describing Individual-Based and Agent-Based Models.” Ecological Modelling 198 (1-2): 115–26. https://doi.org/10.1016/J.ECOLMODEL.2006.04.023.\n\n\nGrimm, Volker, Uta Berger, Donald L. DeAngelis, J. Gary Polhill, Jarl Giske, and Steven F. Railsback. 2010. “The ODD Protocol: A Review and First Update.” Ecological Modelling 221 (23): 2760–68. https://doi.org/10.1016/J.ECOLMODEL.2010.08.019.\n\n\nGrimm, Volker, Steven F. Railsback, Christian E. Vincenot, Uta Berger, Cara Gallagher, Donald L. DeAngelis, Bruce Edmonds, et al. 2020. “The ODD Protocol for Describing Agent-Based and Other Simulation Models: A Second Update to Improve Clarity, Replication, and Structural Realism.” Journal of Artificial Societies and Social Simulation 23 (2): 7.\n\n\nMüller, Birgit, Friedrich Bohn, Gunnar Dreßler, Jürgen Groeneveld, Christian Klassert, Romina Martin, Maja Schlüter, Jule Schulze, Hanna Weise, and Nina Schwarz. 2013. “Describing Human Decisions in Agent-Based Models – ODD + D, an Extension of the ODD Protocol.” Environmental Modelling & Software 48 (October): 37–48. https://doi.org/10.1016/J.ENVSOFT.2013.06.003.\n\n\nRomanowska, Iza, Colin D. Wren, and Stefani A. Crabtree. 2021. Agent-Based Modeling for Archaeology. Electronic. SFI Press. https://doi.org/10.37911/9781947864382.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>How to do ABM</span>"
    ]
  },
  {
    "objectID": "concept-intro.html",
    "href": "concept-intro.html",
    "title": "5  Conceptual modelling of processes",
    "section": "",
    "text": "5.1 Considering archaeological evidence and its interpretations (explanations)\nLet us have a taste of the first and most important stages in the application of simulation, system definition and model design, to archaeology topics.\nGiven a general topic of interest associated with a specific type of archaeological evidence, we must develop a conceptual model that includes a definition of the minimum features of a phenomenon or system (representation), with the aim of its mathematical formalization (mechanism). So that it contributes to the answer to one or more research questions or to refute or reformulate a working hypothesis (validation).\nConceptual modelling reflects the exploratory nature of explanatory modelling. In this context, we should consider the maximum number of potential explanations and subsequently prioritise those that are arguably or demonstrably more likely, all given the limits of our knowledge. When building a model, we should include additional elements parsimoniously and keep in mind that this conceptual definition should help us create a computational model (implementation) that is both intelligible and computable within a reasonable time frame.\nWhen creating your first conceptual model, I recommend starting from scratch with the first intuition that comes to mind. After later scrutiny, its logical structure may be oversimplified, incomplete, or faulty. However, it would most likely represent the main elements of an informal model that you and other researchers share. Relying on an informed guess to start model development is the best remedy for the “blank page panic”. It will also help you avoid overthinking and overworking what should be a mere preliminary sketch of the model.\nSaid this, we might still suffer when trying to jump-start the modelling process. Even if (or maybe especially when) a sizeable interdisciplinary team is involved, such is often the case in ABM-related projects.\nArchaeological evidence can be interpreted to understand past phenomena, and these interpretations often involve proposing underlying mechanisms. The relationship between evidence, phenomenon, and mechanism can be understood as follows:\nThe following table offers some additional examples:\narchaeological evidence\nphenomena in the past\nmechanisms\n\n\n\n\ndistribution and size of settlements\nsubsistence, demographic growth dependent on environmental factors, mobility and sedentary lifestyle\nlogistic function, areas of influence and catchment, competition between settlements\n\n\nfunerary context (number and style of artefacts, determination of age and sex, morphological and genetic proximity between individuals, etc.)\nritual burial of certain individuals (beliefs, population composition, asymmetries and inequalities, etc.), mortality (frequency, contexts), decision making and logistics regarding funerary practice\ninstitutionalisation of prestige and authority status, effects of taboo on logistical stages of burial, inequality between kinship groups\n\n\ndetection of organic residues on the surface of ceramic vessels\nproduction (surface treatment) and use of vessels (storage, cooking, food consumption), decision making in production, selection of recipes and dietary components\nresidue signal (quantified) as a function of type of use\n\n\ndistribution and diversity of varieties of a very common type of artefacts (lithic instruments, ceramics, etc.)\nmovements of people and artefactss, cultural transmission of ways of producing and/or using said artefactss\ncultural transmission (drift), prestige and functional selection\n\n\nfrequency of species in charcoal between the strata of a deposit\nclimate changes that limit or enhance growth by species, selective size, fires, deforestation\nplant growth by species group that explicitly accounts for recurrent clearing\n\n\noldest C14 dating of the presence of domesticated plants and animals in sites distributed throughout a region\ndemographic growth and migration, interaction between groups with and without domestication (exchange, assimilation, conflict, etc.)\ncompetition for habitat between agropastoral groups and hunter-gatherers\n\n\nvolume of a mineral extracted in a deposit with mining, duration of occupation and activity\nsubsistence and liberation of labour, decision making on mining intensity, use and exchange of minerals\neconomy of scale and diminishing returns\nThere are at least three ways to begin this stage:\nIn all routes, there are no shortcuts: the robustness of the explanation will depend on the depth and width of the prior knowledge about both evidence and phenomena.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conceptual modelling of processes</span>"
    ]
  },
  {
    "objectID": "concept-intro.html#considering-archaeological-evidence-and-its-interpretations-explanations",
    "href": "concept-intro.html#considering-archaeological-evidence-and-its-interpretations-explanations",
    "title": "5  Conceptual modelling of processes",
    "section": "",
    "text": "Evidence: This refers to the physical remains or data that archaeologists uncover. This can include artefacts, structures, or environmental data. Pieces of evidence vary in level of description, from pottery styles to the position of fortifications and the abundance of animal species. They also vary in the methods used to define them, like visual analysis, geometric analysis, 3D scanning, and GPS.\nPhenomenon: The phenomenon is the pattern or process inferred from the evidence. It is the “what” that happened, based on the interpretation of the evidence, but also the benchmark definition of reality, based in a much longer list of experiences and confirmed knowledge. For instance, variations in pottery style can represent exchange, the position of fortifications can represent strategic decision-making, and a decrease in a wild animal population can represent human hunting.\nMechanism: The mechanism is the causal explanation of why the phenomenon occurred. It involves identifying the processes or interactions that led to the observed pattern. This is the “why” behind the phenomenon. Mechanisms are expressed through causal relationships between variables, often including underlying assumptions. For example, variations in pottery styles can be explained by increased trade with another region, the positioning of fortifications can be explained by differential visibility, and a decrease in animal population can be explained by overhunting.\n\n\n\n\n\nFrom evidence to mechanism (from left to right in the table): You may prefer to first think about a set of types of archaeological evidence, perhaps a type that one is most familiar with or that can be found in a specific site or dataset. Once the evidence is delimited, you can then identify what is the most likely and/or strongest explanation, first in terms of the phenomenon and then as a generative process (left to right in the table). With sufficient effort and time, the worst-case scenario when taking this path is to obtain a weak explanatory model, one that does not offer a realistic representation of the phenomenon, but may provide further insight into patterns of evidence (i.e., a descriptive model).\n\nFrom phenomenon to evidence and mechanism (middle to left and right in the table): It is equally valid to start by considering a phenomenon that has been extensively documented, studied, and defined in other disciplines (e.g., trade, from an economic and anthropological perspective). In choosing a phenomenon, you must be able to assume it existed in a particular context in the past and that there are domains of evidence that could support or undermine such an explanation. The worst-case scenario here would be to have a “toy model”, one that represents the current knowledge of a phenomenon and can be used to investigate it, but cannot be readily assumed for the past, nor is it directly validated with archaeological evidence.\n\nFrom mechanism to phenomenon and evidence (right to left in the table): The last and more opportunistic option is to focus first on a mechanism that has already been described and/or formalised, consider a phenomenon it can represent and search for a type of evidence where signals of this mechanism can be detected. Taking this path demands a specific knowledge of modelling and models, preferably in multiple fields and disciplines, but it is a relatively safe path: the worse case is to end up concluding that the selected mechanism, alone at least, does not explain the patterns observed in the selected evidence – a small, but steady contribution.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conceptual modelling of processes</span>"
    ]
  },
  {
    "objectID": "concept-intro.html#diagraming-for-simulation-modelling",
    "href": "concept-intro.html#diagraming-for-simulation-modelling",
    "title": "5  Conceptual modelling of processes",
    "section": "5.2 Diagraming for simulation modelling",
    "text": "5.2 Diagraming for simulation modelling\nA conceptual model can be expressed in various ways, such as lists of elements and relationships, schemes, and diagrams. Text or visual expressions are valid as long as they help us approach the design of a computational simulation model, facilitating the next stage (implementation).\nGraphs are a powerful tool for representing complex systems. They can be used to represent:\n\nthe structure of a system, the flow of information, or the flow of resources\n\nthe dynamics of a system, the interactions between agents, or the evolution of a system over time\n\nthe spatial structure of a system, the location of agents, or the movement of agents\n\nthe temporal structure of a system, the timing of events, or the duration of events\n\nHere, we will not force the use of conventions such as UML, although these can be useful. Examples of UML diagrams can also offer inspiration, even if you don’t learn their rules. Other, more specific conventions can also be very useful and relatively easy to learn:\n\n\nCausal diagrams and “stocks and flows” or Forrester diagrams: helpful in relating the change of aggregate variables (stocks) to parameters and other variables (flows).\n\n\n\n\n\n\nFlowcharts: useful for representing flows of logic governed by a predetermined structure, especially when conditionals are involved (e.g. decision-making). In agent-based models, we will use it to describe modular processes that are applied to an entire model or to its entities and repeated every step in time.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conceptual modelling of processes</span>"
    ]
  },
  {
    "objectID": "concept-intro.html#designing-an-explanatory-mechanism",
    "href": "concept-intro.html#designing-an-explanatory-mechanism",
    "title": "5  Conceptual modelling of processes",
    "section": "5.3 Designing an explanatory mechanism",
    "text": "5.3 Designing an explanatory mechanism\nThe selected explanation is never final, nor is it a declaration of subjective belief (my interpretation). It should be the spark and direction of an open-ended process where we order our background knowledge and beliefs in search of logical consistency (formalisation), contrast them with further evidence (validation), and revisit or extend them.\nThe formalisation of an explanation is in fact the most challenging task in simulation modelling, especially in domains as complex as archaeology. It involves, first of all, a way of thinking that goes beyond any technical skill, training in mathematics or computing, or knowledge of jargon specific to one or another discipline. Therefore, it should be practised continuously rather than learned once.\nIf the chosen explanation is already present in formal models developed by others, we could probably skip this stage. However, using, adapting or combining formal models for your own research will require a deep understanding of the formalisation done and how it relates to the terms of your own evidence, question, etc. In this sense, we will have to be especially careful in selecting formalised mechanisms and applying them to domains very different from our topic. For example, a model describing resource exploitation by ant populations might be useful for depicting resource exploitation by human populations, but the adoption and adaptation of the model must be done with an awareness of the differences between these phenomena.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conceptual modelling of processes</span>"
    ]
  },
  {
    "objectID": "concept-pop-dyn.html",
    "href": "concept-pop-dyn.html",
    "title": "6  Example: Settlement size, population and migration",
    "section": "",
    "text": "6.1 Starting simple\nAs an example, let us imagine that in our research we postulate that:\nThis general idea could be expressed more schematically as a set of cases or scenarios. Here we are limited to two:\nWe can also simplify this by sketching a causal diagram, a graph where the nodes are the “things” that change (the variables), the arrows mark the direction of the effect or causality, and their sign (+ or -), the sense of the effect (positive or negative):\nIf we are comfortable with algebra, we could try to translate it to:\nor\nwhere f and g are functions, yet to be defined.\nSuch expressions rephrase the original explanation in a way that is more amenable to formalisation. They read as:\nWithout equations to define f and g, our causal graph actually expresses more content by reading:",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Example: Settlement size, population and migration</span>"
    ]
  },
  {
    "objectID": "concept-pop-dyn.html#starting-simple",
    "href": "concept-pop-dyn.html#starting-simple",
    "title": "6  Example: Settlement size, population and migration",
    "section": "",
    "text": "the increase in the built-up area of an archaeological site, which we assumed to be a settlement, is explained by population growth due to migratory influx.\n\n\n\n↑ immigration → ↑ population → ↑ settlement size\n↓ immigration → ↓ population → ↓ settlement size\n\n\n\n\n\ninitial conceptual model example\n\n\n\n\nsettlementSize = f(population) = f( g(immigration) )\n\n\n\nsettlementSize = f(population)\npopulation = g(immigration)\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nwhat is a function?\n\na function is a relation between a set of inputs and a set of permissible outputs with the property that each input is related to exactly one output.\n\n\n\n\n\n\n\nSettlement size (variable) is a function (depends on) population (variable).\nPopulation (variable) is a function (depends on) immigration (variable).\n\n\n\nSettlement size (variable) is a function (depends on) population (variable) as a positive term (+).\nPopulation (variable) is a function (depends on) immigration (variable) as a positive term (+).",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Example: Settlement size, population and migration</span>"
    ]
  },
  {
    "objectID": "concept-pop-dyn.html#towards-a-balance-between-representation-and-complexity",
    "href": "concept-pop-dyn.html#towards-a-balance-between-representation-and-complexity",
    "title": "6  Example: Settlement size, population and migration",
    "section": "6.2 Towards a balance between representation and complexity",
    "text": "6.2 Towards a balance between representation and complexity\nDo you think this is a satisfactory description of our explanation? Does it leave out something we implicitly assumed with our first informal explanation? Is it going too far, stating something that we did not intend in the first place? The criteria for answering these questions push us away from the informal explanations and into the realm of logic and a broader contextual knowledge.\nIn our example, we can immediately detect that our variables must be expressed in at least two different units (e.g., \\(m^{2}\\) and individuals). We must add a parameter (a variable that remains constant throughout the process) to convert (amounts of) population into (amounts of) settlement size. We will call it areaPerInhabitant:\n\nsettlementSize = f(areaPerInhabitant * population)\n\nFurthermore, we may find it insufficient to describe population change by considering only immigration (i.e., g(immigration)). You cannot tell how many apples are in a basket by just counting the ones you add. That is, we need an initial population:\n\npopulation = g(initialPopulation, immigration)\n\nFollowing the same reasoning, we should also consider that variables can change intrinsically (i.e., independently of g(immigration)) over time:\n\nsettlementSize = f(areaPerInhabitant * population, time)\npopulation = g(initialPopulation, immigration, time)\n\nIf settlement size and population change over time, would immigration rates also change? If so, then we will also need to consider an additional term, the parameter that determines the rate of change in immigration:\n\nsettlementSize = f(population, time)\npopulation = g(initialPopulation, immigration, time)\nimmigration = h(immigrationRate, time)\n\nOur causal graph will be at this point considerably different, even when we assume time as implicit to all variables:\n\n\n\nConceptual model after adding a few parameters\n\n\nAfter a few iterations of this reasoning process, our formal expressions will undoubtedly become more complex. The more variables and parameters an explanatory model includes, the more realistic and rich the scenarios it will allow. However, variables and parameters should then be controlled by evidence or, at the very least, defined in a meaningful way.\nRemember, while defining a parameter adds complexity, it also marks the point in a branch of thought where modelling stops, that is, where something that could certainly be described as complex and dynamic is reduced to a fixed value.\n\n\n\n\n\n\nNote\n\n\n\n\n\nImportant modelling terminology\nVariable: it varies with time. It is part of the object of interest and its dynamics are interpreted as outputs of the phenomenon (≈model).\nParameter: it does not vary with time, but it can vary between instances of the phenomenon (≈simulation runs). It is considered as an input of the phenomenon (≈model).\n\n\n\n\nIn light of the context and research questions, you should decide when to sacrifice the representativeness of your model (the “want to”) to ensure that it can be implemented, understood, and validated in the future (the “can do”).",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Example: Settlement size, population and migration</span>"
    ]
  },
  {
    "objectID": "concept-pop-dyn.html#reusing-consolidated-structures",
    "href": "concept-pop-dyn.html#reusing-consolidated-structures",
    "title": "6  Example: Settlement size, population and migration",
    "section": "6.3 Reusing consolidated structures",
    "text": "6.3 Reusing consolidated structures\nWhen we are satisfied with a structure in our formalism, we can reuse it to extend the model and represent similar or symmetrical aspects of the phenomenon, without repeating the previous steps or making it less intelligible. For example, if our model considers immigration as a cause, we could also take into account an emigration flow with an opposite effect on the population.\n\n\n\nConceptual model after structure duplication",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Example: Settlement size, population and migration</span>"
    ]
  },
  {
    "objectID": "concept-pop-dyn.html#adding-feedback-loops",
    "href": "concept-pop-dyn.html#adding-feedback-loops",
    "title": "6  Example: Settlement size, population and migration",
    "section": "6.4 Adding feedback loops",
    "text": "6.4 Adding feedback loops\nWhen representing processes, we must keep in mind that causality is not necessarily a unilateral relationship. Since we are considering the passage of time, a variable can be modelled to affect itself (in the future) or other variables that have previously influenced its value.\nFor example, given our background knowledge about population pressure, let’s stipulate that population positively affects the amount of emigration at a given time:\n\n\n\nConceptual model after adding a two-variable feedback loop\n\n\nReading:\n&gt;Population (variable) is a function (depends on) emigration (variable) as a negative term (-).\n&gt;Emigration (variable) is a function (depends on) population (variable) as a positive term (+).\nWith this idea, we can replace the parameter “initial population” with a positive loop (population-population), i.e., the initial population will simply be the value of population at the first time step. We can also improve our representation of how a real population by defining a component of the growth rate that is independent of migration flows (natural increase).\n\n\n\nConceptual model after adding a one-variable feedback loop\n\n\nWith this level of formalisation and complexity, our model will begin to approach a fully specified and implemented simulation model within the framework of system dynamics (https://en.wikipedia.org/wiki/System_dynamics). If we were to stay in this framework, we could already write down a preliminary implementation as a set of two difference equations:\n\npopulation = naturalGrowthRate * population + immigrationRate - emmigrationRate * population\nsettlementSize = areaPerInhabitant * population\n\nThrough an examination of the causal diagram and the equations, we can visualise what aspects are detailed or simplified in our model. In this example, the model is clearly focusing more on population dynamics as the primary driver of settlement change, rather than other processes that could mediate population and settlement size (e.g., procurement of materials, construction, labour organisation, social norms of cohabitation). It is essential to decide whether this is desirable or not before continuing to add new elements to the model.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Example: Settlement size, population and migration</span>"
    ]
  },
  {
    "objectID": "concept-pop-dyn.html#expressing-conditions-as-logic-bifurcations",
    "href": "concept-pop-dyn.html#expressing-conditions-as-logic-bifurcations",
    "title": "6  Example: Settlement size, population and migration",
    "section": "6.5 Expressing conditions as logic bifurcations",
    "text": "6.5 Expressing conditions as logic bifurcations\nMore often than not, explanations cannot be formalised solely with causal graphs and algebraic expressions like the ones above. One of the most common cases is when we want to represent a process that only occurs if certain conditions are met: a logical bifurcation or branching.\nImagine, for example, that our migration-driven population model must take into account the combined effect of two factors:\n\nThe political relationship between this and neighbours (friendly/hostile)\n\nThe general state of prosperity in the settlement (e.g. a combined factor of subsistence, well-being and raw material availability), summarised with a binary classification between good and bad times.\n\nThe introduction of the first factor can be simple: a hostile relationship will prevent any migration flow, incoming or outgoing. The corresponding diagram, now expressed as a flowchart, could be:\n\n\n\nConceptual model after adding one logic bifurcation\n\n\n\nNote: the logic bifurcations are not part of the causal graph. They are part of the model’s logic.\n\nThe second factor will create yet another bifurcation, relevant only if the settlement’s neighborhood is friendly. If times are good, we will assume that immigration is triggered, because the settlement is attractive to new residents. If times are bad, emigration is triggered instead, to represent the growing number of inhabitants who are dissatisfied with local living conditions.\n\n\n\nConceptual model after adding two logic bifurcations\n\n\nThe more your formal model is composed of algorithms (discontinuous operations) rather than equations (continuous operations), the more complicated it will be to use causal diagrams and the easier it will be to use of flowcharts and other specialised diagrams (e.g. UML). However, when it comes to model development and communication, ANY diagram is better than NO diagram or conceptual formalism at all.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Example: Settlement size, population and migration</span>"
    ]
  },
  {
    "objectID": "concept-pop-dyn.html#representing-distributed-and-social-mechanisms",
    "href": "concept-pop-dyn.html#representing-distributed-and-social-mechanisms",
    "title": "6  Example: Settlement size, population and migration",
    "section": "6.6 Representing distributed and social mechanisms",
    "text": "6.6 Representing distributed and social mechanisms\nIf we are looking for a formal model capable of accounting for distributed processes (occurring in parallel through the action of multiple entities) and more complex social mechanisms (i.e. multi-dimensional, non-linear), our conceptual model should move towards an object-based and, eventually, agent-based framework. There are many ways to represent distributed processes, such as formulating variables as vectors and matrices, if equations are still a viable format, or drawing flowcharts to prescribe the behaviour of entities and their potential interactions.\nIf our population model were to be formulated as agent-based, considering households as the primary units of the process, we would need to define their behaviour in a way that, in aggregate, still represents the essence of the causal relationship we seek to formalise:\n\n\n\nConceptual model after conversion to agent-based\n\n\nNotice that once the process is conceptualised as distributed, it will be increasingly more challenging to keep the description of the conceptual model in a single formal expression or diagram. In the example above, we choose to simplify the diagram by referencing entire chunks of our model by a single meaningful name (e.g., “reproduce”). These named chunks are the best candidates to be implemented later on as functions: a bundle of operations that can take inputs and return outputs.\nFor example, let us define “reproduce” as a decision on whether a household will branch a new one given that a certain probability threshold, called the household fission rate, a household-level parameter replacing the population-level natural growth rate:\n\n\n\nA tentative “reproduce” process\n\n\nRemember, specifications can be at this stage still quite vague and undefined. For example, how should we determine whether the household fission rate is sufficiently large? Moreover, observe how, yet again, we rely on the promise of a new function, household fission. Thinking of functions in terms of modules can help us expand our conceptual model without getting stuck on details that will only be truly handled once we move to implementation.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Example: Settlement size, population and migration</span>"
    ]
  },
  {
    "objectID": "concept-your-turn.html",
    "href": "concept-your-turn.html",
    "title": "7  Your turn!",
    "section": "",
    "text": "To have your own experience in conceptual modelling for simulation, you will need:\n\nPen and paper or your preferred sketching digital platform (tablet, laptop).\nA subject of interest in archaeology, preferably one that you know or have thought about in terms of explanations. Alternatively, you can select a model that has been explained verbally, but never formalised; for example, a written description of an explanation in a paper or book chapter. Remember, explanation here means that evidence is associated with a phenomenon, a process, and a mechanism (i.e., causal relationships).\n\nYou may work in groups, as long as everyone is actually interested in the chosen topic.\nChoose wisely, and you can continue to develop it in the implementation step.",
    "crumbs": [
      "Learning to model processes",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your turn!</span>"
    ]
  },
  {
    "objectID": "dev-workflow.html",
    "href": "dev-workflow.html",
    "title": "8  A simulation modeller as a software developer: a workflow",
    "section": "",
    "text": "8.1 The “big picture”\nAgent-based modelling (ABM) is more than coding—it is an iterative and cumulative research process that benefits from software engineering principles. Each simulation model can be seen as a small research software project, and the modeller as its developer. Thinking like a software developer helps to ensure that the model is:\nWe can recast the generic modelling steps into a software development workflow represented as:\nIn practice, these stages overlap and repeat. Conceptual choices affect implementation; analysis reveals bugs or design flaws; revisions are documented in version control.\nThe goal is incremental improvement rather than perfection at once. Treat this as a living process: your repository should tell the story of how your model evolved.\nIn practice, your workflow should go over these steps in time in a safe, but tentative way:",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A simulation modeller as a software developer: a workflow</span>"
    ]
  },
  {
    "objectID": "dev-workflow.html#the-big-picture",
    "href": "dev-workflow.html#the-big-picture",
    "title": "8  A simulation modeller as a software developer: a workflow",
    "section": "",
    "text": "Reproducible: anyone (including your future self) can run it and obtain the same results.\nTransparent: the model’s assumptions, mechanisms, and implementation are easy to inspect.\nCollaborative: colleagues can contribute, review, or reuse your code and data.\nExtensible: improvements, corrections, or new experiments can be added without breaking the project.\nReusable: others can build on your work.\n\n\n\nConceptual model: Defines the system, processes, and hypotheses. Identify inputs (data), outputs, and validation criteria.\n\nImplementation or “implemented model”: Translate the conceptual model into executable code (e.g., in NetLogo). Expanded through “coding sessions”.\n\nVersion control: After each coding session, commit your changes with Git (locally) and push them to a remote repository in GitHub. When working directly in the remote repository in your browser, you will need to commit changes to each file individually. When changing your model in NetLogo, you will have to open the .nlogo or .nlogox file in a text editor and copy-paste its contents into the remote version (not recommended).\nExperimentation: Run simulations manually in NetLogo, or systematic experiments using NetLogo’s BehaviorSpace or custom procedures in NetLogo, external files (e.g., datasets generated in R), or executing NetLogo from R.\n\nAnalysis: Process and visualise simulation outputs in R, write up results.\n\nPublication: publish and share your complete project repository, including analysis outputs (specific outputs can be used for an article).\n\n\n\n\n\n\n💡📝 First conceptual model with enough definitions (variables, parameters, agents, functions)\n        ↓\n🧱 First programming session creating a few model elements (not runnable)\n        ↓\n🔄 Commit changes: \"add netlogo file\"\n        ↓\n🔁📝 Rethinking a few definitions\n        ↓\n🧱 Second programming session updating the model with new definitions (not runnable)\n        ↓\n🔄 Commit changes: \"update netlogo file\"\n        ↓\n🧱 Third programming session creating a minimal set of procedures for initialisation (runnable)\n        ↓\n🔄 Commit changes: \"update netlogo file\"\n        ↓\n...\n        ↓\n🧪📊 Run a few simulations and observe the model dynamics (also output variables)\n        ↓\n🔁🧱 Refine a model procedure, not quite behaving as intended\n        ↓\n...\n        ↓\n...",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A simulation modeller as a software developer: a workflow</span>"
    ]
  },
  {
    "objectID": "dev-workflow.html#tools-and-services-checklist",
    "href": "dev-workflow.html#tools-and-services-checklist",
    "title": "8  A simulation modeller as a software developer: a workflow",
    "section": "8.2 Tools and services checklist",
    "text": "8.2 Tools and services checklist\nTo follow best practices, every simulation modeller should maintain a working toolkit and a structured workflow environment. Below is a checklist tailored to this course.\n\n\n\n\n\n\n\n\n\nCategory\nTool / Service\nPurpose\nKey Concepts / Skills\n\n\n\n\nVersion control\nGit\nTrack changes to your project files\nCommits, branches, merges, history\n\n\n\nGitHub\nHost and share repositories online\nREADME, issues, pull requests, releases\n\n\nModel implementation\nNetLogo\nMain platform for building agent-based models\nInterface design, procedures, agents, patches, globals\n\n\nData analysis & visualization\nR (later in the course)\nProcess simulation results, generate plots and statistics\nR scripts, data frames, ggplot2, tidyverse\n\n\n\nRStudio (optional)\nMore agility using R (UI elements for common operations), allows seamless use of notebook formats, other script extensions and git\ninitial configuration, creating projects, package installation, notebook interaction\n\n\nInteroperability\nRNetLogo (optional)\nRun NetLogo from R for batch experiments\nAutomation, reproducibility, less flexibility\n\n\nDocumentation\nMarkdown (.md)\nWrite guides, notebooks, and documentation\nFormatting, headings, links, code blocks\n\n\n\nREADME.md\nFront page of your GitHub repository\nSummary, usage, citation\n\n\n\nBibTeX (.bib) and software like Zotero\nManage bibliographic database, faster import and export of references, citation style agnostic\nBibTeX entries, citation in any kind of document\n\n\nReproducible environment\nProject folders\nOrganise code, data, results, and docs\nClear structure, consistent naming\n\n\n\na general-purpose IDE (e.g. VS Code)\nQuick edit and manage all files with easy git integration and other features. Particularly useful for editing files not directly related to NetLogo or R.\nintegrated file editing and management, essential when using other programming languages (e.g. HTML, Python).\n\n\nCollaboration and feedback\nGitHub Issues / Discussions (optional)\nRecord bugs, ideas, and model questions\nIssue tracking, commenting\n\n\nArchival and citation\nZenodo (later in the course)\nAssign a DOI to your final model\nVersioned release, FAIR principles\n\n\n\n\n8.2.1 Minimal setup for this course\nBy the next session, you will have:\n\nCreated a GitHub account.\nCreated a simple repository for your model(s).\nSet up a structured folder for your project and write a minimal README file.\nAdded these to your GitHub repository.\nCreated a Zenodo account.\nLinked GitHub to Zenodo for future publication.\n\nWhen using your own computer to work in a local repository:\n\nInstalled Git (and GitHub Desktop) on your computer.\n\nInstalled NetLogo, and R (and RStudio).\n\nConfigured Git (username, email, SSH key or HTTPS). This is necessary when using version control locally in your computer.\n\nAlso recommended:\n\nInstalled VS Code or equivalent (for editing text and code files).\n\nInstall Zotero or equivalent and create a user account.\n\n\n\n\n8.2.2 Summary\nA good modeller is a good steward of code. The tools are not the goal—they are supports for clarity, reproducibility, and collaboration. In this course, you will gradually assemble your own simulation software project, learning to combine conceptual, technical, and organisational skills.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A simulation modeller as a software developer: a workflow</span>"
    ]
  },
  {
    "objectID": "dev-git-github.html",
    "href": "dev-git-github.html",
    "title": "9  Git and GitHub",
    "section": "",
    "text": "9.1 Version control and Git",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "dev-git-github.html#version-control-and-git",
    "href": "dev-git-github.html#version-control-and-git",
    "title": "9  Git and GitHub",
    "section": "",
    "text": "9.1.1 Version control: general concept and its usefulness\nVersion control is a system that helps track and manage file changes over time. It’s widely used in software development, but its applications extend to any field where file management is essential, including document editing, research, and project management. At its core, version control provides a historical record of changes. It allows users to revert to previous versions, identify when and why changes were made, and work collaboratively without the risk of overwriting each other’s work.\nThere are two main types of version control: centralized and distributed. Centralized version control systems, such as Subversion (SVN), store files in a central repository. Users check out files, make changes, and then commit them back to the central repository. While effective, centralized systems can be vulnerable if the central server fails. Distributed version control systems, like Git, address this by allowing every user to have a complete copy of the repository on their local machine. This setup enhances collaboration and provides redundancy, as users can work offline and synchronize changes with others when connected.\n\n Git icon\n\n\n\n9.1.2 Benefits of Version Control\n\nCollaboration: Version control systems make collaboration easier and more efficient by allowing multiple users to simultaneously work on the same project. With distributed systems like Git, branches can be created for different features or tasks, and changes can later be seamlessly merged into the main project. This enables teams to work independently and minimize conflicts.\nHistorical Tracking: Version control systems keep a detailed history of all changes made to the files. This allows users to see who made changes, when, and why. If an issue arises, it’s possible to revert to a previous state without losing any data, making debugging easier.\nBackup and Redundancy: In distributed systems, each user’s local copy is a backup of the entire project. This redundancy reduces the risk of data loss due to server failures or other issues and allows users to work offline and sync changes later.\nVersion Management: Version control systems assign unique identifiers to each change, per commit and file changed, usually called “Git hash” or “commit hash”. A Git hash a 40-character hexadecimal string, such as 2d3acf90f35989df8f262dc50beadc4ee3ae1560, derived from the contents of the commit, including its parent commit(s), timestamp, and author details [REF]. These identifiers allow users to switch between different versions of the project easily. It’s also possible to create branches for experimental features and merge them with the main project once they’re stable, facilitating smoother integration of new features.\nEnhanced Workflow: Many version control systems support automated processes such as Continuous Integration (CI) and Continuous Deployment (CD), which streamline development and testing. These systems can automatically test changes before they are merged, ensuring higher code quality and reducing the risk of introducing bugs.\n\nOverall, version control systems are crucial tools in modern project management and development workflows. They enable collaboration, ensure data integrity, and improve productivity by providing a structured approach to managing changes in any type of project.\nGet a short introduction to Git by watching the official Git Documentation videos here.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "dev-git-github.html#git-terminology",
    "href": "dev-git-github.html#git-terminology",
    "title": "9  Git and GitHub",
    "section": "9.2 Git terminology",
    "text": "9.2 Git terminology\nHere are some essential Git terms to know:\n\n\n\n\nRepository: A storage space for your project files and their history. Repositories can be local (on your computer) or remote (on platforms like GitHub).\nInitialise: configure a specific local directory (your “working directory”) as a local repository by creating all necessary files for Git to work.\nAdd/Stage: adds a change in the working directory to the staging area, telling Git to include updates to a particular file in the next commit. However, adding or staging doesn’t really affect the repository since changes are not actually recorded until they are committed (see below).\n\n\n\n\n\n\n\n\nPull: A command that fetches changes from a remote repository and merges them into your local branch, ensuring your local work is up-to-date with the remote [2].\nPush: Uploads your commits from the local repository to the remote repository, making your changes available to others.\n\n\n\n\n\nCommit: A snapshot of changes in the repository. Each commit has a unique ID, allowing you to track and revert changes as needed [1].\nBranch: A separate line of development. The default branch is usually called main or master. Branches allow you to work on features independently before merging them into the main project [2]. A branch is a parallel version of the repository within the same repository structure. By branching, developers can isolate work on different features or fixes without altering the main project files. For example, many projects have a main or master branch for the official release version, while other branches are used for development or testing. Branches are typically merged into the main branch once they are finalized.\n\n\n\n\n\n\n\n\nMerge: The process of integrating changes from one branch into another. Typically, this involves merging a feature branch into the main branch.\n\nUnderstanding these terms is crucial for effective Git usage and collaboration in any project.\n\n\n\n\n\n\nNoteSee also\n\n\n\n\n\n\n“Git - Reference” (n.d.)\n\n“Git Definitions and Terminology Cheat Sheet” (n.d.)\n\n\n\n\n\n\n\n\n\n\nCautionCHECK: Git software installation\n\n\n\n\n\nTo verify if Git is installed on your machine, follow these steps:\n\nOpen Command Prompt (Windows 10 or 11)\n\nPress Win + R, type cmd, and hit Enter.\nAlternatively, you can search for “Command Prompt” in the Start menu and select it.\n\nCheck for Git\n\nIn the Command Prompt window, type the following command and press Enter:\ngit --version\nIf Git is installed, you will see the installed version, e.g., git version 2.34.1.\nIf Git is not installed, you will receive an error message or see that the command is unrecognized. You can download the installer from git-scm.com and follow the installation instructions.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "dev-git-github.html#github",
    "href": "dev-git-github.html#github",
    "title": "9  Git and GitHub",
    "section": "9.3 GitHub",
    "text": "9.3 GitHub\n\n9.3.1 What is GitHub?\nGitHub is a cloud-based platform that enables developers to store, manage, and collaborate on code repositories. It builds on Git functionalities by adding collaborative features like pull requests, issue tracking, and discussions, which make it easier for teams to work together on software projects.\nGitHub also offers hosting for open-source projects, allowing anyone to contribute or review code. With integrations for CI/CD, project management tools, and documentation, GitHub is a popular choice for developers worldwide to manage both personal and professional projects.\n\n GitHub icon\n\nGitHub was created by Tom Preston-Werner, Chris Wanstrath, and PJ Hyett in 2008 and acquired by Microsoft in 2018, growing considerably in size and service features.\n\n\n\n\n\n\nCautionCHECK: GitHub user and GitHub Desktop installation\n\n\n\n\n\n\nCheck GitHub Desktop Installation\nTo verify that GitHub Desktop is installed:\n\nOn Windows: Go to the Start menu, search for “GitHub Desktop,” and open the app. If it launches successfully, GitHub Desktop is installed.\nOn macOS: Use Spotlight Search (Cmd + Space), type “GitHub Desktop,” and press Enter. If the app opens, it is installed.\n\nIf you don’t have GitHub Desktop, you can download it from desktop.github.com and follow the installation instructions [1][2].\n\n\nVerify GitHub User\nTo check if you are signed in as a GitHub user:\n\nOpen GitHub Desktop.\nGo to File &gt; Options (on Windows) or GitHub Desktop &gt; Preferences (on macOS).\nUnder the Accounts tab, you should see your GitHub username and avatar if you are signed in. If not, you can sign in with your GitHub credentials here.\n\n\n\nBookmark your GitHub user profile page\nIn your Internet browser, make sure that your own GitHub user profile page is saved in Bookmarks for easy access later.\n\n\n\n\n\n\n9.3.2 GitHub terminology\nUnderstanding the core vocabulary associated with GitHub operations can help users make the most of this platform, especially for collaborative or open-source projects. Here are some key concepts to keep in mind:\n\nCloning: Cloning involves creating a local copy of a repository on your machine. By cloning a repository, users can work offline and change files that can later be pushed back to the GitHub repository. This process is essential for local development, allowing users to commit changes and manage their workflow effectively with Git commands.\nForking: Forking creates a personal copy of someone else’s GitHub repository in your account. It allows users to experiment with changes without affecting the original repository, and is often used to contribute to open-source projects. After forking, developers can freely modify their own versions and submit a pull request to propose these changes to the original repository if they have improvements or fixes to offer.\nPull Requests: A pull request (PR) is a way to propose changes in a repository. After modifying a forked or branched version of a repository, a developer can open a pull request, which initiates a review process. This feature is central to collaboration on GitHub, allowing others to review, discuss, and approve proposed changes before they are merged into the main branch.\nCommits and Push: A commit is a snapshot of changes in the repository. Every commit includes a message describing the changes, and each commit builds upon previous ones, creating a history of the repository’s development. Pushing is uploading these commits to GitHub from a local repository. After a series of commits on a local branch, a user can push these changes to the corresponding branch on GitHub to keep the remote repository up-to-date.\nGists: A gist is a simple way to share code snippets or single files. Gists can be public or secret, and they are particularly useful for sharing configuration files or code examples. Users can fork and edit Gists, making them a lightweight collaboration and code-sharing tool.\nIssues and Discussions: Issues are GitHub’s built-in tracking system for bugs, tasks, and feature requests. They allow users to report problems, suggest new features, and engage in conversations related to the project. Discussions provide a more open forum-style setting for broader conversation, enabling users to share ideas, ask questions, and contribute knowledge that might not directly relate to specific code changes.\n\n\n\n\n\n\n\nNoteSee also\n\n\n\n\n\n\n“Cloning and Forking a Repository — Pythia Foundations” (n.d.)\n\n“GitHub Glossary” (n.d.)\n\n“How to Get Familiar with Forking & Cloning GitHub Repos” (2023)\n\n“Difference Between Fork and Clone in GitHub” (2021)\n\n\n\n\n\n\n9.3.3 Working with GitHub\nGitHub offers various workflows to manage repositories. Here are three common methods:\n\n\n\n\n\n\nNoteLocal with GitHub Desktop (recommended)\n\n\n\n\n\nFor those who prefer a graphical user interface (GUI):\nCloning a Repository\n\nOpen GitHub Desktop.\n\nGo to File &gt; Clone Repository.\n\nSelect the repository and click “Clone.”\n\nCreating a New Branch\n\nClick on the “Current Branch” dropdown.\n\nSelect “New Branch,” name it, and click “Create Branch.”\n\nMaking Changes\n\nEdit files in your editor.\n\nCommitting Changes\n\nReturn to GitHub Desktop.\n\nStage changed files by ticking the boxes.\n\nWrite a summary of changes and click “Commit to new-branch.”\n\nPushing Changes\n\nClick “Push origin” to upload your changes.\n\n\n\n\n\n\n\n\n\n\nNoteRemote with Web Browser (limited functionality)\n\n\n\n\n\nYou can also work directly on GitHub.com:\nForking a Repository\n\nGo to the repository page.\nClick on the Fork button in the top-right corner of the page.\n\nChoose an owner (user or organisation), a name and description for the new fork repository. The default will always be a exact copy of the original repository. Select whether to copy only the main branch. Click “Create fork”.\n\nCloning a Repository\n\nGo to the repository page.\n\nClick the green “Code” button and continue the cloning process locally, using console commands (copying link) or with GitHub Desktop.\n\nCreating a New Branch\n\nClick the branch dropdown on the main page.\n\nType a new branch name and click “Create branch.”\n\nMaking Changes\n\nNavigate to the file (and branch) you want to edit.\n\nClick the pencil icon to edit.\n\nMake your changes and scroll down to the “Commit changes” section.\n\nCommitting Changes\n\nEnter a commit message.\n\nChoose whether to “commit directly to main” or “Commit to a new branch…”.\n\nPushing Changes\n(No push is needed as changes are automatically saved to GitHub.)\n\n\n\n\n\n\n\n\n\nNoteLocal with console commands (advanced users)\n\n\n\n\n\nTo work with Git via the command line:\nNavigate to the directory to hold the local copy\ncd path/to/local/directory\nCloning a Repository\ngit clone https://github.com/username/repository.git\nCreating a New Branch\ngit checkout -b new-branch\nMaking Changes Edit files in your favorite text editor or IDE.\nCommitting Changes\ngit add .\ngit commit -m \"Describe your changes\"\nPushing Changes\ngit push origin new-branch\n\n\n\nThese workflows enable flexibility in how you manage your projects on GitHub.\n\n\n9.3.4 Markdown (GitHub-flavoured)\nWhen Markdown files (.md) are placed in a GitHub repository, they will be automatically rendered within GitHub web interface by default, while the raw code can still be seen and edited in Markdown.\nThere are some particularities about how Markdown files will be rendered in GitHub through Internet browsers. Consult GitHub Docs for knowing more about them.\n\n\n9.3.5 How to organise repositories\nWhen structuring your repositories, following some common conventions for organizing files in subdirectories is helpful. This makes projects more readable and more accessible for others to navigate. Here are some commonly used subdirectories:\nWhen software development is a significant part:\n* source/ or src/: Contains the main source code for the project.\n* documentation/, docs/, or doc/: Stores documentation, such as guides or API references.\n* tests/: Includes test scripts to ensure code functionality.\n* bin/: Holds executable scripts or binaries.\n* config/: Contains configuration files, like YAML or JSON.\nWhen rendering a document or a graphical user interface, such as LaTeX documents, websites, web apps, or video games:\n* assets: to hold files and subdirectories with closed content and functionality files.\n* assets/images/, assets/media/, etc.: Holds all images or other media files generated externally (not by the repository’s source code).\n* assets/styles.css or assets/css/: all CSS code for formatting HTML objects.\n* assets/js/: JavaScript source code enabling interactive functionalities (it would also apply for other programming languages in similar position). Source code of this kind might also be placed inside the source code folder, if present.\nThese folder structures are conventions and not strict rules. You can adapt or modify them based on your project’s needs.\nThere are several community-based proposals for standards, including tools that can help automate the creation of a new project directory with conventional files. For example, for a typical Data Science project using Python see Cookiecutter Data Science.\n\n\n\n\n\n\nNoteSee also\n\n\n\n\n\n\njimmy (2022)\n\nZestyclose-Low-6403 (2023)\n\ndanijar (2019)\nSuhail (2024)\n\nCioara (2018)\n\n\n\n\n\n\n9.3.6 Conventional files\n\nREADME.md: Provides an overview of the project, including what it does, how to set it up, and how to contribute. A few sections examples are:\n\nGeneral description\n\nAuthors and/or contributors\n\nAcknowledgements\n\nFunding\n\nInstallation or use instructions\n\nContributing\n\n\nLICENSE: Specifies the terms under which the content of the repository can be used, modified, and distributed. There are many licenses, varying in permissiveness and type of content. Generally, for projects involving both code and other kinds of content, we recommend CC0-1.0 or MIT. See https://choosealicense.com/ and GitHub Docs).\nCITATION.cff: human- and machine-readable citation information for software (and datasets). See example here.\n\n.gitignore: Lists files and directories that Git should ignore, such as build outputs and temporary files.\n\nCHANGELOG.md: This file logs a chronological record of all notable changes made to the project, often following conventions like Conventional Commits.\n\nreferences.bib: a file containing references in BibTex format, which can be cited within the markdown files of the repository.\n\n\n\n9.3.7 Version Tags and Releases on GitHub\nTo manage different versions of your project, GitHub allows you to create tags and releases:\n\nCreate a Tag:\n\nOpen your repository on GitHub and navigate to the Releases section.\nClick Draft a new release.\nIn the Tag version field, type a version number (e.g., v1.0.0) to create a new tag (see more in the note below).\nSpecify the target branch or commit for this tag.\n\nCreate a Release:\n\nAfter tagging, enter details such as the release title and description.\nOptionally, add release notes to summarize changes or new features [1].\nClick Publish release to make it public.\n\n\nReleases are tied to tags and provide a stable reference for each version, making it easy for users to download specific versions of your project [2].\n\n\n\n\n\n\nNoteAbout versioning\n\n\n\n\n\nIf unfamiliar with the logic behind versioning, consult the reference to Semantic Versioning, which can also be found on the right of the “Create a new release” page in GitHub. Their summary states:\n\nGiven a version number MAJOR.MINOR.PATCH, increment the:\n1. MAJOR version when you make incompatible API changes\n2. MINOR version when you add functionality in a backward compatible manner\n3. PATCH version when you make backward compatible bug fixes\n\nHowever, if your repository is not about creating software products and services, we can do well by simply obeying a few general conventions:\n\nAdd a PATCH version discretionally when correcting bugs, typos, tuning aesthetics, etc, or refactoring code (explained in ?sec-r-programming).\nAdd a MINOR version when expanding code functionality or adding new content (text sections, images)\nAdd a new PATCH or MINOR version every time the repository reaches a natural stable point (i.e., there are no changes planned any time soon).\nMake sure that every new MAJOR version is released (GitHub) and published (Zenodo, see below).\n\n\n\n\n\n\n\n\n\n\nNoteSee also\n\n\n\n\n\n\n“Creating GitHub Releases Automatically on Tags” (2024)\n“Automatically Generated Release Notes” (n.d.)\n\nSignell (2013)\n\n\n\n\n\n\n\n9.3.8 Establishing a GitHub-Zenodo Connection\nTo link your GitHub repository with Zenodo and enable citation via DOI:\n\nLogin to Zenodo: Go to Zenodo and sign in or create an account.\nAuthorize GitHub Access:\n\nClick on your profile in Zenodo and select Linked accounts.\nChoose Connect next to GitHub.\nYou will be redirected to GitHub to authorize Zenodo’s access. Approve the request to complete the connection.\n\nSelect Repository for DOI Generation:\n\nIn Zenodo, navigate to GitHub in the Linked Accounts section.\nEnable DOI generation for the desired repository. Zenodo will automatically mint DOIs for any new release you publish.\n\n\nThis connection allows you to generate and manage DOIs for GitHub repositories, enhancing your project’s citation and research accessibility.\n\n\n\n\n\n\nNoteSee also\n\n\n\n\n\n\n(noauthor_referencing_nodate?)\n\n(noauthor_zenodo_nodate?)\n\n“Created New Organization in GitHub and Zenodo Did Not Send a Request for Accessing It · Issue #1596 · Zenodo/Zenodo” (n.d.)\n\n(noauthor_module-5-open-research-software-and-open-sourcecontent_developmenttask_2md_nodate?)\n\n“Issue a Doi with Zenodo” (n.d.)\n\n\n\n\n\n\nIn this course, we follow a particular minimal repository structure, specific to our needs. In the next chapter, you will be creating your own model repository using this specifications or directly a template.\n\n\n\n\n“Automatically Generated Release Notes.” n.d. GitHub Docs. Accessed October 11, 2024. https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes.\n\n\nCioara, Andrei. 2018. “How I Organize My GitHub Repositories.” Medium. https://andreicioara.com/how-i-organize-my-github-repositories-ce877db2e8b6.\n\n\n“Cloning and Forking a Repository — Pythia Foundations.” n.d. Accessed October 28, 2024. https://foundations.projectpythia.org/foundations/github/github-cloning-forking.html.\n\n\n“Created New Organization in GitHub and Zenodo Did Not Send a Request for Accessing It · Issue #1596 · Zenodo/Zenodo.” n.d. GitHub. Accessed October 11, 2024. https://github.com/zenodo/zenodo/issues/1596.\n\n\n“Creating GitHub Releases Automatically on Tags.” 2024. https://jacobtomlinson.dev/posts/2024/creating-github-releases-automatically-on-tags/.\n\n\ndanijar. 2019. “Can I Arrange Repositories into Folders on Github?” Forum post. Stack Overflow. https://stackoverflow.com/q/11852982/6199967.\n\n\n“Difference Between Fork and Clone in GitHub.” 2021. GeeksforGeeks. https://www.geeksforgeeks.org/difference-between-fork-and-clone-in-github/.\n\n\n“Git - Reference.” n.d. Accessed October 9, 2024. https://git-scm.com/docs.\n\n\n“Git Definitions and Terminology Cheat Sheet.” n.d. Accessed October 11, 2024. https://www.pluralsight.com/resources/blog/cloud/git-terms-explained.\n\n\n“GitHub Glossary.” n.d. GitHub Docs. Accessed October 28, 2024. https://docs.github.com/en/get-started/learning-about-github/github-glossary.\n\n\n“How to Get Familiar with Forking & Cloning GitHub Repos.” 2023. DEV Community. https://dev.to/joshhortt/how-to-get-familiar-with-forking-cloning-github-repos-46nc.\n\n\n“Issue a Doi with Zenodo.” n.d. Github for Collaborative Documentation. Accessed October 11, 2024. https://cassgvp.github.io/github-for-collaborative-documentation/docs/tut/6-Zenodo-integration.html.\n\n\njimmy. 2022. “How to Organize GitHub Repositories.” Backrightup. https://backrightup.com/blog/how-to-organize-github-repositories/.\n\n\nSignell, Rich. 2013. “How to Handle Releases of Markdown Document on Github.” Forum post. Stack Overflow. https://stackoverflow.com/q/19727632/6199967.\n\n\nSuhail, Muhammad Ahmed. 2024. “Structuring and Organizing My Github: A Developer’s Guide.” Medium. https://medium.com/@muhammadahmedsuhail007/structuring-and-organizing-my-github-a-developers-guide-7353610f04fd.\n\n\nZestyclose-Low-6403. 2023. “How to Organize Repos Within an ’Organization’?” Reddit {Post}. R/Github. www.reddit.com/r/github/comments/188d324/how_to_organize_repos_within_an_organization/.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git and GitHub</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html",
    "href": "dev-git-github-practice.html",
    "title": "10  Creating your simulation model repository",
    "section": "",
    "text": "10.1 Preparation\nThis chapter puts into practice the workflow introduced earlier. You will now create a proper, version-controlled home for your simulation model. Your repository will serve as a living record of your project’s evolution — from conceptualisation and first prototype to final publication.\nIn this session, we will be using the browser interface only. But do consider installing and configuring the rest of the software in order to be able to work locally in your own computer",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html#preparation",
    "href": "dev-git-github-practice.html#preparation",
    "title": "10  Creating your simulation model repository",
    "section": "",
    "text": "Created a GitHub account.\nCreated a Zenodo account.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html#join-the-course-github-organisation",
    "href": "dev-git-github-practice.html#join-the-course-github-organisation",
    "title": "10  Creating your simulation model repository",
    "section": "10.2 Join the course GitHub organisation",
    "text": "10.2 Join the course GitHub organisation\nAll course repositories are hosted under 👉 https://github.com/CoDArchLab-ABM\n\nAccept the invitation sent by your instructor (check your GitHub notifications or email).\nOnce inside the organisation, you can see the list of other student projects.\nYou can also create repositories under your own GitHub username if you prefer, and later transfer them to the organisation.\n\n\n💡 Being part of the organisation helps with collaboration, visibility, and the use of shared templates.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html#creating-a-new-repository",
    "href": "dev-git-github-practice.html#creating-a-new-repository",
    "title": "10  Creating your simulation model repository",
    "section": "10.3 Creating a new repository",
    "text": "10.3 Creating a new repository\nYou can create your repository entirely through the GitHub web interface, no local software required.\n\nGo to your GitHub homepage → Repositories → New.\nChoose owner as your user (you can later create a fork in the course organisation)\nName it following the convention: project2025_&lt;model-name&gt; (use only lowercase letters, digits, and underscores).\nInitialise it with:\n\n✅ a README.md file\n✅ a .gitignore (choose the R template)\n✅ a license of your choice (e.g. MIT, GPL-3.0, CC-BY-4.0)\n\nSet visibility to Public.\n\n\n💡 Starting with a README and license ensures that your project is immediately valid, citable, and shareable.\n\nIf you can work locally (on your own computer or a managed laptop), you may also initialise the repository on your machine using Git, then push it to GitHub.\n\nNOTE: You can find a project template in the course organisation (project2025_template) with files and directories for the typical contents already created. You may “fork” the template for a model repository and modify it accordingly, or create it from scratch using the guidelines above and populate it with files as you develop your project.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html#populating-your-repository",
    "href": "dev-git-github-practice.html#populating-your-repository",
    "title": "10  Creating your simulation model repository",
    "section": "10.4 Populating your repository",
    "text": "10.4 Populating your repository\nYour repository should reflect a clean, modular project structure from the beginning. Create the following files and folders — even if they remain empty for now.\nproject2025_&lt;model-name&gt;/\n│\n├── model/               # NetLogo models (.nlogo files)\n├── data/                # Input data files (CSV, shapefiles, etc.)\n├── results/             # Simulation outputs\n├── analysis/            # R or Python scripts for analysis\n├── docs/                # Markdown or PDF documentation\n│   └── notes.md\n├── LICENSE\n├── README.md\n└── .gitignore\nIf you work in the browser, use GitHub’s “Add file → Create new file” to add folders and files. Each new file can be created and edited directly online.\nWhen you edit a file:\n\nScroll down to “Commit changes.”\nWrite a short message describing your change (e.g. Add empty folders and README).\nChoose “Commit directly to the main branch.”\n\nThis saves and versions your work immediately.\n\n💡 Even if you cannot install Git locally, you still gain the benefits of version control and public documentation.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html#publishing-version-0.1",
    "href": "dev-git-github-practice.html#publishing-version-0.1",
    "title": "10  Creating your simulation model repository",
    "section": "10.5 Publishing version 0.1",
    "text": "10.5 Publishing version 0.1\nDespite your repository might be empty, you may want to practice publishing your repositories in Zenodo or at least make sure that everything is ready for later publication.\nOnce your initial structure is in place:\n\nSet up GitHub–Zenodo connection\n\nGo to https://zenodo.org → Sign in with GitHub.\nAuthorise Zenodo to access your repositories.\nIn Zenodo, enable archiving for your project2025_&lt;model-name&gt; repository.\n\nCreate your first release\n\nIn your repository → “Releases” → “Draft a new release”.\nTag: v0.1\nTitle: Version 0.1 (initial structure)\nDescription: a short note about what this version contains.\nClick on the “Publish release” button.\n\nPublish\n\nOnce published, Zenodo will automatically mint a DOI for your repository snapshot.\n\nUpdate README\n\nAdd the Zenodo DOI badge at the top of your README.md.\nExample:\n[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.xxxxxxx.svg)](https://doi.org/10.5281/zenodo.xxxxxxx)\n\n\n\n💡 This makes your project formally citable and demonstrates best practices for open science.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html#if-you-later-gain-local-access",
    "href": "dev-git-github-practice.html#if-you-later-gain-local-access",
    "title": "10  Creating your simulation model repository",
    "section": "10.6 If you later gain local access",
    "text": "10.6 If you later gain local access\nOnce you can install and use Git locally, you can clone your repository and continue developing offline:\ngit clone https://github.com/CoDArchLab-ABM/project2025_&lt;model-name&gt;.git\nWork as usual:\ngit add .\ngit commit -m \"Implement new agent rules\"\ngit push\nYour history and Zenodo releases will remain intact — this is a seamless transition.\n\n\n10.6.1 Summary\n\n\n\n\n\n\n\n\nStep\nDescription\nOnline only?\n\n\n\n\nCreate repository\nInitialise on GitHub with README, license, and .gitignore\n✅\n\n\nAdd folders/files\nUse GitHub web editor\n✅\n\n\nCommit and version\nDone via “Commit changes” in browser\n✅\n\n\nPublish release and DOI\nConnect to Zenodo\n✅\n\n\nClone locally (optional)\nUse Git on your computer\n❌\n\n\n\n\n🧭 Goal: By the end of this chapter, your simulation project exists as a structured, public, versioned, and citable research artifact — even if you never installed Git.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-git-github-practice.html#writing-your-readme-file",
    "href": "dev-git-github-practice.html#writing-your-readme-file",
    "title": "10  Creating your simulation model repository",
    "section": "10.7 Writing your README file",
    "text": "10.7 Writing your README file\nEvery GitHub repository starts with a README.md file. It serves as the front page of your project and should answer three key questions:\n\nWhat is this project?\nHow can others use it or learn from it?\nHow can it be cited or extended?\n\nBelow is a template you can copy into your repository’s README file and adapt to your project. Sections marked with &lt;!-- comments --&gt; are suggestions to help you fill in the content.\n\n\n10.7.1 📄 Example README.md Template\n# Project2025_&lt;model-name&gt;\n\n[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.xxxxxxx.svg)](https://doi.org/10.5281/zenodo.xxxxxxx)\n\n## Overview\n\n&lt;!-- Briefly describe your simulation model in 2–3 sentences. --&gt;\nThis project develops an agent-based model (ABM) that explores [process or phenomenon, e.g., settlement dynamics and trade interactions] in an archaeological context.  \nIt was created as part of the MA course *Agent-based Modelling for Archaeologists* at the University of [Your Institution].\n\n## Concept and objectives\n\n&lt;!-- Describe what the model represents and what questions it addresses. --&gt;\nThe model aims to simulate [describe processes, behaviours, or hypotheses].  \nIt is designed to help explore how [key mechanisms] influence [outcomes of interest].\n\n## Model design\n\n&lt;!-- Summarise the main elements: environment, agents, and processes. --&gt;\n- **Agents:** [e.g., settlements, traders, households]  \n- **Environment:** [e.g., spatial grid, network, landscape data]  \n- **Key processes:** [list mechanisms such as migration, exchange, resource use]  \n- **Temporal scale:** [e.g., yearly steps, 100 iterations]  \n\nA full conceptual description is available in [`docs/notes.md`](docs/notes.md).\n\n## Repository structure\n\n\\`\\`\\`\n\nmodel/       → NetLogo model files (.nlogo)\ndata/        → Input datasets (CSV, shapefiles, etc.)\nresults/     → Simulation outputs\nanalysis/     → R scripts for analysis\ndocs/        → Documentation and notes\n\n\\`\\`\\`\n\n## Usage\n\n### Requirements\n- [NetLogo](https://ccl.northwestern.edu/netlogo/)\n- [R](https://www.r-project.org/) (optional, for analysis)\n\n### How to run\n1. Open `model/&lt;your_model&gt;.nlogo` in NetLogo.  \n2. Use the Interface tab to initialise and run the simulation.  \n3. Use **BehaviorSpace** (NetLogo menu → Tools → BehaviorSpace) to run batch experiments.  \n4. Store output files in the `results/` folder for later analysis.\n\n## Results\n\n&lt;!-- Mention what kind of outputs or figures you expect. --&gt;\nSimulation results include [key indicators, e.g., settlement sizes, trade volumes, population changes].  \nAnalysis scripts in `scripts/` generate plots and summaries.\n\n## License\n\nThis project is licensed under the [LICENSE](LICENSE) file included in the repository.\n\n## Citation\n\nIf you use or adapt this model, please cite:\n\n&gt; [Your Name]. (2025). *Project2025_&lt;model-name&gt;: An agent-based model of [topic]*. Version 0.1. DOI: [https://doi.org/10.5281/zenodo.xxxxxxx](https://doi.org/10.5281/zenodo.xxxxxxx)\n\n## Acknowledgements\n\nThis work was developed as part of the MA course *Agent-based Modelling for Archaeologists: From Concept to Application and Publication*,  \ntaught by Andreas Angourakis at the University of Cologne.",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Creating your simulation model repository</span>"
    ]
  },
  {
    "objectID": "dev-netlogo-intro.html",
    "href": "dev-netlogo-intro.html",
    "title": "11  Introduction to NetLogo",
    "section": "",
    "text": "11.1 Preparation\nTo prepare for the next sessions, you need to:",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to NetLogo</span>"
    ]
  },
  {
    "objectID": "dev-netlogo-intro.html#preparation",
    "href": "dev-netlogo-intro.html#preparation",
    "title": "11  Introduction to NetLogo",
    "section": "",
    "text": "Download or ‘clone’ the contents of this repository into a local folder. Select  in the top right of the repository page in GitHub, and choose one of the options given.\nDownload and install NetLogo latest version (only if working in your own computer). Currently, it is NetLogo 7.0.2 (file extension .nlogox), but consider that lab computers might have a previous version (file extension .nlogo). The operating system-specific installation files are found here: https://ccl.northwestern.edu/netlogo/download.shtml",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to NetLogo</span>"
    ]
  },
  {
    "objectID": "dev-netlogo-intro.html#excursion-to-abma",
    "href": "dev-netlogo-intro.html#excursion-to-abma",
    "title": "11  Introduction to NetLogo",
    "section": "11.2 Excursion to ABMA",
    "text": "11.2 Excursion to ABMA\nBefore even opening NetLogo in your computer, let us take advantage of the materials available at the Agent-Based Modeling for Archaeologists (ABMA) portal. These were created as a Erasmus+ project by a group of esteemed colleagues, with the goal of further the education on the use of simulation and agent-based modelling in archaeology.\n\n\n\nABMA portal\n\n\nVisit “Tutorials” and then “Open Tutorials”. You will access a interactive web application presenting a few basic concepts of simulation and agent-based modelling, as well as familiarise you with NetLogo’s interface. The latter is done with NetLogo Web, but it broadly corresponds to what you will see when opening a local installation in your computer.\nPlease perform all four lessons (approx. 30 min).",
    "crumbs": [
      "Preparing as a software developer",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to NetLogo</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html",
    "href": "program-netlogo-language-basics.html",
    "title": "12  NetLogo language basics",
    "section": "",
    "text": "12.1 Console interaction\nIn this session, we will learn more about NetLogo’s programming language. We will start with the very basics to ease you into it, in case you are not familiar with any type of programming.\nAs a preamble, important to anyone without previous experiences with programming languages, the very first thing one can do in NetLogo is give oneself a bit of encouragement. In the NetLogo interface, go to the bottom area named ‘Command Center’ and type the following in the empty field on the right of ‘observer&gt;’ and press Enter:\nThe console prints:\nOops! NetLogo still doesn’t know “you”. Or is it that it cannot understand you? Well let us get you two properly introduced…\nBefore continuing, we should note: NetLogo does have its own vocabulary, containing what we will call “primitives”, to which we can add many more “words”, as long as we define them first using what NetLogo can understand. Without going into details now, just keep in mind that, in NetLogo language, special kinds of “words” are reporters, which are practical equivalents to values, and commands, which wrap the necessary steps to do something.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#console-interaction",
    "href": "program-netlogo-language-basics.html#console-interaction",
    "title": "12  NetLogo language basics",
    "section": "",
    "text": "You can do it!\n\nERROR: Nothing named YOU has been defined.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#entities",
    "href": "program-netlogo-language-basics.html#entities",
    "title": "12  NetLogo language basics",
    "section": "12.2 Entities",
    "text": "12.2 Entities\nThe (real) first thing one should learn about NetLogo, and most agent-based modelling systems, is that it handles mainly two types of entities/agents: patches, cells of a square grid, and turtles, which are proper “agents” (i.e., mobile, autonomous entities). Both entities have primitives (built-in, default properties), some of which can be modified by processes in your model. For example, you can’t modify the position of a patch, but you can change its filling colour.\n\n  NetLogo world and entities (Figure 2 in Izquierdo et al. 2019)\n\nAs seen in the figure above, NetLogo also includes a third type of entity, links, which has the particularity of describing a connection between two turtles and thus not having specific spatial coordinates of their own. We will deal with links later on, but for now we focus on the other entities, which are more commonly used in models.\nAll patches and turtles can be identified individually through primitives. Turtles have a unique numerical identifier (who) that is assigned automatically upon the creation of the turtle. Patches, in turn, have an unique combination of x and y integer coordinates in 2D space (pxcor and pycor), as they occupy each a single position in a grid (see Grid). To reference a specific turtle, patch or link:\nturtle &lt;WHO_NUMBER&gt;\npatch &lt;PXCOR&gt; &lt;PYCOR&gt;\nlink &lt;WHO_NUMBER&gt; &lt;WHO_NUMBER&gt;\nNetLogo allows you to define types of turtles as if it where a primitive, declaring its name as a breed:\nbreed [&lt;BREED_1_NAME_PLURAL&gt; &lt;BREED_1_NAME_SINGULAR&gt;]\n\nbreed [&lt;BREED_2_NAME_PLURAL&gt; &lt;BREED_2_NAME_SINGULAR&gt;]\nFor example:\nbreed [apples apple]\n\nbreed [pears pear]\nWe can then use the plural or singular form of the breed name directly, instead of referring to the generic turtles.\n&lt;BREED_1_NAME_SINGULAR&gt; &lt;WHO_NUMBER&gt;\nOr:\npear 2\nThis is useful, of course, when there are more the one breed to be defined, so that they are easily distinguished and intelligible in the code.\nWe can also refer to agents collectively as:\n&lt;BREED_1_NAME_PLURAL&gt;\npears\nor randomly as:\none-of apples\none-of patches\nThe one-of primitive offers a easy way to randomly select one agent (turtles and patches) from all (or a subset of all) agents of a given type.\nLast, we should keep in mind that turtles can be created and destroyed on-the-fly during simulations, while patches are created in the background upon initialisation, according to the model settings (e.g. grid dimensions), but never destroyed during simulation runs.\nSee NetLogo’s documentation on agents for further details (https://ccl.northwestern.edu/netlogo/docs/programming.html#agents).",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#variables",
    "href": "program-netlogo-language-basics.html#variables",
    "title": "12  NetLogo language basics",
    "section": "12.3 Variables",
    "text": "12.3 Variables\nThe most fundamental elements of NetLogo, as in any programming language, is variables. To assign a value to a variable we use the general syntax or code structure:\nset &lt;VARIABLE_NAME&gt; &lt;VALUE&gt;\nFor example:\nset x 123\nMeaning “set the variable x to be the number 123”.\nWhile variable names are fragments of contiguous text following a naming convention (e.g. my-variable, myVariable, my_variable, etc.), values can be of the following data types:\n\nNumber (e.g., 1, 4.5, 1E-6)\nBoolean (i.e., true, false)\nString (effectively text, but enclosed by quote marks: e.g., \"1\", \"my value\")\nturtles, patches (i.e., NetLogo’s computation entities; see Entities)\nAgentSet (a set of either turtles or patches; see Entities)\nList (a list enclosed in squared brakets with values of any kind separated by spaces: e.g., [ \"1\" 1 false my-agents-bunch [\"my value\" true 4.5] ])\n\nBefore we assign a value to a variable, we must declare its scope and name, though not its data type, which is only defined when assigning an specific value. Variable declaration is typically done at the first section of a model script and its exact position will depend on if it is stored globally or inside entities. These types of declarations follow their own structures:\nglobals [ &lt;GLOBAL_VARIABLE_NAME&gt; ]\n\nturtles-own [ &lt;TURTLE_VARIABLE_NAME&gt; ]\n\n&lt;BREED_1_NAME_PLURAL&gt;-own\n[ \n  &lt;BREED_1_VARIABLE_1_NAME&gt;\n  &lt;BREED_1_VARIABLE_2_NAME&gt;\n]\n\npatches-own [ &lt;PATCHES_VARIABLE_NAME&gt; ]\nFor example:\nglobals [ x y ]\n\nturtles-own [ weight ]\n\napples-own [ redness ]\nAs an exception to this general rule, variables can also be declared “locally” using the following syntaxes:\nlet &lt;VARIABLE_NAME&gt; &lt;VALUE&gt;\nFor example:\nlet freshness 100\nAs in other programming languages, having a variable declared locally means it is inside a temporary computation environment, such as a procedure (see below). Once the environment is closed, the variable is automatically discarded in the background.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#expressing-equations",
    "href": "program-netlogo-language-basics.html#expressing-equations",
    "title": "12  NetLogo language basics",
    "section": "12.4 Expressing equations",
    "text": "12.4 Expressing equations\nAs we will see examples further on, the values of variables can be transformed in different ways, using different syntaxes, depending on their type. Possibly the most straightforward case is to perform basic arithmetic operations over numerical variables, expressing equations. These can be written using the special characters normally used in most programming languages (+, -, *, /, (, etc.):\nset myVariable (2 + 2) * 10 / ((2 + 2) * 10)\nNotice that arithmetic symbols and numbers must be separated by spaces and that the order of operations can be structured using parentheses.\nNetLogo allow line breaks, which can help you read expressions that are too long because they hold several operations. However, too many operation at a time can become hard to read and verify, even with line breaks. The best and safer practice to overcome this is to use parentheses abundantly to ensure the right sequence of operations is performed:\nValid\nset myVariable (\n  (\n    (2 + 2) * \n    10\n  ) / (\n    (2 + 2) * \n    10\n  )\n)\nAdditionally, as proper equations, such expressions in NetLogo will also accept variables names representing their current value. Equations can then serve to create far reaching dependencies between different parts of the model code:\nset myVariable 2\nset myOtherVariable 10\n\n&lt;...&gt;\n\nlet myTemporaryVariable 2 * myVariable * myOtherVariable\n\nset myVariable myTemporaryVariable / myTemporaryVariable\nIt will normally be better to keep operations in separate lines. However, be aware that NetLogo accepts sequential commands in the same line, as long as their syntax is correct:\nset myVariable 2 set myOtherVariable 10 let myTemporaryVariable 2 * myVariable * myOtherVariable set myVariable myTemporaryVariable / myTemporaryVariable\nKnowing this, is particularly useful whenever you want to test the outcome of a longer command sequence in NetLogo’s console (“Command Center”).",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#logical-operators",
    "href": "program-netlogo-language-basics.html#logical-operators",
    "title": "12  NetLogo language basics",
    "section": "12.5 Logical operators",
    "text": "12.5 Logical operators\nAs most programming languages, NetLogo can evaluate equalities and inequalities and return a Boolean value (true or false). The related logical operators are:\n\n=: “equals”.\n\n!=: “not equal to”.\n\n&gt;: “greater than”.\n\n&gt;=: “greater than or equal to”.\n\n&lt;: “less than”.\n\n&lt;=: “less than or equal to”.\n\nFor example, try:\n1 &gt;= 0\n100 &gt;= 100 + 1\nEquality and inequality operators can also be used with other data types, though beware of the different implications. Some operations will return an error.\nFor example, you can compare Boolean values with = or !=:\ntrue = false\nbut not with quantitative comparisons:\ntrue &gt;= false\nThe same applies to lists and agent sets, but not to strings or entities (turtles, patches, links):\nValid: check if the two lists are exactly the same.\n[1 2 3] = [ 1 ]\nInvalid: a quantitative comparison between lists is not interpreted from this.\n[1 2 3] &gt; [ 1 ]\nValid: check if strings are exactly the same.\n\"apple\" = \"banana\"\nValid: compares the length of the strings.\n\"apple\" &gt;= \"banana\"\nValid: checks if entities are the same (useful when entities are referenced indirectly by variables)\npatch 0 0 != patch 1 1\nValid, but not recommended: compares the internal ID of entities, which express the creation order, which is often arbitrary.\nturtle 0 &lt; turtle 1\npatch 0 0 &gt; patch 1 1\nNote that in other programming languages the equal sign might be reserved to setting the value of a variable. For example, \"a\" = \"b\" will return false in NetLogo, while in R it will assign a value “b” to an variable named “a”. By the way, to acheive the same in R, we should write \"a\" == \"b\".",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#procedures",
    "href": "program-netlogo-language-basics.html#procedures",
    "title": "12  NetLogo language basics",
    "section": "12.6 Procedures",
    "text": "12.6 Procedures\nIn NetLogo, any action we want to perform, that is not manually typed in the console, must be enclosed within a procedure that is declared in the model script (the text in ‘Code’ tab in the user interface). Similarly to ‘functions’ or ‘methods’ in other programming languages, a procedure is the code scripted inside the following structure:\nto &lt;PROCEDURE_NAME&gt;\n  &lt;PROCEDURE_CODE&gt;\nend\nAny procedure can be executed by typing &lt;PROCEDURE_NAME&gt; + Enter in the NetLogo’s console at the bottom of the ‘Interface’ tab. The “Hello World” program, a typical minimum exercise when learning a programming language, correspond to the following procedure hello-world:\nto hello-world\n  print \"Hello World!\"\nend\nwhich generates the following “prints” in the console:\nobserver&gt; hello-world\nHello World!\nProcedures are particularly useful to group and enclose a sequence of commands that are semantically connected for the programmer. For example, the following procedure declares a temporary (local) variable, assigns to it a number as value, and prints it in the console:\nto set-it-and-show-me\n  let thisVariableOfMine 42\n  print thisVariableOfMine\nend\nProcedures can then be used elsewhere by writing its name (more complications to come). A procedure can be included as a step in another procedure:\nto &lt;PROCEDURE NAME&gt;\n  &lt;PROCEDURE_1&gt;\n  &lt;PROCEDURE_2&gt;\n  &lt;PROCEDURE_3&gt;\n  ...\nend\nNetLogo’s interface editor allows us to create buttons that can execute one or multiple procedures (or even a snippet of ad hoc code). The interface system is quite straightforward. First, at the top of the interface tab, click “Add” and select a type of element in the drop-down list. Click anywhere in the window below to place it. Select it with click-dragging or using the “Select” option in the right-click pop-up menu. You can edit the element by selecting “Edit”, also in the right-click pop-up menu. For any doubts on how to edit the interface tab, please refer to NetLogo’s documentation (https://ccl.northwestern.edu/netlogo/docs/interfacetab.html).",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#logic-bifurcations-if-and-ifelse",
    "href": "program-netlogo-language-basics.html#logic-bifurcations-if-and-ifelse",
    "title": "12  NetLogo language basics",
    "section": "12.7 Logic bifurcations: if and ifelse",
    "text": "12.7 Logic bifurcations: if and ifelse\n\nThe code exemplifies how to create conditional rules according to predefined general conditions using if/else statements, which in NetLogo can be written as if or ifelse:\n\nif (&lt;CONDITION_1_IS_TRUE&gt;)\n[\n  &lt;DO_ACTION_A&gt;\n]\n\nifelse (&lt;CONDITION_2_IS_TRUE&gt;)\n[\n  &lt;DO_ACTION_B&gt;\n]\n[\n  &lt;DO_ACTION_C&gt;\n]",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#iterators-loops",
    "href": "program-netlogo-language-basics.html#iterators-loops",
    "title": "12  NetLogo language basics",
    "section": "12.8 Iterators (loops)",
    "text": "12.8 Iterators (loops)\nUsing while, we can use a structure similar to bifurcations, to reiterate over the same code a number of times as long as a logical condition is true:\nwhile [&lt;CONDITION_1_IS_TRUE&gt;]\n[\n  &lt;DO_ACTION&gt;\n]\nNotice the use of square brackets to surround the condition ([&lt;CONDITION_1_IS_TRUE&gt;]).\nA variant of this is the primitive loop, where there is no condition, meaning that the action within will be repeated forever until the code inside stop the flow explicitly (stop or report), or the user interrupts NetLogo.\nloop\n[\n  &lt;DO_SOMETHING&gt;\n]\n\n\n\n\n\n\nCaution\n\n\n\nALERT\nAvoid using while or loop until you are confident with you code. A loop hidden inside you code, that might go forever in a few cases, can become a headache when performing simulation experiments in batches.\n\n\nA more useful iterator is repeat, which will reiterate code a certain number of times:\nrepeat &lt;NUMBER_OF_TIMES&gt;\n[\n  &lt;DO_SOMETHING&gt;\n]\nYou may quickly test it in the console with:\nlet counter 0 repeat 10 [  set counter counter + 1 ] print counter\nA especial type of iterator abundantly used in NetLogo is ask. You can ask all or any subset of entities to perform specific commands by following the structure:\nask &lt;ENTITIES&gt;\n[ \n  &lt;DO_SOMETHING&gt;\n]",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#entities-with-variables-logic-operations-and-procedures",
    "href": "program-netlogo-language-basics.html#entities-with-variables-logic-operations-and-procedures",
    "title": "12  NetLogo language basics",
    "section": "12.9 Entities with variables, logic operations, and procedures",
    "text": "12.9 Entities with variables, logic operations, and procedures\nCommands inside the ask structure can be both direct variable operations and procedures. For instance:\nask &lt;BREED_1_NAME_PLURAL&gt;\n[ \n  set &lt;BREED_1_VARIABLE_2&gt; &lt;VALUE&gt;\n  &lt;PROCEDURE_1&gt;\n  &lt;PROCEDURE_2&gt;\n  &lt;PROCEDURE_3&gt;\n]\nHowever, all variables referenced inside these structures must be properly related to their scope, following NetLogo’s syntax. For example, an agent is only able to access the variable in another agent if it we use the following kind of structure:\nask &lt;BREED_1_NAME_PLURAL&gt;\n[ \n  print [&lt;BREED_1_VARIABLE_2&gt;] of &lt;BREED_2_NAME_SINGULAR&gt; &lt;WHO_NUMBER&gt;\n]\nIt is possible to select a subset of any set of entities through logic clauses to be checked separately for each individual entity. For example, to get all agents with a certain numeric property greater than a given threshold:\n&lt;TYPE_NAME_PLURAL&gt; with [ &lt;VARIABLE_NAME_1&gt; &gt; &lt;THRESHOLD&gt; ]\nWhen operating from the inside an ask command, we can also make sure to filter-out the agent currently performing the call, by using the primitive other:\nask &lt;BREED_1_NAME_PLURAL&gt;\n[\n  ask other &lt;BREED_1_NAME_PLURAL&gt;\n  [\n    print &lt;WHO_NUMBER&gt;\n  ]\n]\nAll this can be combined to form quite complex rules of behaviour, yet keeping itself generally readable:\nto celebrate-birthday\n\n  ask people\n  [\n    if (today = my-birthday)\n    [\n      ask other people with [presents &gt; 0]\n      [\n        give-present\n      ]\n    ]\n  ]\n\nend",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#grid",
    "href": "program-netlogo-language-basics.html#grid",
    "title": "12  NetLogo language basics",
    "section": "12.10 Grid",
    "text": "12.10 Grid\nOne should spend some time understanding the grid structure and associated syntax. It is recommendable to consult the “settings” pop-up window in the “interface tab”:\n\nThe settings pop-up window in NetLogo\nThe default configuration is a 33x33 grid with the position (0,0) at the centre. Both dimensions and centre can be easily edited for each particular model. Moreover, we can specify agents behaviour at the borders by ticking the “wrap” options. Wrapping the world limits means that, for instance, under the default setting mentioned above, the position (-16,0) is adjacent to (16,0). In the console, we can “ask” the patch at (-16,0) to print its distance to the patch at (16,0), using the primitive function distance (https://ccl.northwestern.edu/netlogo/docs/dictionary.html#distance):\nobserver&gt; ask patch -16 0 [ print distance patch 16 0 ]\n1\nWrapping one dimension represents a cylindrical surface while wrapping two depicts a strange toroidal object (Doughnut!). Although this aspect is relatively hidden among the options, it can have great importance if spatial relations play any part in a model. So if you want your grid to represent a geographical map, make sure to unpick the wrapping features.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#commenting-code",
    "href": "program-netlogo-language-basics.html#commenting-code",
    "title": "12  NetLogo language basics",
    "section": "12.11 Commenting code",
    "text": "12.11 Commenting code\nAnnotations or comments (i.e., text that should be ignored when executing the code) can be added to the code by using the structure:\n&lt;CODE&gt;\n; &lt;FREE_TEXT&gt;\n&lt;CODE&gt;\nor\n&lt;CODE&gt; ; &lt;FREE_TEXT&gt;",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-netlogo-language-basics.html#dictionary",
    "href": "program-netlogo-language-basics.html#dictionary",
    "title": "12  NetLogo language basics",
    "section": "12.12 Dictionary",
    "text": "12.12 Dictionary\nOne of the most useful resources of NetLogo’s documentation is the dictionary that can be accessed in the “Help” menu. This is true at any moment throughout your learning curve; even when you know all primitives and built-in functions by heart. Moreover, all documentation is present with any copy of NetLogo, so it is fully available offline.\nThe dictionary is particularly useful whenever you are learning by example, as in our case. For instance, regarding the earlier mention of distance, you could have searched it in the dictionary directly. Whenever you find yourself reading NetLogo code with violet or blue words that you do not understand, take the habit of searching them in NetLogo’s dictionary.\nFor more information consult NetLogo Programming Guide.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>NetLogo language basics</span>"
    ]
  },
  {
    "objectID": "program-other-languages.html",
    "href": "program-other-languages.html",
    "title": "13  Sneak-peak at other languages",
    "section": "",
    "text": "13.1 ABM beyond NetLogo\nYou are now introduced to NetLogo. However, please remember that agent-based modelling (ABM) is not limited to this language and platform. It is highly recommended that you learn and practice with other programming languages to experience how ABM models can be implemented in different ways, with different goals and trade-offs.\nPotentially, any programming language can be used to implement an ABM model. After all, an ABM is “just code” describing the state and behaviour of multiple interacting agents over time. However, ABM modellers typically rely on specialised frameworks or libraries that provide ready-made functions for creating agents, scheduling their actions, managing environments, and recording outputs.\nThese frameworks help standardise model structure, improve reproducibility, and often support integration with data analysis or visualisation tools.\nBelow are some of the most relevant ABM platforms and libraries beyond NetLogo. Each of them offers different strengths and target audiences.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Sneak-peak at other languages</span>"
    ]
  },
  {
    "objectID": "program-other-languages.html#other-platforms-and-languages",
    "href": "program-other-languages.html#other-platforms-and-languages",
    "title": "13  Sneak-peak at other languages",
    "section": "13.2 Other platforms and languages",
    "text": "13.2 Other platforms and languages\nConsider yourself introduced to NetLogo! However, please remember that ABM is not limited to this language and platform. It is highly recommended that you learn and practice with other programming languages to experience ABM models beyond NetLogo implementations.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Sneak-peak at other languages</span>"
    ]
  },
  {
    "objectID": "program-other-languages.html#major-abm-platforms-and-libraries",
    "href": "program-other-languages.html#major-abm-platforms-and-libraries",
    "title": "13  Sneak-peak at other languages",
    "section": "13.3 Major ABM platforms and libraries",
    "text": "13.3 Major ABM platforms and libraries\n\n13.3.1 🧩 RePast (Recursive Porous Agent Simulation Toolkit)\n\nLanguages: Java (RePast J), Python (RePast Py), and RePast Simphony (with GUI).\nHighlights: A long-established, research-oriented platform; used in social science, ecology, and urban modelling.\nWhy it matters: Provides strong support for building complex, data-driven models; integrates with GIS and statistical analysis.\nLearn more: https://repast.github.io\n\n\n\n13.3.2 ⚙️ AnyLogic\n\nLanguage: Java-based, with a graphical modelling interface.\nHighlights: Commercial and widely used in industry (logistics, epidemiology, economics). Combines ABM, system dynamics, and discrete-event simulation.\nWhy it matters: Demonstrates how ABM concepts are applied in professional and business contexts, often for decision-support.\nLearn more: https://www.anylogic.com\n\n\n\n13.3.3 🐍 Mesa (Python)\n\nLanguage: Python.\nHighlights: Open-source ABM framework with web-based visualisation; well integrated with data science libraries like NumPy and pandas.\nWhy it matters: Ideal for researchers who already use Python for data analysis. Encourages modular and reproducible modelling workflows.\nLearn more: https://mesa.readthedocs.io\n\n\n\n13.3.4 🧮 Agents.jl (Julia)\n\nLanguage: Julia.\nHighlights: Modern, high-performance ABM library that is easy to integrate with numerical computing and visualisation tools in Julia.\nWhy it matters: Demonstrates how ABM can benefit from efficient computation and real-time data analysis in a single language.\nLearn more: https://juliadynamics.github.io/Agents.jl/stable/",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Sneak-peak at other languages</span>"
    ]
  },
  {
    "objectID": "program-other-languages.html#quick-comparison-of-abm-frameworks",
    "href": "program-other-languages.html#quick-comparison-of-abm-frameworks",
    "title": "13  Sneak-peak at other languages",
    "section": "13.4 Quick comparison of ABM frameworks",
    "text": "13.4 Quick comparison of ABM frameworks\n\n\n\n\n\n\n\n\n\n\n\nPlatform / Library\nLanguage\nVisual interface\nTypical use cases\nLicense / Access\nLearning curve\n\n\n\n\nNetLogo\nNetLogo (Logo-like)\n✅ Built-in GUI, easy model prototyping\nEducation, conceptual models, rapid exploration\nFree & open-source\n⭐ Beginner-friendly\n\n\nRePast (Simphony / J / Py)\nJava / Python\n✅ (Simphony) or code-only\nComplex scientific ABM, GIS models, large-scale simulations\nFree & open-source\n⭐⭐⭐ Advanced\n\n\nAnyLogic\nJava-based\n✅ Professional GUI, multi-method\nIndustry simulation (health, transport, logistics), decision-support\nCommercial (educational licenses available)\n⭐⭐⭐⭐ High but powerful\n\n\nMesa\nPython\n✅ Web-based UI templates\nResearch ABM + Python data analysis pipelines\nFree & open-source\n⭐⭐ Intermediate (Python skills needed)\n\n\nAgents.jl\nJulia\n✅ Visualisation in Julia ecosystem\nHigh-performance scientific computing, real-time analysis\nFree & open-source\n⭐⭐⭐ Intermediate–Advanced\n\n\n\nLegend for learning-curve stars:\n\n⭐ Beginner → ⭐⭐⭐⭐ Advanced / steep learning curve",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Sneak-peak at other languages</span>"
    ]
  },
  {
    "objectID": "program-other-languages.html#other-frameworks-and-resources",
    "href": "program-other-languages.html#other-frameworks-and-resources",
    "title": "13  Sneak-peak at other languages",
    "section": "13.5 Other frameworks and resources",
    "text": "13.5 Other frameworks and resources\nThere are many more ABM frameworks across different domains and programming languages. The SWARM.org community maintains an updated list of simulation platforms, including older but historically significant systems such as Swarm, MASON, and NetLogo itself.\n➡️ Explore: https://www.swarm.org/wiki/ABM_Resources",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Sneak-peak at other languages</span>"
    ]
  },
  {
    "objectID": "program-other-languages.html#what-to-take-away",
    "href": "program-other-languages.html#what-to-take-away",
    "title": "13  Sneak-peak at other languages",
    "section": "13.6 What to take away",
    "text": "13.6 What to take away\n\nNetLogo is ideal for learning ABM concepts quickly, focusing on model logic rather than low-level programming.\nOther frameworks (like Mesa, RePast, or Agents.jl) offer greater flexibility, scalability, and integration with scientific workflows — but they require more programming experience.\nUnderstanding multiple environments helps you:\n\nEvaluate models written by others in different ecosystems.\nChoose the right tool for your own future research.\nAppreciate that ABM is not a “NetLogo thing” but a modelling approach applicable across disciplines.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Sneak-peak at other languages</span>"
    ]
  },
  {
    "objectID": "program-other-languages.html#optional-exploration",
    "href": "program-other-languages.html#optional-exploration",
    "title": "13  Sneak-peak at other languages",
    "section": "13.7 💡 Optional exploration",
    "text": "13.7 💡 Optional exploration\nIf you’re curious, pick one of the above frameworks and browse its documentation. Ask yourself:\n\nHow are agents defined and scheduled?\nHow is the simulation environment represented (grid, network, continuous space)?\nHow are outputs collected and visualised? These are the same questions you will address in your own models, regardless of language.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Sneak-peak at other languages</span>"
    ]
  },
  {
    "objectID": "program-netlogo-tutorials.html",
    "href": "program-netlogo-tutorials.html",
    "title": "14  NetLogo tutorials",
    "section": "",
    "text": "14.1 Why work through these tutorials?\nIn this chapter you will be guided toward a solid foundation in NetLogo by working through the four official tutorials provided by the NetLogo developers. These tutorials are not optional extras but rather the core learning path into the modelling environment we will use throughout this course. They introduce the interface, the language, and the modelling mindset you will need for your simulation work. Before the tutorials, you can also have a quick look at The Beginner’s Guide to NetLogo Programming and learn or refresh your knowledge about the basics of NetLogo language with video tutorials and topic articles. It would be especially useful for you to read their page about the 11 most important primitives.\nBy completing these tutorials you will:\nBecause you will be using NetLogo in a research-modelling context (not just a classroom tutorial), the earlier you solidify your familiarity with the environment, the more time you will have for conceptual modelling, experimentation, and analysis.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NetLogo tutorials</span>"
    ]
  },
  {
    "objectID": "program-netlogo-tutorials.html#why-work-through-these-tutorials",
    "href": "program-netlogo-tutorials.html#why-work-through-these-tutorials",
    "title": "14  NetLogo tutorials",
    "section": "",
    "text": "Become comfortable with NetLogo’s user interface, including the Interface, Info and Code tabs.\nUnderstand how to explore existing models (via the Models Library), how to modify them and what the underlying code does.\nGain experience of the basic commands of the NetLogo language (for turtles, patches, observer) and how to execute simple instructions.\nMove into defining your own procedures, building up models step-by-step, and working with the Code tab in a purposeful way.\nPrepare yourself to implement the more complex models we will build later (such as the “Pond Trade” and “Messara Trade” models), with confidence in NetLogo as a modelling platform.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NetLogo tutorials</span>"
    ]
  },
  {
    "objectID": "program-netlogo-tutorials.html#the-tutorial-sequence",
    "href": "program-netlogo-tutorials.html#the-tutorial-sequence",
    "title": "14  NetLogo tutorials",
    "section": "14.2 The tutorial sequence",
    "text": "14.2 The tutorial sequence\nBelow is the sequence of the four tutorials, with short commentary on what you should focus on, and suggestions on how they link to your archaeological modelling work.\n\n\n\n#\nTutorial\nFocus and highlights for this course\n\n\n\n\n#0 – Sample Model\n“What is NetLogo?” / Sample Model\nYour entry point: open NetLogo, pick a model from the Models Library, explore buttons, sliders, plots, monitors. Ask: What do I see happening? What parameters do I have control over? This will help you think like a modeller inspecting someone else’s agent-based system.\n\n\n#1 – Models (docs.netlogo.org)\nExplore the Models Library in more depth. Learn about interface elements (buttons, sliders, choosers, switches), how a model is controlled, how it runs. For example, the Wolf-Sheep Predation model is used to illustrate. (docs.netlogo.org)\nFocus: when you later build a settlement-migration model (like in Session 6/7), you will need to design sliders and switches for your key mechanisms (migration rate, resource availability, etc.). Get accustomed to making predictions: “What will happen if I change this slider?”\n\n\n#2 – Commands (docs.netlogo.org)\nLearn how to issue commands through the Command Center, how agents behave (turtles, patches, observer), and basic language primitives. For example, in the Traffic Basic model you explore effects of simple commands.\nFocus: For your archaeological simulations you will need to script commands to initialise agents, set up the landscape, change states over time. This tutorial anchors that programming mindset: what happens behind the scenes when the user clicks “setup” or “go”.\n\n\n#3 – Procedures (docs.netlogo.org)\nYou learn to build a full model: define setup and go procedures, define agent variables, use ask commands, make plots, etc. This is where you move from “explore someone else’s model” to “build your own.” (docs.netlogo.org)\nFocus: When you come to sessions 17-22 (Pond Trade II/III) you will be programming agent behaviours and submodels. This tutorial arms you with the techniques of structuring code, naming procedures, using global variables and agent variables.",
    "crumbs": [
      "Programming for simulation modelling",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NetLogo tutorials</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html",
    "href": "pond-trade-concept.html",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "",
    "text": "15.1 Starting with models as references\nTo complement the initial “brainstorming” of conceptual models, modellers will often search and review models already published on related subjects, considering if these could be reused, at least as an inspiration.\nKeeping yourself posted about the ABM community may give you an edge. Unfortunately, academic publishing has become a saturated media, and it is relatively hard to be updated about specific types of research, such as ABM models, which are often spread in many kinds of publications. Public model repositories, such as CoMSES and initiatives like the modular library from NASSA may aid you greatly in this task. But, ultimately, finding a relevant model will depend on your skills in Internet search (including prompting the right LLM!) and the attention others have put to preparing and publishing their models.\nIn the following example, instead of building a model from scratch, we will be visiting the conceptual model corresponding to the Pond Trade model, designed by me in 2018 to facilitate learning ABM, mainly for archaeology and history.\nHaving started with a mechanism definition (the model), which already is declared to represent a phenomenon relevant to archaeologists (trade), we will then proceed to select a set of types of evidence and a case study to demonstrate it.",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html#the-pond-trade-context",
    "href": "pond-trade-concept.html#the-pond-trade-context",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "15.2 The Pond Trade context",
    "text": "15.2 The Pond Trade context\nThe Pond Trade model represents mechanisms that link cultural integration and economic cycles caused by the exchange of materials (“trade”) between settlements placed in a heterogeneous space (“pond”). The Pond Trade design intentionally includes several aspects commonly used by other ABM models in archaeology and social sciences, such as multiple types of agents, the representation of a so-called “cultural vector”, procedural generation of data, network dynamics, and the reuse of published submodels and algorithms.\nThe Pond Trade model and all its versions were developed by myself, Andreas Angourakis, and are available for download in this repository and its original repository.\nA similar model, TravellerSim, was presented by Graham and Steiner (2008), who were revisiting an older non-ABM model (Rihll and Wilson 1991, 59–95), even though one was not based on the other. All three, and indeed many more, coincide in the “informal formulation” of the core mechanism, rooted in economic theory, relating the size of settlements to how they are interconnected.\n\n\n\n\n\n\nNote\n\n\n\n\n\nSuch a situation, where similar mechanisms are modelled from scratch several times by different researchers, is, in fact, prevalent in the ABM community. There is a growing number of publications and models spreading over many specialised circles, which do not always cover all details about model implementation. Meanwhile, there is still no adequate logistical support for orderly sharing and searching for models across disciplines, despite the efforts made by CoMSES. The primary mission of NASSA is to offer a long-term solution to this problem.",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html#phenomenon",
    "href": "pond-trade-concept.html#phenomenon",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "15.3 Phenomenon",
    "text": "15.3 Phenomenon\nThe Pond Trade model core idea is inspired by the premise that the settlement economy’s size depends on the volume of materials exchanged between settlements for economic reasons (i.e. ‘trade’). The “economic” size of settlements is an overall measure of, for example, population size, the volume of material production, built-up surface, etc. The guiding suggestion was that economy size displays a chaotic behaviour as described in chaos theory: describing apparently “random” oscillations as an emergent of deterministic mechanisms. The cause of this chaotic behaviour would be presumably the shifting nature of trade routes as the outcome of many context-dependent decision-making processes. Furthermore, in addition to variation in time, routes would be bounded to more stable constraints in space, explicitly concerning the contrast of land in front of maritime and fluvial routes.",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html#mechanism-a-first-approach",
    "href": "pond-trade-concept.html#mechanism-a-first-approach",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "15.4 Mechanism: a first approach",
    "text": "15.4 Mechanism: a first approach\nThe initial inspiration for a model design may be theoretically profound, empirically based, or well-connected to discussions in the academic literature. However, the primary core mechanism of a model must narrow down to a straightforward, intelligible process. In this case, the focus is to represent a positive feedback loop between settlement size and the trade volumes coming in and out, which can be described as follows:\nCore mechanism:\n- Traders choose their destination trying to maximize the value of their cargo by considering settlement size and distance from their base settlement;\n- An active trade route will increase the economic size of settlements at both ends\n- An increase in size will increase trade by: - Making a settlement more attractive to traders from other settlements\n- Allowing the settlement to host more traders. - An active trade route will increase the cultural similarity between two settlements through the movement of traders and goods from one settlement to the other (cultural transmission)\nElements (potentially entities):\n- settlements\n- traders\n- terrain\n- routes\n- goods\nPreliminary rules:\n- Coastal settlements of variable size around a rounded water body (“pond”)\n- Traders travel between the settlements\n- Traders travel faster or slower depending on the terrain - Once in their base settlement, traders evaluate all possible trips and choose the one with the greater cost-benefit ratio\n- Traders carry economic value and cultural traits between the base and destination settlements - Settlement size depends on the economic value received from trading - The economic value produced in a settlement depends on its size - The number of traders per settlement depends on its size\nTargeted dynamics:\nSettlements that become trade hubs will increase in size and have a greater cultural influence over their trade partners, though also receiving much of their aggregated influences\nThe display above might seem somewhat chaotic and vague, but it intends to represent one of the best-case scenarios in terms of the conciseness of the initial conceptual model. There are no golden rules, good-for-all schemes or “right words” at this stage. You should start from your (or your team’s) knowledge and hypotheses and move these into implementation, where you may revise them. In my opinion, you should not limit your ideas beforehand to external frameworks (e.g., some of the points required in the ODD).\nStill, we count here on the second layer of the conceptual model, which allows us to have an overall plan of the implementation steps.",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html#base-terrain",
    "href": "pond-trade-concept.html#base-terrain",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "15.5 Base terrain",
    "text": "15.5 Base terrain\nThe Pond Trade model requires a “geography” of discrete spatial units. For simplicity, we define two types of spatial units, land and water. The general configuration should form a main water body, the “pond”, surrounded by land, and settlements should be placed around this water body. This gives us the context for having a differential cost in travelling between settlements (assuming that travel over water is easier/faster), and allows us to work with the concept of route in an heterogeneous terrain.",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html#first-tier-dynamics",
    "href": "pond-trade-concept.html#first-tier-dynamics",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "15.6 First-tier dynamics",
    "text": "15.6 First-tier dynamics\nTo pace the complexity of modelling process, we organise the further development of the Pond Trade conceptual model in two tiers. The first tier will aim to cover only some aspects of our initial formulation:\nMechanisms: - ↑ global level of productivity → ↑ settlement production\n- ↑ number of settlements → ↓ distance between settlements - ↑ settlement size → ↑ settlement production → ↑ trade flow from/to settlement → ↑ settlement size\n- ↑ settlement size → ↑ number of traders based in settlement → ↑ trade flow from/to settlement → ↑ settlement size\n- ↑ trade attractiveness of route A to B → ↑ trade flow A to B\n- ↑ distance A to B → ↓ trade attractiveness A to B - ↑ size B → ↑trade attractiveness A to B - ↑ trade flow A to B → ↑ trade flow B to A\n\nPond Trade conceptual model at start (first tier)\nTrack the paths made by the arrows in our diagram. Notice that we have drawn a system with at least two positive feedback loops (cycles with “+” arrows), one mediated by the production and the other by the number of traders.\nExpected dynamics: differentiation of settlements (size) according to their relative position",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html#second-tier-dynamics",
    "href": "pond-trade-concept.html#second-tier-dynamics",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "15.7 Second-tier dynamics",
    "text": "15.7 Second-tier dynamics\nTo reach the full version of the Pond Trade model, we also need to address the aspects related to cultural transmission and evolution:\nMechanisms:\n\n↑ global undirected variation in culture → ↑ or ↓ cultural similarity A and B (cultural drift)\n\n↑ trade flow A to B → ↑ cultural similarity A and B (cultural integration)\n\n↑ global cultural permeability → ↑ cultural similarity A and B, if A and B are trading (acceleration of cultural integration)\n\n\nPond Trade conceptual model at start (second tier)\nExpected dynamics: cultural integration as the outcome of exchange network dynamics",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-concept.html#conclusion",
    "href": "pond-trade-concept.html#conclusion",
    "title": "15  Conceptual design or modeling: the Pond Trade model",
    "section": "15.8 Conclusion",
    "text": "15.8 Conclusion\nOnce a minimum conceptual model is defined, we should use caution when attempting our first implementation. A relatively simple model may still correspond to code that can be very difficult to control and understand. Simulation models are very sensitive to the presence of feedback loops. You will notice later in the step-wise implementation of the Pond Trade model, that the positive feedback loops present in the conceptual model are not included until the most basic and predictable aspects are properly defined and their isolated behaviours verified.\n\n\n\n\nGraham, Shawn, and J. Steiner. 2008. “TravellerSim: Growing Settlement Structures and Territories with Agent-Based Modeling.” In Digital Discovery: Exploring New Frontiers in Human Heritage. CAA 2006. Computer Applications and Quantitative Methods in Archaeology. Proceedings of the 34th Conference, Fargo, United States, April 2006, edited by Jeffrey T. Clark and Emily M. Hagemeister. Budapest: Archaeolingua. https://electricarchaeology.ca/2009/10/16/travellersim-growing-settlement-structures-and-territories-with-agent-based-modeling-full-text/.\n\n\nRihll, T. E., and A. G. Wilson. 1991. “Modelling Settlement Structures in Ancient Greece: New Approaches to the Polis.” In City and Country in the Ancient World. Routledge. https://www.taylorfrancis.com/chapters/edit/10.4324/9780203418703-9/modelling-settlement-structures-ancient-greece-new-approaches-polis-rihll-wilson.",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Conceptual design or modeling: the Pond Trade model</span>"
    ]
  },
  {
    "objectID": "pond-trade-terrain.html",
    "href": "pond-trade-terrain.html",
    "title": "16  Getting started with NetLogo",
    "section": "",
    "text": "16.0.1 Test-drive: creating a “pond” terrain\nNow, let us make a minimum working example of all elements explained above while advancing towards the Pond Trade model prototype. Let us start with implementing a minimum base for the PondTrade model: the pond-like terrain.\nFor this section, I recommend starting your own NetLogo file (placed at the root directory of this repository) and writing the following steps progressively. Feel free to copy and paste whenever the code fragments become too long. If you run into any problems at the end of each step, you may check the corresponding complete script at the repository’s root.\n\n16.0.1.1 Step 0: Drawing a blue circle\nInside a single procedure, called create-map, we order (ask) all patches to do something using the structure:\nto create-map\n\n  ask patches\n  [ \n    &lt;DO_SOMETHING&gt;\n  ]\n\nend\nNext, we use the syntax for setting variables (set &lt;VARIABLE&gt; &lt;VALUE&gt;) inside the procedure to change patches color to blue:\nto create-map\n\n  ask patches\n  [ \n    set pcolor blue\n  ]\n\nend\nNotice that both pcolor and blue are ‘primitives’, so they are automatically understood by NetLogo. Remember to consult NetLogo’s Dictionary, if in doubt about such primitives. Color primitives such as blue or their numeric equivalent are shown in ‘Color Swatches’ inside the Tools menu tab.\nSince we don’t want all patches to have the same color, we need to build some structure that give different colors to patches depending on their position, so that a blue circle is draw.\nConsidering how to draw a circle, we need two bits of information: a center and a radius (respectively, O and R in the figure).\n\nFirst, we must define a center. Because we won’t use this information for anything else, we can declare and set a local variable (i.e., accessable only from its own context), using the syntax let &lt;VARIABLE&gt; &lt;VALUE&gt;. We define the center patch coordinates as (0,0):\nto create-map\n\n  ask patches\n  [ \n    let centralPatch patch 0 0\n\n    set pcolor blue\n  ]\n\nend\nWe can set a radius for our circle using a single numeric value, e.g. 5, expressed in patch widths:\nto create-map\n\n  ask patches\n  [ \n    let centralPatch patch 0 0\n\n    let minDistOfLandToCenter 5\n\n    set pcolor blue\n  ]\n\nend\nHowever, if we are passing a single absolute numeric value to be compared to a distance, the result will be sensitive to how large is our world grid. This is not wise, given that we might want to use this procedure in grids of different dimensions. Imagine that you are interested in changing the dimensions of the grid but want the circle to cover a similar proportion of it (e.g., adjusting the resolution of our map).\nWe can easily circunvent this code fragility by stepping-up its complexity. One alternative solution is to work with proportions of one of the grid dimensions, e.g. width (world-width). For the time being, we will set it to be half of half (a quater) of the width, since we have the circle positioned in the middle of the grid.\nto create-map\n\n  ask patches\n  [ \n    let centralPatch patch 0 0\n\n    let minDistOfLandToCenter round (0.5 * (world-width / 2))\n\n    set pcolor blue\n  ]\n\nend\nRunning this code will still not produce a blue circle. Rather, we are asking for all patches to paint themselve blue, no matter what the values of centralPatch or minDistOfLandToCenter.\nTo differenciate patches to be painted blue, we now use minDistOfLandToCenter for evaluating a criterium for a ifelse structure, finding out if a patch is inside or outside our circle. With this, we are ordering patches to paint themselves green or blue depending on if their distance to the center is less than a given value, i.e. minDistOfLandToCenter.\nifelse (distance centralPatch &lt; minDistOfLandToCenter)\n[\n  set pcolor blue ; water\n]\n[\n  set pcolor green ; land\n]\nNow, the entire code for the create-map procedure is finally doing what we expected, drawing a blue circle over a green background:\nto create-map\n\n  ask patches [\n\n    ; set central patch\n    let centralPatch patch 0 0\n\n    ; set minimum distance to center depending on world width\n    let minDistOfLandToCenter round (0.5 * (world-width / 2))\n\n    ifelse (distance centralPatch &lt; minDistOfLandToCenter)\n    [\n      set pcolor blue ; water\n    ]\n    [\n      set pcolor green ; land\n    ]\n\n  ]\n\nend\n\nPond Trade step 0\n\n\n16.0.1.2 Step 1a: De-composing “magic numbers”\nThe code we just created has several fixed arbitrary values (the coordinates of the centralPatch, the values used to calculate minDistOfLandToCenter). It is good enough for us to draw a particular blue circle, but it is insufficient to draw other types of blue circle. Of course, the code will never be able to draw anything, if we are not programming it to do it. For instance, the colors blue and green are also magic numbers, but we are hardly interest in having them as parameters. We must generalize but also compromise, accepting that there will be possibilities that are not covered by our model.\nFirst, is there any case where the patch 0 0 is not the one at the center of the grid? Imagine that you don’t like to have negative coordinates in your model. Go to “Settings” and modify the “location of origin” to be at the corner. Now, test the create-map procedure:\n\nNot at all what we are looking for! To correct this behavior, we must calculate the center coordinates, depending on the ranges or sizes of the grid width and height, whatever its configuration. Therefore, we must replace 0 with the calculation minimum + range / 2 for both x and y coordinates:\nlet centralPatch patch (min-pxcor + floor (world-width / 2)) (min-pycor + floor (world-height / 2))\nWe use the floor function to obtain the round lower grid position when the range is an odd number. Because this calculation uses only NetLogo primitives, you can test this by printing it in the console in any NetLogo model. It will return the central patch given your grid settings:\nobserver&gt; show patch (min-pxcor + floor (world-width / 2)) (min-pycor + floor (world-height / 2))\nobserver: (patch 16 16)\nNow, regarding minDistOfLandToCenter, we could simply bring it as a parameter to be set in the interface instead of hard-coded (e.g. as a slider). This would be a better design, but we still would have a potential problem. Maybe you do not want the grid to be squared (e.g., 33x33), but rectangular (e.g., 100x20) instead. This is what you would get:\n\nAgain, not what we are looking for. No matter how strange our map is shaped, we want our pond to be always fully within the grid. To do this, we must modify our calculation of minDistOfLandToCenter to account for both width and height. One way of doing it is to calculate the radius for both dimensions and then choose the lowest value.\nlet minXDistOfLandToCenter round (0.5 * world-width / 2) ; minimum distance in X\n\nlet minYDistOfLandToCenter round (0.5 * world-height / 2) ; minimum distance in Y\n\nlet minDistOfLandToCenter min (list minXDistOfLandToCenter minYDistOfLandToCenter)\nTo test our solution, we can run the procedure with different extreme grid settings:\n\n\n\n\n\n\n\n100x20\n20x100\n\n\n\n\n\n\n\n\n\nSuccess!\n\n\n16.0.1.3 Step 1b: Parameterizing\nOnce you defined a procedure in raw terms and tested that it does what you expect, you probably want to generalize it further. As the aim of modeling is to represent a type of phenomenon, it is a good practice to program all non-dynamic conditions as parameters. In NetLogo, parameters are often those variables that can be set through user input in the interface tab (e.g., slides, selectors, numeric fields).\nAfter the later changes, we still have two magic numbers in our code. Regarding the calculation of centralPatch and minDistOfLandToCenter, we used 2 to divide world-width and world-height, so that the circle is always draw in the center of the grid. Although it is possible, we will not replace this value with a parameter. As an exercise aside, you can test the outcome of having different numbers instead of 2.\nThe other “magic number” is 0.5, used to represent the relative size of the pond radius, i.e., the half of the half of the smaller dimension. Here we have a good candidate for a parameter. It is reasonable to believe that the size of the pond will be relevant to our model’s results. Mainly, we expect that larger ponds will make trade slower, assuming a fixed number of settlements, evenly distributed around the pond.\nIn NetLogo, we create a parameter by adding an input element to the interface tab (e.g., slider) and naming it. In this case, we create a parameter called pondSize that represents the pond radius as the percentage of the smallest dimension, i.e. varing between 0 and 100. We can use it in the code to replace the two instances of 0.5 with (pondSize / 100):\nlet minXDistOfLandToCenter round ((pondSize / 100) * (world-width / 2)) ; minimum distance in X\n\nlet minYDistOfLandToCenter round ((pondSize / 100) * (world-height / 2)) ; minimum distance in Y\n\nlet minDistOfLandToCenter min (list minXDistOfLandToCenter minYDistOfLandToCenter)\nNote that we use percentage, instead of a proportion (from 0 to 1), for no other reason than because it can improve the inteligibility of our model. I recommend using percentages to format this kind of parameters because they are more intuitive for humans and will be more easily understood by colleagues and the general public with no background in computer science or mathematics.\nOnce you close a version of any piece of code, it is good practice to increase the spacing between the lines or even break down single lines that are particularly complicated. NetLogo language allows much flexibility in this sense: you can add spaces, tabs, line breaks, and commentary between most elements of your code. Also, enclosing parenthesis are not required but may improve readability.\nto create-map\n\n  ask patches [\n\n    ; find central patch, depending on the size of dimensions\n    \n    let centralPatch\n      patch\n      ; position in X\n      (\n        min-pxcor +\n        floor (world-width / 2)\n      )\n      ; position in Y\n      (\n        min-pycor +\n        floor (world-height / 2)\n      )\n\n    print(centralPatch) ; print central patch\n\n    ; find minimun distance of land pathes to the central patch, depending on the size of dimensions\n    \n    let minXDistOfLandToCenter round ((pondSize / 100) * (world-width / 2)) ; minimum distance in X\n    \n    let minYDistOfLandToCenter round ((pondSize / 100) * (world-height / 2)) ; minimum distance in Y\n    \n    let minDistOfLandToCenter min (list minXDistOfLandToCenter minYDistOfLandToCenter)\n\n    ifelse (distance centralPatch &lt; minDistOfLandToCenter)\n    [\n      set pcolor blue ; water\n    ]\n    [\n      set pcolor green ; land\n    ]\n\n  ]\n\nend\n\n\n16.0.1.4 Step 1c: Optimasing\nWe increased significantly the create-map procedure, but we now have a process that is both flexible and controllable by user input. Yet, we still have a pending issue to solve.\nThe fact that the centralPatch and minDistOfLandToCenter are local variables (let) and placed inside ask patches [ &lt;ACTIONS&gt; ] means that we are creating and destroying a different variable once for every patch. We cannot use these variables (plural intended) outside their enclosing brackets and patches hold no memory of their values before or after this particular action. Does anything feel wrong about this?\nBesides taking unnecessary computational resources, this design does not generete any errors and, for now, is quite inofensive. However, while it can be easily solved in a short piece of code, it might become harder to find and have odd repercussions over other parts of our model later on.\nThe solution is to extract the declaration of the local variables, centralPatch and minDistOfLandToCenter, from the patches commands. They are now calculated only once at the start of the procedure and then used by every patch:\nto create-map\n\n  ; find central patch, depending on the size of dimensions\n  let centralPatch\n    patch\n    ; position in X\n    (\n      min-pxcor +\n      floor (world-width / 2)\n    )\n    ; position in Y\n    (\n      min-pycor +\n      floor (world-height / 2)\n    )\n  print(centralPatch) ; print central patch\n\n  ; find minimun distance of land pathes to the central patch, depending on the size of dimensions\n  let minXDistOfLandToCenter round ((pondSize / 100) * (world-width / 2)) ; minimum distance in X\n  let minYDistOfLandToCenter round ((pondSize / 100) * (world-height / 2)) ; minimum distance in Y\n  let minDistOfLandToCenter min (list minXDistOfLandToCenter minYDistOfLandToCenter)\n\n  ask patches [\n\n    ifelse (distance centralPatch &lt; minDistOfLandToCenter)\n    [\n      set pcolor blue ; water\n    ]\n    [\n      set pcolor green ; land\n    ]\n\n  ]\n\nend\n\nPond Trade step 1\n\n\n16.0.1.5 Step 2a: Pacing comments and line breaks\nSince our code for now is rather simple, we can downgrade the extensive commentary and line-breaking on the calculation of centralPatch.\nCommenting and spacing your code is generally a good practice, but do not get carried away! You must assume that your reader has to know something about the programming language and the context of the model. Sometimes comments and line breaks might be just too many and end up defeating the purpuse of improving the code readabiity.\nto create-map\n\n  let centralPatch patch (min-pxcor + floor (world-width / 2)) (min-pycor + floor (world-height / 2))\n\n  ; find minimun distance to center\n  let minXDistOfLandToCenter round ((pondSize / 100) * (world-width / 2)) ; minimum distance in X\n  let minYDistOfLandToCenter round ((pondSize / 100) * (world-height / 2)) ; minimum distance in Y\n  let minDistOfLandToCenter min (list minXDistOfLandToCenter minYDistOfLandToCenter)\n\n  ask patches [\n\n    ifelse (distance centralPatch &lt; minDistOfLandToCenter)\n    [\n      set pcolor blue ; water\n    ]\n    [\n      set pcolor green ; land\n    ]\n\n  ]\n\nend\nAt every step in this tutorial, we will be downgrading most commentaries added in the previous step.\n\n\n16.0.1.6 Step 2b: Exploring alternative designs\nDuring refactoring, we should always keep in mind that there are always alternative designs that could generate the outcome we seek, some of which might be more readable or optimal.\nIn this case, we can simplify the calculation of minDistOfLandToCenter. This new version initializes a local variable halfSmallerDimension assuming the smaller dimension is the width. Then, it checks that this is the case, and re-write this value if height is actually smaller. Finally, we calculate minDistOfLandToCenter as a proportion of halfSmallerDimension.\nlet halfSmallerDimension (world-width / 2)\nif (world-width &gt; world-height) [ set halfSmallerDimension (world-height / 2) ]\n\nlet minDistOfLandToCenter round ((pondSize / 100) * halfSmallerDimension)\nThis version is less redundant, uses two instead of three local variables, and expresses more clearly that the condition is the comparison between the grid width and height.\n\n\n16.0.1.7 Step 2c: Colors and shades\nLast, we replace the text reference for colors with NetLogo’s numerical codes. Using this numeric system allow us to use many shades of any given color. In this case, we are selecting slightly different shades of blue (106) and green (54). You can consult the color codes in “Tools” &gt; “Color Swatches” or in http://ccl.northwestern.edu/netlogo/docs/programming.html#colors:\n\n\nPond Trade step 2\nGreat, now we can draw a blue circle with a bulletproof piece of NetLogo code. Now let us go a few steps faster and aim at a more interesting outcome.\n\n\n16.0.1.8 Step 3: Adding noise (stochasticity)\nStochasticity is intrinsic in NetLogo. We were already dealing with random processes since step 0, when asking patches to paint themselves. You probably did not realize, but the command ask patches demands that patches are ordered somehow. Think as if you were told to ask all your friends to have a look at your new model. Well, but who exactly are you going to ask first? NetLogo solves this dilemma automaticaly by randomizing the order of “asking”. As an exercise, you can reduce the velocity of simulation (top of the interface tab), and execute the create-map procedure. You will observe each patch changing color, one at a time. This is also a nice example of using stochasticity to assure that an aggregated outcome (i.e. blue circle) is not a mere artefact of any particular schedulle of processes (i.e. the order in which patches change colors). Remember, sequences will be different every time we run our simulation, unless we preset the RNG using a specific ‘seed’ (see http://ccl.northwestern.edu/netlogo/docs/dict/random-seed.html).\nBut is it so important to have a random order? In our script so far, it is completely irrelevant. Our goal was to draw a blue circle; it does not matter which patch assumes the role of land or water first. However, this will became increasingly relevant as we advance in creating a proper agent-based model, because agents’ states DO normally depend on other agents’ states. Following the scenario where you want to show your model to your friends, imagine that your friends would talk to each other after one of them have seen your model and that some of them are more talkative and some more respected. Can you assume that the order in which you present your model would have no effect on the level of publicity and prestige of your model? ‘I don’t think so’, ‘Who knows?!’, ‘I don’t really care about it’? If these thoughts cross your mind while addressing a process in your model, you are probably better off using stochasticity.\nA perfect blue circle is great but it is a poor representation of a real water body. Once we implement the dynamics of the model, it will be quite difficult to explore the effect of geography solely by varying the size of the pond. The first step to creating more interesting set-ups is to add noise to the condition used to determine whether a patch is land or water. NetLogo has a family of primitive functions, random and alike, that can be used to generate random discrete (integer) and continuos (float) values, following different probability distributions (e.g., uniform, normal, exponential).\nFor each patch, we sample a random continuous number, add it to the minDistOfLandToCenter, and use as the threshold distance from the center:\nlet coastThreshold minDistOfLandToCenter + random-float (halfSmallerDimension * coastalNoiseLevel / 100)\n\nifelse (distance centralPatch &lt; coastThreshold)\n[\n  set pcolor 106 ; blue for water\n]\n[\n  set pcolor 54 ; green for land\n]\nThe function random-float &lt;number&gt; returns a random “float” number greater or equal to 0.0 and lower than &lt;number&gt;. To strech your learning skills, we are jumping a few minor steps in refactoring by defining a noise that is a portion of halfSmallerDimension and controlable through the parameter coastalNoiseLevel, exposed in the interface.\nto create-map\n\n let centralPatch patch (min-pxcor + floor (world-width / 2)) (min-pycor + floor (world-height / 2))\n\n let halfSmallerDimension (world-width / 2)\n if (world-width &gt; world-height) [ set halfSmallerDimension (world-height / 2) ]\n\n let minDistOfLandToCenter round ((pondSize / 100) * halfSmallerDimension)\n\n ask patches\n [\n\n   ; add noise to coast line\n   let coastThreshold minDistOfLandToCenter + random-float (halfSmallerDimension * coastalNoiseLevel / 100)\n\n   ifelse (distance centralPatch &lt; coastThreshold)\n   [\n     set pcolor 106 ; blue for water\n   ]\n   [\n     set pcolor 54 ; green for land\n   ]\n\n ]\n\nend\nWe now can generate strange “spray ponds”. More importantly, we made the generation process controllable through two parameters that are easily understandable. Play with the parameters and meditate on their effects on the shape of the pond.\n\nPond Trade step 3\n\n\n16.0.1.9 Step 4b: design alternatives\nBecause a “spray pond” is not exactly what we want, let us implement another alternative to add stochasticity. NetLogo offers the random-normal primitive, which samples a random “float-point number” given the mean and standard deviation of a normal distribution, using the structure random-normal &lt;MEAN&gt; &lt;STD.DEV&gt; (https://ccl.northwestern.edu/netlogo/docs/dictionary.html#random-reporters). In this context, we can re-use the paramater coastalNoiseLevel for the latter and consider minDistOfLandToCenter as the mean.\nComment-out the line with random-float and add the following:\n; let coastThreshold minDistOfLandToCenter + random-float (halfSmallerDimension * coastalNoiseLevel / 100)\nlet coastThreshold random-normal minDistOfLandToCenter (halfSmallerDimension * coastalNoiseLevel / 100)\nWe can now experiment running create-map in three different ways: without noise, with uniform-distributed noise, and with normal-distributed noise. We can run each by commenting-out the line corresponding to the other two. For example, to come back to the no noise option:\n; no noise\nlet coastThreshold minDistOfLandToCenter\n; uniform-distributed noise\n; let coastThreshold minDistOfLandToCenter + random-float (halfSmallerDimension * coastalNoiseLevel / 100)\n; normal-distributed noise\nlet coastThreshold random-normal minDistOfLandToCenter (halfSmallerDimension * coastalNoiseLevel / 100)\n\n\n\n\n\n\n\nno noise\n\n\n\nuniform\n\n\n\nnormal\n\n\n\n\nBut at this point, can we decide which option we want going forward?\n\n\n16.0.1.10 Step 4c: keeping design alternatives\nAs mentioned, stochasticity may be the only honest way of defining values that are unknown or undefined in our conceptual model, but still need specification in the model implementation. Another useful, still honest approach is to consolidate alternative solutions and expose the criterium for deciding among them as a special type of parameter. Often, these will be Booleans (true or false), which can be set with “switchers” in NetLogo interface, or String (declarative text, e.g. \"option A\", \"option B\", \"option C\"), which can be selected through “choosers” or dropdown menus.\nCreate a chooser by clicking at “Add” and then “chooser” in the NetLogo Interface tab. Give it the name noiseType and write down a name for each alternative as String values:\n\nThe configuration of a “chooser” for noiseType\nThen, we use this new parameter in if structures containing the code specific for each alternative:\n; no noise stands as the default alternative\nlet noiseRange (halfSmallerDimension * coastalNoiseLevel / 100)\n\nask patches\n[\n  if (noiseType = \"uniform\")\n  [\n    ; adds a random amount from a uniform distribution with mean minDistOfLandToCenter\n    set noiseRange (random-float noiseRange) - (noiseRange / 2)\n    set coastThreshold minDistOfLandToCenter + noiseRange\n  ]\n  if (noiseType = \"normal\")\n  [\n    ; adds a random amount from a normal distribution with mean minDistOfLandToCenter\n    set coastThreshold random-normal minDistOfLandToCenter noiseRange\n  ]\n\n  ...\n]\nWith this, we can now run create-map with any of the alternative designs without having to comment-out/in the code every time.\n\n\n16.0.1.11 Step 4d: patch neighborhood\nDespite having all the alternative modes of stochasticity, our ponds are still not quite what we need. This kind of terrain might be valid to represent something like a swamp, but not a distinctive water body. There is no coastline, which makes PondTrade more interesting.\nOne generic, but very useful technique in distributed computation is “smoothing”. More precisily, smoothing refers to the approximation of each point in a variable to the average of a sample of points, often taken from within the neighbourhood of the point.\nIn a two-dimensional grid such as in NetLogo, we can use the values in the immediate patch neighbourhood of each patch to adjust its value. In our present case, we want to switch the color of a patch, depending on the color of the adjacent patches. We can antecipate, however, that we will need to expose another paramater, one that can express how many neighbors (out of eight) of a type are enough to activate the change. We will call it coastLineSmoothThreshold. Notice that this step moves data in the opposite direction of our last steps, reducing stochasticity. Yet, it does not bringing us back to the original circle. Therefore, we want to smooth after adding noise.\nRemembering our mandate of modularity, we want to avoid adding the code for this operation directly in create-map. Rather, we can implement it in a cleaner way by enclosing it in a new procedure:\nto smooth-coast-line\n\n  ask patches\n  [\n    ifelse (pcolor = 106)\n    [\n      ; water patch\n      if (count neighbors with [pcolor = 54] &gt;= coastLineSmoothThreshold)\n      [\n        ; water patch has a certain number of land neighbors\n        set pcolor 54 ; converted to land\n      ]\n    ]\n    [\n      ; land patch\n      if (count neighbors with [pcolor = 106] &gt;= coastLineSmoothThreshold)\n      [\n        ; land patch has a certain number of water neighbors\n        set pcolor 106 ; converted to water\n      ]\n    ]\n  ]\n\nend\nWe can then used it by calling smooth-coast-line after create-map, either through the console or, better, by adding a button in the interface. Testing it for each noiseType:\n\n\n\n\n\n\n\nno noise\n\n\n\nuniform\n\n\n\nnormal\n\n\n\n\nNotice that there is no effect visible on the no noise option, but we significantly modify the outcome of the others.\n\n\n16.0.1.12 Step 4e: iterative structures\nTry pressing the new smooth-coast-line button more than once after create-map. The coastline will become smoother and smoother, until it becomes stable. This behaviour indicates that we have a good opportunity for implementing and iterative structure. NetLogo has a easy option for this using the follow structure: repeat &lt;NUMBER OF ITERATIONS&gt; [ &lt;COMMANDS&gt; ], requiring that we expose another parameter specifying the number of iterations, which we will call smoothIterations.\nto smooth-coast-line\n\n  ; smooth coast line\n  repeat smoothIterations\n  [\n    ask patches\n    [\n      ifelse (pcolor = 106)\n      [\n        ; water patch\n        if (count neighbors with [pcolor = 54] &gt;= coastLineSmoothThreshold)\n        [\n          ; water patch has a certain number of land neighbors\n          set pcolor 54 ; converted to land\n        ]\n      ]\n      [\n        ; land patch\n        if (count neighbors with [pcolor = 106] &gt;= coastLineSmoothThreshold)\n        [\n          ; land patch has a certain number of water neighbors\n          set pcolor 106 ; converted to water\n        ]\n      ]\n    ]\n  ]\n\nend\n\n\n16.0.1.13 Step 4f: printing event messages\nSince we are expanding considerably the complexity of our code, this is a good moment to consider printing messages for us to know what is happening in the background after pressing the buttons in the interface. This will be valuable specially when the code is encountering an error or outputing an unexpected result (i.e. debugging).\nto create-map\n\n  print \"Creating map...\"\n\n  ; erase previous data\n  clear-all\n\n  let centralPatch patch (min-pxcor + (floor world-width / 2)) (min-pycor + (floor world-height / 2))\n\n  let halfSmallerDimension (world-width / 2)\n  if (world-width &gt; world-height) [ set halfSmallerDimension (world-height / 2) ]\n\n  let minDistOfLandToCenter round ((pondSize / 100) * halfSmallerDimension)\n\n  let coastThreshold minDistOfLandToCenter ; defaults to the basic value\n\n  ;; add noise to coast line\n  ; set general noise range depending on UI's coastalNoiseLevel and the size of world\n  let noiseRange (halfSmallerDimension * coastalNoiseLevel / 100)\n\n  print \"Assigning initial patch types...\"\n\n  ask patches\n  [\n    ; noiseType is specified with the chooser in the UI\n    if (noiseType = \"uniform\")\n    [\n      ; adds a random amount from a uniform distribution with mean minDistOfLandToCenter\n      set noiseRange (random-float noiseRange) - (noiseRange / 2)\n      set coastThreshold minDistOfLandToCenter + noiseRange\n    ]\n    if (noiseType = \"normal\")\n    [\n      ; adds a random amount from a normal distribution with mean minDistOfLandToCenter\n      set coastThreshold random-normal minDistOfLandToCenter noiseRange\n    ]\n\n    ifelse (distance centralPatch &lt; coastThreshold)\n    [\n      set pcolor 106 ; blue for water\n    ]\n    [\n      set pcolor 54 ; green for land\n    ]\n\n  ]\n\n  print \"done.\"\n\nend\n\nto smooth-coast-line\n\n  print \"Smoothing...\"\n\n  ; smooth coast line\n  repeat smoothIterations\n  [\n    ask patches\n    [\n      ifelse (pcolor = 106)\n      [\n        ; water patch\n        if (count neighbors with [pcolor = 54] &gt;= coastLineSmoothThreshold)\n        [\n          ; water patch has a certain number of land neighbors\n          set pcolor 54 ; converted to land\n        ]\n      ]\n      [\n        ; land patch\n        if (count neighbors with [pcolor = 106] &gt;= coastLineSmoothThreshold)\n        [\n          ; land patch has a certain number of water neighbors\n          set pcolor 106 ; converted to water\n        ]\n      ]\n    ]\n  ]\n  print \"done.\"\n\nend\nWe just consolidated a version of our script that is able to create interesting (and more realistic) waterbody shapes with stochasticity, while being able to vary the output with a set of five parameters clearly displayed and no grave magic number unexposed.\n\nPond Trade step 4\n\n\n16.0.1.14 Step 5: refactoring (again)\nWe reached our initial objective, to have a realistic procedurally-generated terrain upon which we can build PondTrade. As before, we should now stop ourselves and think about refactoring, again.\nHere is a summary of the improvements we can make:\n\nControl the RNG seed and expose it in the interface\nMove the initialisation of coastThreshold and noiseRange before ask patches\nDeclare a new patch Boolean variable called isLand and use it to replace color in the procedures for creating terrains\nDefine a new procedure paint-patches dedicated only to set patch colors based on isLand\nCall smooth-coast-line and paint-patches at the end of create-map\nIn the evaluation of coastLineSmoothThreshold used in smooth-coast-line, consider it in relation to the actual number of neighbors instead of as an absolute number (to avoid having isolated water bodies adjacent to the world edges, where there are less than 8 neighbors)\nRearrange the interface elements to set apart the parameters we will be using for terrain generation\n\npatches-own [ isLand ]\n\nto setup\n\n  clear-all\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n\n  create-map\n\nend\n\nto create-map\n\n  let centralPatch patch (min-pxcor + (floor world-width / 2)) (min-pycor + (floor world-height / 2))\n\n  let halfSmallerDimension (world-width / 2)\n  if (world-width &gt; world-height) [ set halfSmallerDimension (world-height / 2) ]\n\n  let minDistOfLandToCenter round ((pondSize / 100) * halfSmallerDimension)\n\n  let coastThreshold minDistOfLandToCenter ; defaults to the basic value\n\n  ;; add noise to coast line\n  ; set general noise range depending on UI's coastalNoiseLevel and the size of world\n  let noiseRange (halfSmallerDimension * coastalNoiseLevel / 100)\n\n  ask patches\n  [\n    ; noiseType is specified with the chooser in the UI\n    if (noiseType = \"uniform\")\n    [\n      ; adds a random amount from a uniform distribution with mean minDistOfLandToCenter\n      set noiseRange (random-float noiseRange) - (noiseRange / 2)\n      set coastThreshold minDistOfLandToCenter + noiseRange\n    ]\n    if (noiseType = \"normal\")\n    [\n      ; adds a random amount from a normal distribution with mean minDistOfLandToCenter\n      set coastThreshold random-normal minDistOfLandToCenter (halfSmallerDimension * coastalNoiseLevel / 100)\n    ]\n\n    ifelse (distance centralPatch &lt; coastThreshold)\n    [\n      set isLand false\n    ]\n    [\n      set isLand true\n    ]\n\n  ]\n\n  smooth-coast-line\n\n  paint-patches\n\nend\n\nto smooth-coast-line\n\n  ; smooth coast line\n  repeat smoothIterations\n  [\n    ask patches\n    [\n      ifelse (isLand = false)\n      [\n        ; water patch\n        ; consider ratios instead of absolute numbers to avoid having isolated water bodies adjacent to the world limits (less than 8 neighbors)\n        if (count neighbors with [isLand = true] / count neighbors &gt;= coastLineSmoothThreshold / 8)\n        [\n          ; water patch has a certain number of land neighbors\n          set isLand true ; converted to land\n        ]\n      ]\n      [\n        ; land patch\n        if (count neighbors with [isLand = false] / count neighbors &gt;= coastLineSmoothThreshold / 8)\n        [\n          ; land patch has a certain number of water neighbors\n          set isLand false ; converted to water\n        ]\n      ]\n    ]\n  ]\n\nend\n\nto paint-patches\n\n  ask patches\n  [\n    ifelse (isLand = false)\n    [ set pcolor 106 ] ; blue for water\n    [ set pcolor 54 ] ; green for land\n  ]\n\nend\n\n\nPond Trade step 5",
    "crumbs": [
      "Pond Trade (I): basics and cellular automata",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Getting started with NetLogo</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-definition.html",
    "href": "pond-trade-agent-definition.html",
    "title": "17  Defining and initialising agents",
    "section": "",
    "text": "17.1 Refresing the specificacions of the conceptual model\nIn Block B, we will finally build a version of PondTrade through steps that will introduce you to more advanced algorithms that bring us closer to our conceptual model, such as path cost calculation, feedback loops, and evolution through vector variables.\nSo that we can cover all the steps at a good pace, we will not be delving into the same details as in Block A. I recommend you follow the steps in this block using the copy-and-paste functionality to update your script. If your version at the end of each step does not work as expected, you may want to compare it to the corresponding script (.nlogo) included in the repository (use tools like Text Compare!). If there are any doubts about NetLogo primitives, for example, remember to consult the NetLogo Dictionary from the Help menu.\nOur first aim is to reach a consolidated version corresponding to the first-tier conceptual model. In the original PondTrade repository, this will cover the development steps 6 to 9.\nPond Trade conceptual model at start (first tier)\nOne of the necessary first steps in implementing and ABM model is to define the types of agents we plan to have, based on our initial conceptual model. We must emphasise the plan part here. There is always the possibility that we will revise the conceptual model up to the point that we will require more or fewer specifications about the agents.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Defining and initialising agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-definition.html#agent-declaration",
    "href": "pond-trade-agent-definition.html#agent-declaration",
    "title": "17  Defining and initialising agents",
    "section": "17.2 Agent declaration",
    "text": "17.2 Agent declaration\nAccording to our conceptual model so far, we need two types of agents:\n\nsettlements: fixed to a coastal patch and with an “economic size” (sizeLevel). Create traders according to their size.\ntraders: mobile agents but with a fixed base at a settlement (base).\n\nbreed [ settlements settlement ]\nbreed [ traders trader ]\n\nsettlements-own [ sizeLevel ]\n\ntraders-own [ base ]\n\n\n\n\n\n\nCaution\n\n\n\nNotice that we intentionally avoid naming the size of settlements as size, since it is a NetLogo primitive used to scale the pixel size turtles in the view screen.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Defining and initialising agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-definition.html#creating-settlements",
    "href": "pond-trade-agent-definition.html#creating-settlements",
    "title": "17  Defining and initialising agents",
    "section": "17.3 Creating settlements",
    "text": "17.3 Creating settlements\nWe then write a procedure to handle the creation of all settlements, which under the PondTrade specifications, should always be placed in an empty land patch adjacent to at least one water patch (i.e., coastal settlements).\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 + random 10; sets a random arbitrary size level for the settlement (between 1 and 10)\n\n        ; give meaningful display proportional to size\n        set shape \"circle 2\"\n        set size 1 + sizeLevel / 3\n      ]\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\nWe are introducing the parameter numberOfSettlements, which we add to the interface tab as a slider (e.g., spanning from 0 to 100 by increments of 1). We randomise sizeLevel to get a sense of how we will visualise these agents.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Defining and initialising agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-definition.html#creating-traders",
    "href": "pond-trade-agent-definition.html#creating-traders",
    "title": "17  Defining and initialising agents",
    "section": "17.4 Creating traders",
    "text": "17.4 Creating traders\nWe implement the procedure for creating traders, which is a call to all settlements to generate several traders proportional to ita sizelevel. We give them a nice sailboat shape and place them randomly inside the pond.\nto create-traders-per-settlement\n\n  ask settlements\n  [\n    let thisSettlement self ; to avoid the confusion of nested agent queries\n    hatch-traders round sizeLevel ; use the sizeLevel variable as the number of traders based in the settlement\n    [\n      set base thisSettlement\n\n      ; give meaningful display related to base\n      set shape \"sailboat side\" ; import this shape from the library (Tools &gt; Shape editor &gt; import from library)\n      set color [color] of base\n      set size 3\n\n      ; place it somewhere in the pond, randomly for now (if not, the command \"hatch-breed\" will place them in the same patch of the settlement)\n      move-to one-of patches with [isLand = false]\n    ]\n  ]\n\nend",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Defining and initialising agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-definition.html#adapting-setup-initialisation",
    "href": "pond-trade-agent-definition.html#adapting-setup-initialisation",
    "title": "17  Defining and initialising agents",
    "section": "17.5 Adapting setup (initialisation)",
    "text": "17.5 Adapting setup (initialisation)\nAdd these procedures to setup, after create-map:\nto setup\n\n  clear-all\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n\n  create-map\n\n  create-coastal-settlements\n\n  create-traders-per-settlement\n\nend\nPress the Set up button and observe the outcome.\nGiven the appearance of the view screen so far, we might foresee it becoming too populated by agent icons later. As a precaution, let us enable a simple visualisation option, to switch on and off the settlement icons:\nto setup\n\n  clear-all\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n\n  create-map\n\n  create-coastal-settlements\n\n  create-traders-per-settlement\n\n  update-display\n\nend\n\nto update-display\n\n  ask settlements [ set hidden? not showSettlements ]\n\nend\n\nPond Trade step 6",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Defining and initialising agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-definition.html#check-agent-variable-inheritance",
    "href": "pond-trade-agent-definition.html#check-agent-variable-inheritance",
    "title": "17  Defining and initialising agents",
    "section": "17.6 Check agent variable inheritance",
    "text": "17.6 Check agent variable inheritance\nUnless specified otherwise, all new turtles created with create-&lt;BREED&gt; or sprout-&lt;BREED&gt; are assigned a random colour. In this case, settlements were created by specific patches with sprout-settlements, and these created traders with hatch-traders. Unlike create and sprout, the hatch command assumes that all variables in common between the creator (turtle) and the created (turtle) are to be inherited.\nTo check this after initialising your agents, right-click on top of a trader and select “trader &lt;WHO NUMBER&gt; &gt; inspect trader &lt;WHO NUMBER&gt;”.\n\n\n\nPond Trade step 6 - “View” right-click context menu\n\n\nYou now get a focus pop-up context menu where the values of each agent variable are shown. Do the same to check the information about this trader base. This time, however, write the inspect settlement &lt;WHO NUMBER&gt; directly into the console. You can now verify that the trader and settlement were assigned the exact same colour.\n\nPond Trade step 6 - agent detail",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Defining and initialising agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html",
    "href": "pond-trade-agent-ai.html",
    "title": "18  Programming agent AI",
    "section": "",
    "text": "18.1 Modelling behaviour\nWe advance into implementing the behaviour rules, i.e. Artificial Inteligence, of each agent type, particularly traders. The conceptual model specifies the following:\nImplementing this will take us several steps in development (up to step 9). Given the importance and potential complexity of these behaviours, let us start by implementing the most fundamental aspect: the traders’ criterium for choosing a destination settlement. We have mentioned “distance”, yet how should traders measure such distance in a heterogeneous terrain?",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#modelling-behaviour",
    "href": "pond-trade-agent-ai.html#modelling-behaviour",
    "title": "18  Programming agent AI",
    "section": "",
    "text": "settlements: produce goods according to their size and a productivity term. They create or destroy traders according to their current size.\ntraders: take some goods from their base and deliver them to another settlement, which is chosen based on the size of other settlements and the distance between these and the base settlement. Traders will then return with goods from that settlement back to the base and restart the cycle.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#implementing-path-finding",
    "href": "pond-trade-agent-ai.html#implementing-path-finding",
    "title": "18  Programming agent AI",
    "section": "18.2 Implementing path finding",
    "text": "18.2 Implementing path finding\nIn the original repository of the PondTrade model, you will notice an initial attempt to approach this aspect through a simple network implementation, using NetLogo’s links (PondTrade_step07_agent AI v1_links.nlogo). This approach is similar to other ABM and network-based models applied to topics of trade and settlement interactions.\nHowever, as you may know, there can be a significant difference between a straight line measurement (Euclidean distance) and a more complex path cost calculation that uses terrain data. As the PondTrade model eventually did, we will to “complicate” our design and make a proper “least-cost route” calculation using this as a perfect excuse for learning.\nBut how should we implement a least-cost path algorithm in NetLogo? We follow our modular philosophy, search and find an implementation of the A* (A-star) algorithm in NetLogo User Community Models. We get the main fragment of the code and adapt it to our purposes, making sure we keep a clear reference to the source as a commentary header:shown. Do the same to check the information about this trader base. This time, however, write the inspect settlement &lt;WHO NUMBER&gt; directly into the console. You can now verify that the trader and settlement were assigned the same colour.\npatches-own\n[\n  isLand\n  pathCost\n  \n  ;;; path-finding related\n  parent-patch ; patch's predecessor\n  f ; the value of knowledge plus heuristic cost function f()\n  g ; the value of knowledge cost function g()\n  h ; the value of heuristic cost function h()\n]\n\n...\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; A* path finding algorithm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; modified from Meghendra Singh's Astardemo1 model in NetLogo User Community Models\n; http://ccl.northwestern.edu/netlogo/models/community/Astardemo1\n; modified lines/fragments are marked with \";-------------------------------*\"\n; In this version, patches have different movement cost.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n; the actual implementation of the A* path finding algorithm\n; it takes the source and destination patches as inputs\n; and reports the optimal path if one exists between them as output\nto-report find-a-path [ source-patch destination-patch]\n\n  ; initialize all variables to default values\n  let search-done? false\n  let search-path []\n  let current-patch 0\n  let open [] ;-------------------------------*\n  let closed [] ;-------------------------------*\n\n  ;-------------------------------*\n  ask patches with [ f != 0 ]\n  [\n    set f 0\n    set h 0\n    set g 0\n  ]\n  ;-------------------------------*\n\n  ; add source patch in the open list\n  set open lput source-patch open\n\n  ; loop until we reach the destination or the open list becomes empty\n  while [ search-done? != true]\n  [\n    ifelse length open != 0\n    [\n      ; sort the patches in open list in increasing order of their f() values\n      set open sort-by [ [?1 ?2] -&gt; [f] of ?1 &lt; [f] of ?2 ] open\n\n      ; take the first patch in the open list\n      ; as the current patch (which is currently being explored (n))\n      ; and remove it from the open list\n      set current-patch item 0 open\n      set open remove-item 0 open\n\n      ; add the current patch to the closed list\n      set closed lput current-patch closed\n\n      ; explore the Von Neumann (left, right, top and bottom) neighbors of the current patch\n      ask current-patch\n      [\n        ; if any of the neighbors is the destination stop the search process\n        ifelse any? neighbors4 with [ (pxcor = [ pxcor ] of destination-patch) and (pycor = [pycor] of destination-patch)] ;-------------------------------*\n        [\n          set search-done? true\n        ]\n        [\n          ; the neighbors should not already explored patches (part of the closed list)\n          ask neighbors4 with [ (not member? self closed) and (self != parent-patch) ] ;-------------------------------*\n          [\n            ; the neighbors to be explored should also not be the source or\n            ; destination patches or already a part of the open list (unexplored patches list)\n            if not member? self open and self != source-patch and self != destination-patch\n            [\n              ;set pcolor 45 ;-------------------------------*\n\n              ; add the eligible patch to the open list\n              set open lput self open\n\n              ; update the path finding variables of the eligible patch\n              set parent-patch current-patch\n              set g [g] of parent-patch + pathCost ;-------------------------------*\n              set h distance destination-patch\n              set f (g + h)\n            ]\n          ]\n        ]\n;        if self != source-patch ;-------------------------------*\n;        [\n;          set pcolor 35\n;        ]\n      ]\n    ]\n    [\n      ; if a path is not found (search is incomplete) and the open list is exhausted\n      ; display a user message and report an empty search path list.\n      user-message( \"A path from the source to the destination does not exist.\" )\n      report []\n    ]\n  ]\n\n  ; if a path is found (search completed) add the current patch\n  ; (node adjacent to the destination) to the search path.\n  set search-path lput current-patch search-path\n\n  ; trace the search path from the current patch\n  ; all the way to the source patch using the parent patch\n  ; variable which was set during the search for every patch that was explored\n  let temp first search-path\n  while [ temp != source-patch ]\n  [\n;    ask temp ;-------------------------------*\n;    [\n;      set pcolor 85\n;    ]\n    set search-path lput [parent-patch] of temp search-path\n    set temp [parent-patch] of temp\n  ]\n\n  ; add the destination patch to the front of the search path\n  set search-path fput destination-patch search-path\n\n  ; reverse the search path so that it starts from a patch adjacent to the\n  ; source patch and ends at the destination patch\n  set search-path reverse search-path\n\n  ; report the search path\n  report search-path\nend\nBecause our model assigns different path costs for each patch (i.e., land or water), we must create a new procedure that assigns these costs and add a call to it just after the other steps in create-map:\nto create-map\n\n  ...\n\n  assign-path-cost\n\n  paint-patches\n\nend\n\n...\n\nto assign-path-cost\n\n  ask patches\n  [\n    ifelse (isLand = false)\n    [ set pathCost 1 ] ; arbitrary unit for now\n    [ set pathCost relativePathCostInLand ] ; defined by parameter in relation to the cost of path in water (i.e., 1)\n  ]\n\nend\nWe are forced then to introduce another parameter, relativePathCostInLand, which specifies how much the movement on land costs in relation to the movement on the water. Add a slider in the interface (from 0 to 100, by 0.01, default value at 50).\nGiven the special circumstance of traders arriving and leaving settlements, let us introduce a differential value for pathCost in patches with settlements. For this we should modify create-coastal-settlements and introduce the parameter relativePathCostInPort (from 0 to 100, by 0.01, default value at 10):\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 + random 10 ; sets a random arbitrary size level for the settlement (between 1 and 10)\n\n        ; give meaningful display proportional to size\n        set shape \"circle 2\"\n        set size 1 + sizeLevel / 3\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\nNotice that relativePathCostInPort will generally not affect A* results since routes will always have two patches with this pathCost. However, it does matter because routes will more likely avoid going through a third settlement if a path through water is available.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#testing-the-algorithm",
    "href": "pond-trade-agent-ai.html#testing-the-algorithm",
    "title": "18  Programming agent AI",
    "section": "18.3 Testing the algorithm",
    "text": "18.3 Testing the algorithm\nYou can now experiment with the A* algorithm by running setupas it is, and then find-a-path between two patches of your choosing. To observe how the algorithm works, you can “uncomment” the lines, including code about colouring patches within the algorithm code. Then, reduce the simulation speed in the interface and rerun the procedure.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice how the large difference in path cost between land and water (x50) makes A* avoid drawing a route through land, practically until all adjacent water patches are explored.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#adapting-model-schedule",
    "href": "pond-trade-agent-ai.html#adapting-model-schedule",
    "title": "18  Programming agent AI",
    "section": "18.4 Adapting model schedule",
    "text": "18.4 Adapting model schedule\nNow that we have confirmed the code we just introduced let us implement everything we will need to call A* and keep track of all routes between settlements. Given that A* takes time to compute, we should make everything possible to avoid repeating the calculation of routes.\nglobals [ routes ]\n\n...\n\nto setup\n\n  reset-timer\n  clear-all\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n\n  create-map\n\n  create-coastal-settlements\n\n  set-routes\n\n  create-traders-per-settlement\n\n  update-display\n\n  output-print (word \"Set up took \" timer \" seconds.\")\n\nend\n\n...\n\nto set-routes\n\n  set routes [] ; initialize/reset the routes as an empty list\n\n  let settlementsWithoutRoutes settlements ; helper variable to keep track of which settlement already searched for routes\n\n  ask settlements\n  [\n    let thisSettlement self\n\n    ask other settlementsWithoutRoutes\n    [\n      let optimalRoute find-a-path ([patch-here] of thisSettlement) ([patch-here] of self) ; find the optimal route to this settlement\n      set routes lput optimalRoute routes ; add the optimal route to the end of the routes list\n\n      ; paint route patches in shades of red depending on route frequency\n      foreach optimalRoute\n      [ ?1 -&gt;\n        ask ?1\n        [\n          ifelse (pcolor = 106 or pcolor = 54) ; if its the first route crossing the patch\n          [\n            set pcolor 11\n          ]\n          [\n            set pcolor min (list (pcolor + 1) (19)) ; sets a maximum at 19 (the brightest)\n          ]\n        ]\n      ]\n    ]\n\n    set settlementsWithoutRoutes other settlementsWithoutRoutes\n\n  ]\n\nend\nRunning the code as it is will generate the maximum number of routes given the settlements present (e.g., if numberOfSettlements = 10, it will be 45 or 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1). We store each route as a list of patches, and all routes as a list of routes (routes). These will be globally accessible by all traders in our model.\nNotice that it takes a considerable time to calculate all possible routes, and the number of settlements increases this time exponentially. At this point, we should be aware of how to stop NetLogo while still running a long command. Go to Tools &gt; Halt. This might not work if NetLogo interface is unresponsive. Then the only options are to wait or quit or force-quit NetLogo.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#decision-making",
    "href": "pond-trade-agent-ai.html#decision-making",
    "title": "18  Programming agent AI",
    "section": "18.5 Decision making",
    "text": "18.5 Decision making\nHaving the calculation of routes solved, we now must use them to inform the decision of traders. Let us create a procedure to be called by traders named choose-destination, for which we will need to implement a few “helper” procedures:\ntraders-own [ base route destination direction lastPosition ]\n\n...\n\nto choose-destination ; ego = trader\n\n  let thisTrader self\n\n  ; get routes connecting the base settlement\n  let routesFromBase get-routes-from-settlement [base] of thisTrader\n\n  ; order these routes by benefit/cost ratio\n  set routesFromBase sort-by [ [?1 ?2] -&gt; benefit-cost-of-route ?1 &gt; benefit-cost-of-route ?2 ] routesFromBase\n\n  ; print the options available\n;  foreach routesFromBase\n;  [\n;    print \"===============================================================\"\n;    print \"route between:\"\n;    print [who] of get-origin-and-destination ?\n;    print \"has the benefit-cost ratio of:\"\n;    print benefit-cost-of-route ?\n;  ]\n;  print \"-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x\"\n\n  ; select the one with higher benefit/cost ratio\n  set route first routesFromBase\n\n  ; mark the most effective route\n  foreach route\n  [ ?1 -&gt;\n    ask ?1 [ set pcolor yellow ]\n  ]\n\n  ; get the settlement of destination\n  set destination one-of (get-origin-and-destination route) with [who != [who] of ([base] of thisTrader)]\n\nend\n\n...\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Get and set routes (helper 'to-report' procedures) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\nto-report get-route [ settlement1 settlement2 ] ; accepts two settlements and returns a route\n\n  ; get routes connecting settlement1\n  let routesFromSettlement1 filter\n  [ ?1 -&gt;\n    ([one-of settlements-here] of first ?1 = settlement1) or\n    ([one-of settlements-here] of last ?1 = settlement1)\n  ] routes\n\n  ; get the route connecting settlement2 from the previous list\n  let routeFromSettlement1ToSettlement2 filter\n  [ ?1 -&gt;\n    ([one-of settlements-here] of first ?1 = settlement2) or\n    ([one-of settlements-here] of last ?1 = settlement2)\n  ] routesFromSettlement1\n\n  report first routeFromSettlement1ToSettlement2\n\nend\n\nto-report get-routes-from-settlement [ aSettlement ] ; accepts a settlement and return a list of routes\n\n  report filter\n  [ ?1 -&gt;\n    ([one-of settlements-here] of first ?1 = aSettlement) or\n    ([one-of settlements-here] of last ?1 = aSettlement)\n  ] routes\n\nend\n\nto-report get-origin-and-destination [ aRoute ] ; accepts a route and returns a turtle-set with two settlements\n\n  report (turtle-set ([ one-of settlements-here ] of first aRoute) ([one-of settlements-here ] of last aRoute))\n\nend\n\nto-report benefit-cost-of-route [ aRoute ] ; accepts a route and returns a number (the benefit/cost ratio of the route)\n\n  let cost 0\n\n  foreach aRoute ; for every patch in the given route\n  [ ?1 -&gt;\n    set cost cost + [pathCost] of ?1\n  ]\n\n  let originAndDestination get-origin-and-destination aRoute\n  let benefit 0\n  ask originAndDestination [ set benefit benefit + sizeLevel ] ; the benefit is the sum of the sizeLevel of the two settlements\n\n  report benefit / cost\n\nend\nNotice that get-route is only helpful for debugging and querying the information in routes.\nTo inform the traders’ decisions, we specify a very simple calculation of the potential gain of a route (sum of sizeLevel of origin and destination) and calculate a ratio between the benefit and cost of routes. Traders will then compare these ratios for all possible routes from its base settlement and choose the one with the highest value.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#movement",
    "href": "pond-trade-agent-ai.html#movement",
    "title": "18  Programming agent AI",
    "section": "18.6 Movement",
    "text": "18.6 Movement\nOnce a destination is decided, traders must move towards it and then, once there, start the return trip. We implement this behaviour assuming that movement must go through each patch center in the route and that traders move at a maximum speed of 1 / [pathCost] of patch-here, meaning they will be delayed in proportion to the local value of pathCost.\nto move-to-destination ; ego = trader\n\n  ; update lastPosition if in a patch center\n  if ((xcor = [pxcor] of patch-here) and (ycor = [pycor] of patch-here))\n  [\n    set lastPosition patch-here\n  ]\n  ; find where in the route list is the trader\n  let currentPosition position lastPosition route\n\n  ; set direction if in a settlement\n  ifelse (currentPosition = 0) ; in the first extreme of the route list\n  [\n    set direction 1 ; move in the route list towards larger index numbers\n  ]\n  [\n    if (currentPosition = (length route - 1)) ; in the last extreme of the route list\n    [\n      set direction -1 ; move in the route list towards smaller index numbers\n    ]\n  ]\n  ; else the trader is in route to either the base or the destination\n\n  ; move through the route following direction\n  let targetPatch item (currentPosition + direction) route\n  ;move-to targetPatch ; constant travel time (1 patch per tick)\n  facexy ([pxcor] of targetPatch) ([pycor] of targetPatch)\n  forward min (\n    list\n    (1 / [pathCost] of patch-here) ; the maximum distance in a tick in the current patch\n    (distancexy ([pxcor] of targetPatch) ([pycor] of targetPatch)) ; the distance to the target patch\n    )\n\nend\nWe wrap up this development step by finally implementing our preliminary model cycle, ordering the behaviour of traders within the conventional go procedure:\nto go\n\n  ask traders\n  [\n    if (patch-here = [patch-here] of base) ; update the destination whenever in the base settlement\n    [\n      choose-destination\n    ]\n    move-to-destination\n  ]\n\nend\nAs we specified in our conceptual model, traders will choose a destination whenever they are at their base and move towards their current destination.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#enhancing-visualisation",
    "href": "pond-trade-agent-ai.html#enhancing-visualisation",
    "title": "18  Programming agent AI",
    "section": "18.7 Enhancing visualisation",
    "text": "18.7 Enhancing visualisation\nTo help visualise routes, implement the following version of update-display, call it at the end of setup, and add two switches, showRoutes and showActiveRoutes to the interface:\nto setup\n\n  clear-all\n  reset-ticks\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n\n  create-map\n\n  create-coastal-settlements\n\n  set-routes\n\n  create-traders-per-settlement\n\n  update-display\n\nend\n\n...\n\nto update-display\n\n  paint-routes\n  paint-active-routes\n\n  ; scale the size of settlements according to their dynamic free-scaled sizeLevel\n  let maxSettlementSize max [sizeLevel] of settlements\n\n  ask settlements\n  [\n    set hidden? not showSettlements\n    set size 1 + (sizeLevel / maxSettlementSize) * 9\n  ]\n\nend\n\nto paint-routes\n\n  ; resets route patches to the terrain color\n  foreach routes\n  [ ?1 -&gt;\n    let aRoute ?1\n\n    foreach aRoute\n    [ ??1 -&gt;\n      ask ??1 [ paint-terrain ]\n    ]\n  ]\n\n  ; paint route patches in shades of red depending on route frequency\n  foreach routes\n  [ ?1 -&gt;\n    let aRoute ?1\n\n    foreach aRoute\n    [ ??1 -&gt;\n      ask ??1\n      [\n        if (showRoutes)\n        [\n          ifelse (pcolor &lt; 11 or pcolor &gt; 19) ; if its the first route crossing the patch\n          [\n            set pcolor 11\n          ]\n          [\n            set pcolor min (list (pcolor + 1) (19)) ; sets a maximum at 19 (the brightest)\n          ]\n        ]\n      ]\n    ]\n  ]\n\nend\n\nto paint-active-routes\n\n  ask traders\n  [\n    foreach route\n    [ ?1 -&gt;\n      ask ?1\n      [\n        ifelse (showActiveRoutes)\n        [\n          set pcolor yellow\n        ]\n        [\n          if (not showRoutes) ; if not displaying all routes\n          [\n            ; resets to the patch terrain color\n            paint-terrain\n          ]\n        ]\n      ]\n    ]\n  ]\n\nend",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-agent-ai.html#testing-agent-behaviour",
    "href": "pond-trade-agent-ai.html#testing-agent-behaviour",
    "title": "18  Programming agent AI",
    "section": "18.8 Testing agent behaviour",
    "text": "18.8 Testing agent behaviour\nAs a temporary “hack”, replace the code create-traders-per-settlement with the following:\nto create-traders-per-settlement\n\n  ; For now, we create only one trader to better control its behaviour\n  ask one-of settlements\n  [\n    let thisSettlement self\n\n    hatch-traders 1\n    [\n      set base thisSettlement\n\n      set shape \"sailboat side\" ; import this shape from the library (Tools &gt; Shape editor &gt; import from library)\n      set color [color] of base\n      set size 3\n    ]\n  ]\n\n; the previous code for creating traders can be commented out\n; by adding ';' at the beggining of each line, or\n; by selecting several lines and either selecting 'Edit &gt; Comment' or pressing 'ctrl + ;'.\n;  ask settlements\n;  [\n;    let thisSettlement self ; to avoid the confusion of nested agent queries\n;    hatch-traders round sizeLevel ; use the sizeLevel variable as the number of traders based in the settlement\n;    [\n;      set base thisSettlement\n;\n;      ; give meaningful display related to base\n;      set shape \"sailboat side\" ; import this shape from the library (Tools &gt; Shape editor &gt; import from library)\n;      set color [color] of base\n;      set size 3\n;\n;      ; place it somewhere in the pond, randomly for now (if not, the command \"hatch-breed\" will place them in the same patch of the settlement)\n;      move-to one-of patches with [isLand = false]\n;    ]\n;  ]\n\nend\nReduce numberOfSettlements, vary seed, and run setup again. Run go repeatedly to observe the behaviour of the loner trader.\n\nPond Trade step 7",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programming agent AI</span>"
    ]
  },
  {
    "objectID": "pond-trade-mechanism.html",
    "href": "pond-trade-mechanism.html",
    "title": "19  Implementing mechanisms",
    "section": "",
    "text": "We now reach the “spicy” part of the development of PondTrade. Until this point, settlements are completely static, and traders are only created in setup, then travel back and forth without any consequence to settlements.\nFirst, we want to implement the feedback loop described in the conceptual model, connecting settlement size, production, and trade inflow.\nLet us re-organise the behavioural cycle of traders into a new separate procedure update-traders:\nto update-traders\n\n  let tradersInBase traders with [is-in-base]\n  let tradersInDestination traders with [is-in-destination]\n\n  ; UPDATE LAST POSITION\n  ask traders\n  [\n    ; update lastPosition if in a patch center\n    if ((xcor = [pxcor] of patch-here) and (ycor = [pycor] of patch-here))\n    [\n      set lastPosition patch-here\n    ]\n  ]\n\n  ; UNLOAD\n  ask (turtle-set tradersInBase tradersInDestination) with [cargoValue &gt; 0]\n  [\n    ; unload cargo (changes sizeLevel)\n    unload-cargo\n    ; load cargo (changes stock)\n    load-cargo\n  ]\n\n  ; CHOOSE DESTINATION\n  ask tradersInBase\n  [\n    ; update the destination whenever in the base settlement and there is cargo to transport\n    choose-destination\n  ]\n\n  ; FIND DIRECTION in route\n  ask (turtle-set tradersInBase tradersInDestination)\n  [\n    find-direction\n  ]\n\n  ; MOVE towards the next position in the route\n  ask traders\n  [\n    ; move following the route when there is cargo to transport\n    move-to-destination\n  ]\n\nend\n\nto choose-destination ; ego = trader\n\n  let thisTrader self\n\n  ; get routes connecting the base settlement\n  let routesFromBase get-routes-to-settlement [base] of thisTrader\n\n  ; order these routes by benefit/cost ratio\n  set routesFromBase sort-by [ [?1 ?2] -&gt; benefit-cost-of-route ?1 &gt; benefit-cost-of-route ?2 ] routesFromBase\n\n  ; print the options available\n;  foreach routesFromBase\n;  [\n;    print \"===============================================================\"\n;    print \"route between:\"\n;    print [who] of get-origin-and-destination ?\n;    print \"has the benefit-cost ratio of:\"\n;    print benefit-cost-of-route ?\n;  ]\n;  print \"-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x\"\n\n  ; select the one with higher benefit/cost ratio\n  set route first routesFromBase\n\n  ; get the settlement of destination\n  set destination one-of (get-origin-and-destination route) with [who != [who] of ([base] of thisTrader)]\n\nend\n\nto find-direction ; ego = trader\n\n  ; find where in the route list is the trader\n  let currentPosition position lastPosition route\n\n  ; set direction if in a settlement\n  ifelse (currentPosition = 0) ; in the first extreme of the route list\n  [\n    ; move in the route list towards larger index numbers\n    set direction 1\n  ]\n  [\n    if (currentPosition = (length route - 1)) ; in the last extreme of the route list\n    [\n      ; move in the route list towards smaller index numbers\n      set direction -1\n    ]\n  ]\n  ; else the trader is in route to either the base or the destination\n\nend\n\nto move-to-destination ; ego = trader\n\n  ; find where in the route list is the trader\n  let currentPosition position lastPosition route\n\n  ; move through the route following direction\n  let targetPatch item (currentPosition + direction) route\n  ;move-to targetPatch ; constant travel time (1 patch per tick)\n  facexy ([pxcor] of targetPatch) ([pycor] of targetPatch)\n  forward min (\n    list\n    (1 / [pathCost] of patch-here) ; the maximum distance in a tick in the current patch\n    (distancexy ([pxcor] of targetPatch) ([pycor] of targetPatch)) ; the distance to the target patch\n    )\n\nend\n\nto-report is-in-base ; ego = trader\n\n  report (xcor = [xcor] of base) and (ycor = [ycor] of base) ; if the trader arrived at the center of the base patch\n\nend\n\nto-report is-in-destination ; ego = trader\n\n  report (xcor = [xcor] of destination) and (ycor = [ycor] of destination) ; if the trader arrived at the center of the destination patch\n\nend\nNotice that we refactor the previous code, splitting the former procedures into several more specialised parts.\nWe then define the new procedures to handle the interaction between traders and settlements:\ntraders-own [ base route destination direction lastPosition cargoValue ]\n\n...\n\nto unload-cargo ; ego = trader\n\n  let thisTrader self\n  let settlementHere one-of settlements-here\n\n  ; unload cargo\n  ask settlementHere [ add-trade-effect [cargoValue] of thisTrader ]\n\nend\n\nto load-cargo ; ego = trader\n\n  let settlementHere one-of settlements-here\n\n  ; load cargo\n  set cargoValue [sizeLevel] of settlementHere\n\nend\n\nto add-trade-effect [ value ] ; ego = settlement\n\n  set sizeLevel sizeLevel + value\n\nend\n\nObserve that we are defining a very simple “submodel” , where the economic size units of one settlement produce an equivalent amount of transportable value (cargoValue), which is transferred by traders to another settlement, again as economic size units. However, with this mechanism, we are increasing the economic size of settlements in every trader trip but never decrease it. To avoid this, we must specify a second mechanism that “decays” economic size with time, up to a baseline arbitrary value (i.e., 1).\nFor now, we implement this mechanism directly inside the goprocedure, where we also call update-traders:\nto go\n\n  tick\n\n  update-traders\n\n  ; the size of settlements decays with a constant rate, up to 1 (minimum)\n  ask settlements\n  [\n    set sizeLevel max (list 1 (sizeLevel * (1 - (settlementSizeDecayRate / 100)) ) )\n  ]\n\n  update-display\n\nend\nWe must add to the interface yet another parameter to regulate decay, settlementSizeDecayRate (from 0 to 25, by 0.01, default value of 5). This is expressed as the percentage of sizeLevel that is subtracted at each simulation step.\nTo better explore the effects of this feedback loop, it is time for us to start adding some plots to the interface. Select Plot in the dropdown menu and add two plot objects, as you have done with buttons, sliders, etc. Configure them as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can now run the model with a few settlements and repeat go many times. Explore different seed numbers. Are settlements reacting to traders’ dynamics at all? Is the value of settlementSizeDecayRate too high or low? What are we doing wrong?\n\nPond Trade step 8\nBefore moving to the second feedback loop, we must solve our problem. If you followed any of the different approaches for debugging (e.g., inspecting agents, printing messages in mid-code), you have detected that traders are not transporting any cargoValue. The problem resides in how we have scheduled the calls for unload-cargoand load-cargo. Notice that we added load-cargo to a conditional call ask (turtle-set tradersInBase tradersInDestination) with [cargoValue &gt; 0], only relevant to traders with cargo, which is impossible for traders to fulfill initially.\nWe re-organise update-tradersas follows:\nto update-traders\n  \n  ...\n\n  ; UNLOAD\n  ask (turtle-set tradersInBase tradersInDestination) with [cargoValue &gt; 0]\n  [\n    ; unload cargo (changes sizeLevel)\n    unload-cargo\n  ]\n\n  ; LOAD\n  ask (turtle-set tradersInBase tradersInDestination)\n  [\n    ; load cargo (changes stock)\n    load-cargo\n  ]\n\n  ...\n\nend\n\nPond Trade step 8 (after correction)\nWe can now see how, quite often, one or very few hubs emerge among settlements.\n\nThe second positive feedback loop in our concept model relates settlement size, the number of traders per settlement, and trade inflow.\nThe key addition is that now we will have to differentiate, for each settlement, between currentNumberOfTraders and potentialNumberOfTraders, and update these according sizeLevel. To wrap up all this, we finally implement an update procedure specifically for settlements (update-settlements).\nWe will also need to manage the traders that are left outside the maximum value for its base settlement. We create the tag isActivated, in order to avoid creating and deleting too many traders in the same simulation run (i.e., it might become a problem when who numbers start getting bigger and bigger).\nsettlements-own\n[\n  sizeLevel\n  currentNumberOfTraders potentialNumberOfTraders\n]\n\ntraders-own\n[\n  isActivated\n  base route destination direction lastPosition\n  cargoValue\n]\n\n...\n\n\nto create-traders-per-settlement\n\n  ask settlements\n  [\n    let thisSettlement self ; to avoid the confusion of nested agent queries\n\n    set potentialNumberOfTraders get-potential-number-of-traders\n\n    hatch-traders potentialNumberOfTraders ; use the sizeLevel variable as the number of traders based in the settlement\n    [\n      setup-trader thisSettlement\n    ]\n\n    set currentNumberOfTraders get-current-number-of-traders\n  ]\n\nend\n\nto setup-trader [ baseSettlement ]\n\n  set base baseSettlement\n  set isActivated true\n\n  ; give meaningful display related to base\n  set shape \"sailboat side\" ; import this shape from the library (Tools &gt; Shape editor &gt; import from library)\n  set color [color] of base\n  set size 3\n\n  choose-destination\n\nend\n\n...\n\nto update-settlements\n\n  ask settlements\n  [\n    let thisSettlement self\n\n    ; the sizeLevel of settlements decays with a constant rate, up to 1 (minimum)\n    set sizeLevel max (list 1 (sizeLevel * (1 - (settlementSizeDecayRate / 100)) ) )\n\n    ; determine the current and potential number of traders\n    set currentNumberOfTraders get-current-number-of-traders\n    set potentialNumberOfTraders get-potential-number-of-traders\n\n    ; conditions favors the creation of new traders\n    if (random-float 1 &gt; currentNumberOfTraders / potentialNumberOfTraders )\n    [\n      ; create a new trader or activate an old one\n      repeat 1\n      [\n        ifelse (any? traders with [not isActivated])\n        [\n          ask one-of traders with [not isActivated]\n          [\n            setup-trader thisSettlement\n            move-to thisSettlement\n          ]\n        ]\n        [\n          hatch-traders 1\n          [\n            setup-trader thisSettlement\n          ]\n        ]\n      ]\n      set currentNumberOfTraders get-current-number-of-traders ; update currentNumberOfTraders\n    ]\n  ]\n\nend\n\n...\n\nto-report get-potential-number-of-traders ; ego = settlement\n\n  report (\n    1 +\n    (sizeLevel - 1)\n    )\n\nend\n\nto-report get-current-number-of-traders ; ego = settlement\n\n  let thisSettlement self\n  report count traders with [isActivated and base = thisSettlement ]\n\nend\n\nSettlements will now calculate potentialNumberOfTraders at every simulation step as a number equal to its size and be allowed to create/reactivate or deactivate any traders accordingly.\nAdd a new Plot to visualise the count of traders through time, using the update command: plot count traders with [isActivated]\nOur second feedback loop is now up and running!\nHowever, our implementation is still rough on the edges and needs a bit of refactoring and model extensions.\nThe representation of the production process is overly simplistic. With no separable entity from sizeLevel, production value gets immediately replaced after traders load their cargo. We must introduce a new settlement variable, stock, to keep track of the flow of economic value and implement a more explicit representation of production and value decay, independent of size decay. For this, we introduce two new parameters, productionRate and stockDecayRate (use same interface configuration from settlementSizeDecayRate).\nsettlements-own\n[\n  ...\n  stock\n]\n\n...\n\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 ; the size level is initiated at minimum (i.e., 1)\n        set stock 0\n        set shape \"circle 2\"\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\n\n...\n\nto load-cargo ; ego = trader\n\n  let settlementHere one-of settlements-here\n\n  ; load cargo\n  set cargoValue [stock] of settlementHere\n  ask settlementHere [ set stock 0 ] ; empty the settlement stock\n\nend\n\n...\n\nto update-settlements\n\n  ask settlements\n  [\n    let thisSettlement self\n\n    ; the sizeLevel of settlements decays with a constant rate, up to 1 (minimum)\n    set sizeLevel max (list 1 (sizeLevel * (1 - (settlementSizeDecayRate / 100)) ) )\n    ; production in stock also decays with a constant rate\n    set stock stock * (1 - (stockDecayRate / 100))\n    ; prodution is generated in proportion to sizeLevel, following a constant rate\n    set stock stock + sizeLevel * (productionRate / 100)\n\n    ; determine the current and potential number of traders\n    set currentNumberOfTraders get-current-number-of-traders\n    set potentialNumberOfTraders get-potential-number-of-traders\n\n    ; conditions favors the creation of new traders\n    if (random-float 1 &gt; currentNumberOfTraders / potentialNumberOfTraders )\n    [\n      ; create a new trader or activate an old one\n      repeat 1\n      [\n        ifelse (any? traders with [not isActivated])\n        [\n          ask one-of traders with [not isActivated]\n          [\n            setup-trader thisSettlement\n            move-to thisSettlement\n          ]\n        ]\n        [\n          hatch-traders 1\n          [\n            setup-trader thisSettlement\n          ]\n        ]\n      ]\n      set currentNumberOfTraders get-current-number-of-traders ; update currentNumberOfTraders\n    ]\n  ]\n\nend\nIn get-potential-number-of-traders, there is a hidden magic number worth exploring. We name it frequencyOverQualityand make it a “trait” of settlements, setting it in create-coastal-settlements as a random number between 0 and 1:\nsettlements-own\n[\n  ...\n\n  frequencyOverQuality\n]\n\n...\n\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 ; the size level is initiated at minimum (i.e., 1)\n        set stock 0\n        set frequencyOverQuality random-float 1\n        set shape \"circle 2\"\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\n\nto-report get-potential-number-of-traders ; ego = settlement\n\n  report (\n    1 +\n    (sizeLevel - 1) * frequencyOverQuality\n    )\n\nend\nAs its name tries to state, this trait’s meaning is: “how much the frequency of trade is prioritised over the quality of the cargo”. This is because the more traders a settlement has, the less cargo each will be able to get from stock, which will have less time to recover. Therefore, this trait represents an interesting aspect of how different settlements could organise trade.\nWe can now observe how the number of traders in our pond reaches an oscillating, stable low level most of the time. We can observe some exceptions by exploring higher values of numberOfSettlements. With enough settlements, our feedback loops push the dynamics towards the emergence of hubs, boosting the overall number of traders.\n\nPond Trade step 9\nWe reach the end of the implementation steps for the first-tier PondTrade model. Given all changes and extensions we made, we must go back to our conceptual model and update it accordingly.\n\nPond Trade conceptual model revised at step 9 (first tier)\nThis graphical description is still far from the implementation code, as it should be. However, it is now adequate for the new conceptual changes we introduced in code.",
    "crumbs": [
      "Pond Trade (II): agents and mechanisms",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Implementing mechanisms</span>"
    ]
  },
  {
    "objectID": "pond-trade-cultural-vectors.html",
    "href": "pond-trade-cultural-vectors.html",
    "title": "20  Implementing complex agents",
    "section": "",
    "text": "20.1 Second-tier model\nWe will now go over the implementation of the second-tier PondTrade model (steps 10 to 13). The pace in this section will be significantly faster. I ask you only to comprehend the main aspects added at each step and concern yourself only with the files already in the root directory.\nRemember the conceptual model for this tier, as we defined back at the beginning.\nPond Trade conceptual model at start (second tier)\nApart from assimilating the changes we made to the first-tier model, our goal here will be to implement the following:",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Implementing complex agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-cultural-vectors.html#second-tier-model",
    "href": "pond-trade-cultural-vectors.html#second-tier-model",
    "title": "20  Implementing complex agents",
    "section": "",
    "text": "a cultural “vector” of settlements, representing a series of cultural traits of the aggregated population of the settlements\n\na mechanism to modify these cultural vectors through the movement of trade goods, according to a global measure of what we call here “cultural permeability”\n\na mechanism that modifies cultural vectors randomly through time (undirected variation)",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Implementing complex agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-cultural-vectors.html#step-10-cultural-vectors",
    "href": "pond-trade-cultural-vectors.html#step-10-cultural-vectors",
    "title": "20  Implementing complex agents",
    "section": "20.2 Step 10: cultural vectors",
    "text": "20.2 Step 10: cultural vectors\nLet us start with implementing the settlements’ cultural vector (culturalVector). Since there is, for now, no meaning of traits, we can use this new variable to hold the values of the three numbers defining an RGB colour (i.e., red, green, blue; values between 0 and 255) that will then be shown as the icon colour of the settlement.\nsettlements-own\n[\n  ...\n  culturalVector\n]\n\n...\n\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 ; the size level is initiated at minimum (i.e., 1)\n        set stock 0\n        set frequencyOverQuality random-float 1\n        set culturalVector extract-rgb color\n        ; for now, we represent three continuos cultural traits of settlements\n        ; initialized as the rgb values of the settlement color.\n\n        set shape \"circle 2\"\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\n\nto update-display\n\n  paint-routes\n  paint-active-routes\n\n  ; scale the size of settlements according to their dynamic free-scaled sizeLevel\n  let maxSettlementSize max [sizeLevel] of settlements\n\n  ask settlements\n  [\n    set hidden? not showSettlements\n    set size 1 + (sizeLevel / maxSettlementSize) * 9\n    set color rgb (item 0 culturalVector) (item 1 culturalVector) (item 2 culturalVector)\n  ]\n\n  ask traders\n  [\n    ifelse (isActivated)\n    [ set hidden? false ]\n    [ set hidden? true ]\n  ]\n\nend\n\nPond Trade step 10 - settlement with cultural vector\nNext, we add a mechanism for traders to record the state of their base culturalVector while loading their cargo and pass this vector as an influence over another settlement’s culturalVector, when unloading. More specifically, this influence will decrease the difference between values in each trait to a measure dependent on the parameter traitTransmissionRate (slider, from 0 to 25, by 0.01, default value = 1).\ntraders-own\n[\n  ...\n\n  culturalSample\n]\n\n...\n\nto load-cargo ; ego = trader\n\n  let settlementHere one-of settlements-here\n\n  ; load cargo\n  set cargoValue [stock] of settlementHere\n  ask settlementHere [ set stock 0 ] ; empty the settlement stock\n\n  set culturalSample [culturalVector] of settlementHere\n\nend\n\n...\n\nto add-trade-effect [ aTrader ] ; ego = settlement\n\n  ; cultural transmission trader to port\n  let newCulturalVector []\n  foreach culturalVector\n  [ ?1 -&gt;\n    let otherSettlementTrait item (length newCulturalVector) [culturalSample] of aTrader\n    let traitChange (otherSettlementTrait - ?1) * (traitTransmissionRate / 100)\n    set newCulturalVector lput (?1 + traitChange) newCulturalVector\n  ]\n;  print (word \"========== \" self \" ============\")\n;  print (word \"old vector: \" culturalVector \", new vector: \" newCulturalVector)\n  set culturalVector newCulturalVector\n\n  set sizeLevel sizeLevel + [cargoValue] of aTrader\n\nend\nWith these changes, the model dynamics will now include a general cultural convergence whenever trade partners become stable, especially when trade hubs emerge. After a few thousand simulation steps, the visual result is that all settlements hold the same colour.\n\nPond Trade step 10\nAccording to our initial conceptual model, the next step is implementing a mechanism of undirected variation. We can easily include this as the addition of noise to the value of each trait on the pass of each time step. As with transmission, we could have it regulated by a global parameter of trait mutation rate. However, it may feel already that we have too many global parameters that we can easily conceive as varying widely among settlements. Thus, we move forward by breaking our plan and exploring the idea emerging during the implementation process, back when we defined frequencyOverQuality: what if most of the parameters about settlements were implemented instead as traits in culturalVector and allowed to evolve?",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Implementing complex agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-cultural-vectors.html#step-11-trait-selection",
    "href": "pond-trade-cultural-vectors.html#step-11-trait-selection",
    "title": "20  Implementing complex agents",
    "section": "20.3 Step 11: trait selection",
    "text": "20.3 Step 11: trait selection\nTo internalise most parameters as trait values in culturalVector, we must convert all former parameters into hyperparameters, i.e. those values that will be used only to set a range of variation of the settlement-specific values.\n\n\n\nbefore (step 10)\nafter (step 11)\n\n\n\n\nsettlementSizeDecayRate\nmaxSettlementSizeDecayRate\n\n\nstockDecayRate\nmaxStockDecayRate\n\n\nproductionRate\nmaxProductionRate\n\n\ntraitTransmissionRate\nmaxTraitTransmissionRate\n\n\n(traitMutationRate)\nmaxMutationVariation\n\n\n\nWe will also exploit the opportunity further and create two extra elements to which we will refer as land and port technology, which will allow us to modify how pathCost affects traders’ decisions and movements. For these, we need to introduce two extra hyperparameters landTechVariation and portTechVariation. Notice that we could do the same to the path cost in water, though it would affect the rhythm of the model more drastically.\nWe change the code for initialising settlements so that each trait within culturalVector is sampled randomly according to the hyperparameters above:\nto create-coastal-settlements\n\n  ; consider only coastal patches\n  let coastalPatches patches with [(isLand = true) and (any? neighbors with [isLand = false])]\n\n  repeat numberOfSettlements\n  [\n    ; ask a random coastal patch without a settlement already\n    ask one-of coastalPatches with [not any? settlements-here]\n    [\n      sprout-settlements 1 ; creates one \"turtle\" of breed settlements\n      [\n        set sizeLevel 1 ; the size level is initiated at minimum (i.e., 1)\n        set stock 0\n\n        set culturalVector extract-rgb color ; 0#, 1# and 2#\n        ; We add seven continuos cultural traits to the neutral RGB traits,\n        ; representing their attitude and ability involving\n        ; aspects we previously fixed as parameters and one variable:\n        ; 3# relativePathCostInLand (normal distribution around global parameter)\n        set culturalVector lput (random-normal 0 landTechVariation) culturalVector\n        ; 4# relativePathCostInPort (normal distribution around global parameter)\n        set culturalVector lput (random-normal 0 portTechVariation) culturalVector\n        ; 5# settlementSizeDecayRate [0 - maxSettlementSizeDecayRate)\n        set culturalVector lput (random-float maxSettlementSizeDecayRate) culturalVector\n        ; 6# stockDecayRate [0 - maxStockDecayRate)\n        set culturalVector lput (random-float maxStockDecayRate) culturalVector\n        ; 7# produtionRate [0 - maxProductionRate)\n        set culturalVector lput (random-float maxProductionRate) culturalVector\n        ; 8# frequencyOverQuality [0 - 1)\n        set culturalVector lput (random-float 1) culturalVector\n        ; 9# traitTransmissionRate [0 - maxTraitTransmissionRate) *** now, it means specifically the 'openess' of a settlement towards other variants of a trait\n        set culturalVector lput (random-float maxTraitTransmissionRate) culturalVector\n        ; 10# mutationVariation [0 - maxMutationVariation)\n        set culturalVector lput (random-float maxMutationVariation) culturalVector\n\n        set shape \"circle 2\"\n      ]\n      ; replace the land path cost with the port pathCost\n      set pathCost relativePathCostInPort\n      ; exclude this patch from the pool of coastal patches\n      set coastalPatches other coastalPatches\n    ]\n  ]\n\nend\nAnd then replace the former parameters with the corresponding indexed values in culturalVector:\n\nto update-settlements\n\n  ask settlements\n  [\n    let thisSettlement self\n\n    ; the sizeLevel of settlements decays with a constant rate, up to 1 (minimum)\n    set sizeLevel max (list 1 (sizeLevel * (1 - ((item 5 culturalVector) / 100)) ) )\n    ; production in stock also decays with a constant rate\n    set stock stock * (1 - ((item 6 culturalVector) / 100))\n    ; prodution is generated in proportion to sizeLevel, following a constant rate\n    set stock stock + sizeLevel * ((item 7 culturalVector) / 100)\n\n    ; determine the current and potential number of traders\n    set currentNumberOfTraders get-current-number-of-traders\n    set potentialNumberOfTraders get-potential-number-of-traders\n\n    ; conditions favors the creation of new traders\n    if (random-float 1 &gt; currentNumberOfTraders / potentialNumberOfTraders )\n    [\n      ; create a new trader or activate an old one\n      repeat 1\n      [\n        ifelse (any? traders with [not isActivated])\n        [\n          ask one-of traders with [not isActivated]\n          [\n            setup-trader thisSettlement\n            move-to thisSettlement\n          ]\n        ]\n        [\n          hatch-traders 1\n          [\n            setup-trader thisSettlement\n          ]\n        ]\n      ]\n      set currentNumberOfTraders get-current-number-of-traders ; update currentNumberOfTraders\n    ]\n\n    ; add variation to the settlement traits (mutation)\n    mutate-traits\n  ]\n\nend\n\n...\n\nto add-trade-effect [ aTrader ] ; ego = settlement\n\n  ; cultural transmission trader to port\n  let newCulturalVector []\n  foreach culturalVector\n  [ ?1 -&gt;\n    let otherSettlementTrait item (length newCulturalVector) [culturalSample] of aTrader\n    let traitChange (otherSettlementTrait - ?1) * ((item 9 culturalVector) / 100)\n    set newCulturalVector lput (?1 + traitChange) newCulturalVector\n  ]\n;  print (word \"========== \" self \" ============\")\n;  print (word \"old vector: \" culturalVector \", new vector: \" newCulturalVector)\n  set culturalVector newCulturalVector\n\n  set sizeLevel sizeLevel + [cargoValue] of aTrader\n\nend\n\n...\n\n\nto-report get-potential-number-of-traders ; ego = settlement\n\n  report (\n    1 +\n    (sizeLevel - 1) * (item 8 culturalVector)\n    )\n\nend\n\n...\n\nto-report get-path-cost [ aPatch aTrader ]\n\n  let pathCostOfPatch [pathCost] of aPatch\n  if ([isLand] of aPatch)\n  [\n    ifelse ([any? settlements-here] of aPatch)\n    [\n      ; path cost in port apply\n      set pathCostOfPatch pathCostOfPatch + [(item 4 culturalVector)] of [base] of aTrader\n    ]\n    [\n      ; path cost in land apply\n      set pathCostOfPatch pathCostOfPatch + [(item 3 culturalVector)] of [base] of aTrader\n    ]\n  ]\n  report pathCostOfPatch\n\nend\nFinally, we add a new procedure that apply random (normally-distributed) mutations to all traits separately:\n\nto mutate-traits\n\n  let mutationVariationToApply (item 10 culturalVector) / 100\n  ;print \"========================================\"\n  ;print culturalVector\n  ; #1, #2 and #3\n  set culturalVector replace-item 0 culturalVector mutate-trait (item 0 culturalVector) 0 255 mutationVariationToApply\n  set culturalVector replace-item 1 culturalVector mutate-trait (item 1 culturalVector) 0 255 mutationVariationToApply\n  set culturalVector replace-item 2 culturalVector mutate-trait (item 2 culturalVector) 0 255 mutationVariationToApply\n\n  ; #3 and #4 (relativePathCostInLand, relativePathCostInPort)\n  set culturalVector replace-item 3 culturalVector mutate-trait (item 3 culturalVector) (-1 * relativePathCostInLand + 1) 100 mutationVariationToApply ; arbitrary maximum\n  set culturalVector replace-item 4 culturalVector mutate-trait (item 4 culturalVector) (-1 * relativePathCostInPort + 1) 100 mutationVariationToApply ; arbitrary maximum\n\n  ; #5, #6 and #6 (settlementSizeDecayRate, stockDecayRate, produtionRate)\n  set culturalVector replace-item 5 culturalVector mutate-trait (item 5 culturalVector) 0 maxSettlementSizeDecayRate mutationVariationToApply\n  set culturalVector replace-item 6 culturalVector mutate-trait (item 6 culturalVector) 0 maxStockDecayRate mutationVariationToApply\n  set culturalVector replace-item 7 culturalVector mutate-trait (item 7 culturalVector) 0 maxProductionRate mutationVariationToApply\n\n  ; #8, #9 and #10 (frequencyOverQuality, traitTransmissionRate, mutationVariation)\n  set culturalVector replace-item 8 culturalVector mutate-trait (item 8 culturalVector) 0 1 mutationVariationToApply\n  set culturalVector replace-item 9 culturalVector mutate-trait (item 9 culturalVector) 0 maxTraitTransmissionRate mutationVariationToApply\n  set culturalVector replace-item 10 culturalVector mutate-trait (item 10 culturalVector) 0 maxMutationVariation mutationVariationToApply\n\n  ;print culturalVector\n\nend\n\nto-report mutate-trait [ traitValue minValue maxValue mutationVar ]\n\n  report (max (list minValue min (list maxValue (traitValue + (random-normal 0 mutationVar) * (maxValue - minValue)))))\n\nend\nTo better visualise the distribution of traits along with the simulation, we add four new Plots to our interface. These are histograms of the values of each trait and settlement, giving us a sense of both convergence or cultural integration and possibly revealing any evolutionary trends caused by trait selection. For instance, we would expect high selective pressure for settlements with a higher production rate since it is part of the positive feedback loops we implemented earlier in the first tier.\n\nPond Trade step 11\nAt this stage, we also had to introduce stop conditions to interrupt simulation runs, especially given the potential number of traders under some parameter configurations. The conditions are added to the go procedure:\nto go\n\n  tick\n\n  if (ticks = 10000 or count turtles &gt; 500) [ stop ]\n\n  update-traders\n\n  update-settlements\n\n  update-display\n\nend",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Implementing complex agents</span>"
    ]
  },
  {
    "objectID": "pond-trade-stats.html",
    "href": "pond-trade-stats.html",
    "title": "21  Implementing output statistics",
    "section": "",
    "text": "Apart from minor refactoring, the last implementation steps involve displaying (step 12) and recording (step 13) output statistics. These are essentially aggregate measurements about the state of the simulation at a given time step.\n\nPond Trade step 12\n\nPond Trade step 13\nThe statistics serve as indicators for monitoring complex results while manually running simulations in the interface. Most importantly, they can be used more systematically as data that can be exported for further use in other software, e.g., to perform advanced statistical analyses and more sophisticated graphs.\nHere is how step 13 implements those statistics:\nglobals\n[\n  routes\n\n  ;;; Output\n  patchesCount\n  coastalLandPatchesCount\n\n  traderCount\n\n  meanTraderCargoValue\n  minTraderCargoValue\n  maxTraderCargoValue\n\n  minSettlementSize\n  maxSettlementSize\n  mainHub\n\n  meanTotalPathCostOfActiveRoutes\n  minTotalPathCostOfActiveRoutes\n  maxTotalPathCostOfActiveRoutes\n\n  meanRedTrait stdDevRedTrait modesRedTrait\n  meanGreenTrait stdDevGreenTrait modesGreenTrait\n  meanBlueTrait stdDevBlueTrait modesBlueTrait\n\n  meanLandTechTrait stdDevLandTechTrait modesLandTechTrait\n  meanPortTechTrait stdDevPortTechTrait modesPortTechTrait\n\n  meanSizeDecayTrait stdDevSizeDecayTrait modesSizeDecayTrait\n  meanStockDecayTrait stdDevStockDecayTrait modesStockDecayTrait\n  meanProductionTrait stdDevProductionTrait modesProductionTrait\n\n  meanFreqOverQualTrait stdDevFreqOverQualTrait modesFreqOverQualTrait\n  meanTransmissionTrait stdDevTransmissionTrait modesTransmissionTrait\n  meanMutationTrait stdDevMutationTrait modesMutationTrait\n]\n\n...\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; OUTPUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\nto update-output\n\n  set coastalLandPatchesCount count patches with [isLand = true and any? neighbors with [isLand = false]]\n\n  let activatedTraders traders with [isActivated]\n\n  set traderCount count activatedTraders\n\n  set meanTraderCargoValue mean [cargoValue] of activatedTraders\n  set minTraderCargoValue min [cargoValue] of activatedTraders\n  set maxTraderCargoValue max [cargoValue] of activatedTraders\n\n  set minSettlementSize min [sizeLevel] of settlements\n  set maxSettlementSize max [sizeLevel] of settlements\n  set mainHub max-one-of settlements [sizeLevel]\n\n  set meanTotalPathCostOfActiveRoutes mean [sum (map [ ?1 -&gt; [pathCost] of ?1 ] route)] of activatedTraders\n  set minTotalPathCostOfActiveRoutes min [sum (map [ ?1 -&gt; [pathCost] of ?1 ] route)] of activatedTraders\n  set maxTotalPathCostOfActiveRoutes max [sum (map [ ?1 -&gt; [pathCost] of ?1 ] route)] of activatedTraders\n\n  set meanRedTrait mean [item 0 culturalVector] of settlements\n  set stdDevRedTrait standard-deviation [item 0 culturalVector] of settlements\n  set modesRedTrait modes [ round (item 0 culturalVector) ] of settlements\n  set meanGreenTrait mean [item 1 culturalVector] of settlements\n  set stdDevGreenTrait standard-deviation [item 1 culturalVector] of settlements\n  set modesGreenTrait modes [ round (item 1 culturalVector) ] of settlements\n  set meanBlueTrait mean [item 2 culturalVector] of settlements\n  set stdDevBlueTrait standard-deviation [item 2 culturalVector] of settlements\n  set modesBlueTrait modes [ round (item 2 culturalVector) ] of settlements\n\n  set meanLandTechTrait mean [item 3 culturalVector] of settlements\n  set stdDevLandTechTrait standard-deviation [item 3 culturalVector] of settlements\n  set modesLandTechTrait modes [ round (relativePathCostInLand + item 3 culturalVector) ] of settlements\n  set meanPortTechTrait mean [item 4 culturalVector] of settlements\n  set stdDevPortTechTrait standard-deviation [item 4 culturalVector] of settlements\n  set modesPortTechTrait modes [ round (relativePathCostInPort + item 4 culturalVector) ] of settlements\n\n  set meanSizeDecayTrait mean [item 5 culturalVector] of settlements\n  set stdDevSizeDecayTrait standard-deviation [item 5 culturalVector] of settlements\n  set modesSizeDecayTrait modes [ round (item 5 culturalVector) ] of settlements\n  set meanStockDecayTrait mean [item 6 culturalVector] of settlements\n  set stdDevStockDecayTrait standard-deviation [item 6 culturalVector] of settlements\n  set modesStockDecayTrait modes [ round (item 6 culturalVector) ] of settlements\n  set meanProductionTrait mean [item 7 culturalVector] of settlements\n  set stdDevProductionTrait standard-deviation [item 7 culturalVector] of settlements\n  set modesProductionTrait modes [ round (item 7 culturalVector) ] of settlements\n\n  set meanFreqOverQualTrait mean [item 8 culturalVector] of settlements\n  set stdDevFreqOverQualTrait standard-deviation [item 8 culturalVector] of settlements\n  set modesFreqOverQualTrait modes [ round (item 8 culturalVector) ] of settlements\n  set meanTransmissionTrait mean [item 9 culturalVector] of settlements\n  set stdDevTransmissionTrait standard-deviation [item 9 culturalVector] of settlements\n  set modesTransmissionTrait modes [ round (item 9 culturalVector) ] of settlements\n  set meanMutationTrait mean [item 10 culturalVector] of settlements\n  set stdDevMutationTrait standard-deviation [item 10 culturalVector] of settlements\n  set modesMutationTrait modes [ round (item 10 culturalVector) ] of settlements\n\nend\n\nWe could further implement a procedure to export these and more variables at a specific time of simulations. We will see an example of this in Block C. However, in most cases, we want to use NetLogo Behavioral Space. Find it in Tools &gt; Behavior Space. This built-in tool allows you to configure experiments to be run in parallel, within a specific parameter space, and perform a series of commands before, during, or after a simulation run. It includes functionality for exporting simulation data as a CSV file (you will be prompt with a File Explorer window once you press “run” in an experiment).\nAs the final step in developing PondTrade, let us update our second-tier conceptual model, adding a more explicit representation of cultural vectors and their contents.\n\nPond Trade conceptual model at step 13 (second tier)",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Implementing output statistics</span>"
    ]
  },
  {
    "objectID": "pond-trade-modularity.html",
    "href": "pond-trade-modularity.html",
    "title": "22  Identifying and formatting submodels",
    "section": "",
    "text": "22.1 🔹 Why Modularise?\nIn the early stages of model development, it is common to work within a single .nlogo file. This approach keeps all code—setup, agent logic, data collection, and plotting—in one place, which is convenient for learning and experimentation. However, as models grow in complexity, maintaining a long monolithic file becomes difficult. To make large projects easier to navigate, debug, and extend, NetLogo allows modularisation through the __includes directive.\nBreaking a model into smaller source files improves:\nThese have great consequences for supporting transparent and replicable research. Instead of one opaque model file, a modular structure makes explicit where, for example, environmental data, agent rules, or calibration routines are defined—facilitating peer review, teaching, and long-term model reuse.",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Identifying and formatting submodels</span>"
    ]
  },
  {
    "objectID": "pond-trade-modularity.html#why-modularise",
    "href": "pond-trade-modularity.html#why-modularise",
    "title": "22  Identifying and formatting submodels",
    "section": "",
    "text": "Readability: Each file focuses on a specific function (e.g., setup, environment, agent behaviour, data collection).\nReusability: Procedures can be shared across projects.\nMaintenance: Updating or replacing a subsystem (e.g., weather generation) doesn’t require scrolling through hundreds of lines.\nCollaboration: Multiple researchers can work on separate components concurrently.",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Identifying and formatting submodels</span>"
    ]
  },
  {
    "objectID": "pond-trade-modularity.html#the-__includes-directive",
    "href": "pond-trade-modularity.html#the-__includes-directive",
    "title": "22  Identifying and formatting submodels",
    "section": "22.2 🔹 The __includes Directive",
    "text": "22.2 🔹 The __includes Directive\nNetLogo allows a model to load additional source files (.nls, for NetLogo Source) at runtime. The syntax, placed at the top of your main .nlogo file, is:\n__includes [\n  \"modules/setup.nls\"\n  \"modules/agents.nls\"\n  \"modules/environment.nls\"\n  \"modules/data_collection.nls\"\n]\n\nNOTE: Storing these files in a subdirectory, like ‘modules’, is not a requirement, but it will be preferable if the model directory contains anything besides a single .nlogo file (e.g., input or output data files, documentation, etc).\n\nEach included file may contain any NetLogo code (procedures, reporters, variable declarations). They could even correspond to a single element each (e.g., “setup.nls” containing only the setup procedure). The criteria for splitting those elements and naming the files is ultimately for you to decide. You should aim to have not too much nor too little code in files, but this is no golden rule and there are many instances where grouping or separating elements is more desirable. Using a combination of function (e.g., “setup”, “data collection”), object (e.g., “patches”, a given breed of agent) and topic (e.g., vegetation growth, movement, communication) can make good intermediate solutions. Remember the reasons for going modular and think in terms of what helps you pursuing them.\nWhen the model (.nlogo file) loads, all included .nls files are merged into a single shared namespace, so procedures defined in one file are visible to all others. You may also consult and modify the source code directly in NetLogo since, once loaded, they will appear in the drop down list at the top of the “Code” tab.",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Identifying and formatting submodels</span>"
    ]
  },
  {
    "objectID": "pond-trade-modularity.html#breaking-down-the-pond-trade-model",
    "href": "pond-trade-modularity.html#breaking-down-the-pond-trade-model",
    "title": "22  Identifying and formatting submodels",
    "section": "22.3 Breaking Down The Pond Trade Model",
    "text": "22.3 Breaking Down The Pond Trade Model\nTo break down the Pond Trade model developed within one .nlogo file, we can refactor it into modules stored in a structured directory, for example:\nPondTrade/\n├── PondTrade.nlogo              ; main file (interface + globals + includes)\n└── modules/\n    ├── main.nls                 ; stricly, setup and go procedures\n    ├── map.nls                  ; Map and terrain generation\n    ├── output.nls               ; Plotting, displays, outputs, and computing model statistics\n    ├── routes.nls               ; Route calculation, pathfinding, and connectivity logic.\n    ├── settlements.nls          ; Creating and managing settlements\n    └── traders.nls              ; trader creation, activation, movement, and trading logic\nInside the main model:\n__includes [\n  \"modules/PondTrade/main.nls\"\n  \"modules/PondTrade/map.nls\"\n  \"modules/PondTrade/settlements.nls\"\n  \"modules/PondTrade/routes.nls\"\n  \"modules/PondTrade/traders.nls\"\n  \"modules/PondTrade/output.nls\"\n]\nEach .nls file then contains code that is more closely related, even though they are inevitably connect to others. For example, map.nls stores create-map and smooth-coast-line, but while smooth-coast-line is only called by create-map, create-map in turn is called by setup.\nThis structure makes it easier to focus on specific model components, understand or modify them, without being overwhelmed by the entire codebase.\n\n22.3.1 🔹 Shared Utilities\nAll included files share the same namespace. Therefore, utility functions—such as clamp01 or random-between—can be stored in a shared file (e.g., root/utils/clamp.nls) and referenced in the main __includes list:\n__includes [\n  \"../utils/clamp.nls\"\n  \"modules/setup.nls\"\n  \"modules/trade.nls\"\n  \"modules/data.nls\"\n]\nThese utilities will then be available to all modules, even though .nls files cannot themselves include other .nls files.",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Identifying and formatting submodels</span>"
    ]
  },
  {
    "objectID": "pond-trade-modularity.html#refactoring-for-a-better-modularity",
    "href": "pond-trade-modularity.html#refactoring-for-a-better-modularity",
    "title": "22  Identifying and formatting submodels",
    "section": "22.4 ⚒️ Refactoring for a better modularity",
    "text": "22.4 ⚒️ Refactoring for a better modularity\nOnce we split our code into logical parts, we might already gain some useful insights about how to better respect modularity without changing the code behaviour. We have one such a case in map.nls. Here is the call paths involving the two procedures in this file:\n\n\n\n\n\n\nWe can see that assign-path-cost has a somewhat ambiguous position: it is clearly related to route calculation, but it is actually called in map, inside create-map, not in another procedure in routes or directly in setup.\nto create-map\n\n  ...\n  \n  smooth-coast-line\n\n  assign-path-cost\n\n  ask patches [ paint-terrain ]\n\nend\nThis makes our code a “spaghetti code”. The refactoring measure that can solve this is straightforward: we move the call for assign-path-cost from create-map to setup. Since it was already positioned at the end of create-map, moving it immediately following the call for create-map in setup will not change the model behaviour. The cost is simply a slightly longer setup procedure.\nto setup\n\n  clear-all\n  reset-ticks\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n  \n  set patchesCount count patches\n\n  create-map\n  \n  assign-path-cost\n\n  create-coastal-settlements\n\n  set-routes\n\n  create-traders-per-settlement\n\n  update-output\n\n  update-display\n\n  update-plots\n\nend\nRefactoring is a process that never finishes. Do you see any other improvements to our implementation of the model so far? If so, please try them and if successful, create a pull request with your changes to our course-guide repository.",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Identifying and formatting submodels</span>"
    ]
  },
  {
    "objectID": "pond-trade-modularity.html#alternative-organisation-options",
    "href": "pond-trade-modularity.html#alternative-organisation-options",
    "title": "22  Identifying and formatting submodels",
    "section": "22.5 🔹 Alternative Organisation Options",
    "text": "22.5 🔹 Alternative Organisation Options\nWhile __includes is the standard and simplest way to modularise code within NetLogo, larger or data-intensive projects can also benefit from:\n\nExtensions: Custom primitives written in Java or Scala for reusable functionality across models.\nExternal scripting: Coordinating model runs from R (via RNetLogo) or Python (via pyNetLogo), keeping analysis and simulation control outside NetLogo.\nVersioned templates: Using Git and folders (e.g., /modules/, /data/, /docs/) for collaborative development and reproducibility.",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Identifying and formatting submodels</span>"
    ]
  },
  {
    "objectID": "pond-trade-modularity.html#activity-refactor-the-artificial-anasazi-model-using-__includes",
    "href": "pond-trade-modularity.html#activity-refactor-the-artificial-anasazi-model-using-__includes",
    "title": "22  Identifying and formatting submodels",
    "section": "22.6 🧠 Activity: Refactor the Artificial Anasazi Model Using __includes",
    "text": "22.6 🧠 Activity: Refactor the Artificial Anasazi Model Using __includes\n\n22.6.1 🎯 Learning Objective\nBy the end of this exercise, students will:\n\nUnderstand how to break a NetLogo model into functional modules.\nLearn how to organise model code for clarity, maintenance, and reuse.\nRecognise how modularisation supports reproducible archaeological modelling.\n\n\n\n\n22.6.2 🪣 Background\nYou have been working with the PondTrade model as a single .nlogo file containing setup, agent behaviour, environment rules, and data collection. In this activity, you will restructure it into a modular design using NetLogo’s __includes feature.\n\n\n\n22.6.3 🧩 Step 1 — Create the Folder Structure\n\nMake a new directory called PondTrade_Modular/.\nInside it, create the following subfolders:\nPondTrade_Modular/\n├── PondTrade.nlogo\n└── modules/\n    ├── setup.nls\n    ├── turtles.nls\n    ├── environment.nls\n    ├── trade.nls\n    ├── data.nls\n    └── utils.nls\nCopy your original model interface (sliders, plots, switches) into PondTrade.nlogo.\n\n\n\n\n22.6.4 ⚙️ Step 2 — Add the __includes Statement\nAt the very top of PondTrade.nlogo, add:\n__includes [\n  \"modules/setup.nls\"\n  \"modules/turtles.nls\"\n  \"modules/environment.nls\"\n  \"modules/trade.nls\"\n  \"modules/data.nls\"\n  \"modules/utils.nls\"\n]\nThis tells NetLogo to merge all these modules into one program when the model is loaded.\n\n\n\n22.6.5 ✂️ Step 3 — Split the Code\nNow open your original single-file model and move procedures into the appropriate module files.\n\n\n\n\n\n\n\n\nType of Procedure\nMove it to file\nExample\n\n\n\n\nWorld setup and initialization\nsetup.nls\nto setup, to create-turtles\n\n\nAgent behaviour (movement, decisions)\nturtles.nls\nto go, to forage, to trade\n\n\nEnvironment updates\nenvironment.nls\nto update-water, to grow-resources\n\n\nTrade and interaction logic\ntrade.nls\nto exchange-goods, to evaluate-partner\n\n\nData collection and plotting\ndata.nls\nto record-stats, to export-csv\n\n\nHelper and math functions\nutils.nls\nto-report clamp01 [x], to-report random-between [a b]\n\n\n\nRemember — you do not need to re-declare globals or interface variables in every file. All modules share the same namespace once included.\n\n\n\n22.6.6 🧪 Step 4 — Test the Modular Model\n\nOpen PondTrade.nlogo in NetLogo.\nCheck that it runs exactly like the original version.\nIf an error appears such as “Nothing named CLAMP01”, ensure that the file containing that procedure (utils.nls) is listed in the __includes.\n\n\n\n\n22.6.7 💬 Step 5 — Reflect and Discuss\nConsider these questions:\n\nHow does splitting the model help you identify its components conceptually (e.g. agents, environment, data)?\nWhich part of the model would you expect to change most often during an archaeological experiment?\nHow does modular organisation support collaboration between researchers (e.g. environmental scientist, archaeologist, and programmer)?\nHow might this approach make the model easier to archive, cite, or share for reproducibility?\n\n\n\n\n22.6.8 📚 Optional Extension\nExplore alternative code organisation options:\n\nCreate a reusable utils folder shared by multiple models.\nCall NetLogo models externally from R or Python using RNetLogo or pyNetLogo for automated experiments.\nPackage frequently used model components as NetLogo extensions (Java/Scala).\n\n\n\n\n22.6.9 🏺 Summary\nBy modularising your model, you have:\n\nImproved readability and traceability of the code.\nCreated a structure that supports collaboration and replication.\nTaken an important step toward professional-level model documentation in computational archaeology.",
    "crumbs": [
      "Pond Trade (III): advanced mechanisms, output stats and modularity",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Identifying and formatting submodels</span>"
    ]
  },
  {
    "objectID": "messara-concept.html",
    "href": "messara-concept.html",
    "title": "23  Case study and conceptual model",
    "section": "",
    "text": "23.1 Evidence and case study\nHaving a generic conceptual model that covers the definition of a phenomenon and mechanism, we proceed to select a case study that offers both a real-world context and archaeological data to which we can adapt the Pond Trade model.\nSince Paliou and Bevan (2016) also tackles research questions on settlement patterns and interactions, the study offers us an opportunity to compare ABM with other approaches, such as the gravity spatial interaction models referenced in the original study. Hopefully, you will gain an intuitive perception of the advantages and caveats of ABM in front of more analytical or data-driven approaches.\nWith site distributions and artefactual classifications, archaeology offers an opportunity for us to estimate aspects such as population density and economic and cultural interactions. However, to relate the socio-ecological past to the material evidence in the present, we must inevitably use an explanatory model. There are many published models relevant to this topic, several already mentioned by Paliou and Bevan (2016). However, few are formalised to some extent, and fewer are available as reusable implementations. Luckily, some of these are ABM models (see ABM in archaeology and References).\nOur objective adapting the Pond Trade model to this case study is to delve deeper into the expectations of our current knowledge about the growth of settlements and the formation of local polities in this crucial period, preluding the Minoan palatial institution. As in the original paper, we will need to assume a series of conditions and behaviour rules, considered valid for this context, given historical and anthropological parallels. However, in an agent-based model, such assumptions can be made more explicit as part of the model and, thus, testable as an explanation.\nAs mentioned, ABM is particularly hungry for specifications, many of which are not even dreamed of by the average archaeologist. In this tutorial, we will try to maintain an intermediate level of model abstraction, avoiding many details that would normally be included in the ABM-SES approach in archaeology.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Case study and conceptual model</span>"
    ]
  },
  {
    "objectID": "messara-concept.html#evidence-and-case-study",
    "href": "messara-concept.html#evidence-and-case-study",
    "title": "23  Case study and conceptual model",
    "section": "",
    "text": "Note\n\n\n\n\nPaliou, Eleftheria, and Andrew Bevan. 2016. ‘Evolving Settlement Patterns, Spatial Interaction and the Socio-Political Organisation of Late Prepalatial South-Central Crete’. Journal of Anthropological Archaeology 42 (June): 184–97. https://doi.org/10.1016/j.jaa.2016.04.006.\n\nSummary (by Google NotebookLM)\nThis research article investigates socio-political organization in south-central Crete during the late Prepalatial period (ca. 2300–1850 BC), a period before the well-documented Minoan palaces. Employing spatial interaction models and regression-based predictive modeling, the authors analyze settlement patterns and artefact distributions (specifically Minoan seals) to identify potential local power centers. The study addresses the challenges of incomplete archaeological data by incorporating simulated settlement locations, improving the accuracy of the analysis. The findings suggest the existence of three to four local power centers, rather than a single dominant center, during the late Prepalatial period, with a shift towards a single dominant center at Phaistos in the subsequent Protopalatial period. The study highlights the combined use of computational modeling and material culture evidence to understand past socio-political dynamics.\nTakeaways for our conceptual model\n\nCase study: settlement interaction and the emergence of hierarchical settlement structures in Prepalatial south-central Crete\nPhenomena to represent: cycles of growth and collapse (i.e., fluctuations in the scale of site occupation). Focus on site interconnectivity and its relationship with settlement size.\nMain assumption: topography, transport technology, exchange network, settlement size, wealth, and cultural diversity are intertwined in a positive feedback loop (i.e. big gets bigger or busy gets busier).\nDynamics we expect and want to explore: the long-term consolidation of central sites and larger territorial polities.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Case study and conceptual model</span>"
    ]
  },
  {
    "objectID": "messara-concept.html#extending-the-pond-trade-model",
    "href": "messara-concept.html#extending-the-pond-trade-model",
    "title": "23  Case study and conceptual model",
    "section": "23.2 Extending the Pond Trade model",
    "text": "23.2 Extending the Pond Trade model\nWe advance with a minor revision to our previous conceptual model:\n\nPond Trade conceptual model at step 14 (second tier)\nIn addition to the core mechanism, we must consider another aspect to better approach our case study.\nThe Pond Trade model has several caveats. Like any other model, it is incomplete and greatly simplifies those aspects of reality that we chose not to prioritise. One of the most significant simplifications is that each settlement’s production is only dependent on a general term of productivity, independent of the land accessible to its inhabitants.\nThis limitation is not a significant problem if we are dealing with a straightforward terrain, like in the original Pond Trade where we only differentiate between land and water. However, we eventually aim to apply the model to a specific region and use the available geographical and archaeological data. Therefore, we lay out a potential expansion of the original Pond Trade, which will enable us to factor in the diversity regarding the land productivity around settlements.\nMechanisms:\n\n↑ settlement size → ↑ settlement territory\n\n↑ settlement territory → ↑ production (of land)\n\n↑ productivity (of land) → production (of land)\n\n↑ production (of land) → ↑ production (of settlement)\n\n\nExpanded Pond Trade conceptual model at start\nNotice that, with this expansion, we are again introducing a positive feedback loop or splitting the one that already involves production. This time, however, instead of relying on a global parameter, we are regulating the process through a location-specific value (i.e., productivity of land).\nExpected dynamics: production is ‘grounded’, i.e., dependent on each settlement catchment area size and productivity",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Case study and conceptual model</span>"
    ]
  },
  {
    "objectID": "messara-concept.html#towards-model-implementation",
    "href": "messara-concept.html#towards-model-implementation",
    "title": "23  Case study and conceptual model",
    "section": "23.3 Towards model implementation",
    "text": "23.3 Towards model implementation\nTo build the Messara Trade model, we will take several advanced steps. Through a sequence of module development, we will reach a final version that extends the Pond Trade model to a ‘grounded’ production process and contextual data that refers specifically to our case study.\n\n\n\n\nPaliou, Eleftheria, and Andrew Bevan. 2016. “Evolving Settlement Patterns, Spatial Interaction and the Socio-Political Organisation of Late Prepalatial South-Central Crete.” Journal of Anthropological Archaeology 42 (June): 184–97. https://doi.org/10.1016/j.jaa.2016.04.006.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Case study and conceptual model</span>"
    ]
  },
  {
    "objectID": "messara-gis.html",
    "href": "messara-gis.html",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "",
    "text": "24.1 The gisextension\nThe NetLogo default installation includes an extension to support GIS that can be used by adding the following to the first section of your script:\nThis extension allows you to perform a variety of GIS operations and to connect patch and turtle behaviour to data expressed in GIS files, supporting both vector and raster. The description of its contents can be found here: https://ccl.northwestern.edu/netlogo/docs/gis.html\nWe will only reference a few aspects of GIS in NetLogo. You will find useful examples in NetLogo’s Models Library (e.g., Sample Models &gt; Code Examples &gt; Extensions Examples &gt; gis &gt; GIS General Examples).",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#the-gisextension",
    "href": "messara-gis.html#the-gisextension",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "",
    "text": "extensions [ gis ]",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#loading-gis-data",
    "href": "messara-gis.html#loading-gis-data",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "24.2 Loading GIS data",
    "text": "24.2 Loading GIS data\nWe start by loading all GIS data into separate NetLogo variables. To know about the formats this extension accepts, see here: https://ccl.northwestern.edu/netlogo/docs/gis.html#gis:load-dataset.\nglobals\n[\n  ;;; GIS data holders\n  sitesData_EMIII-MMIA\n  sitesData_MMIB\n  elevationData\n  riversData\n]\n\n...\n\nto load-gis\n\n  ; Load all of our datasets\n  set sitesData_EMIII-MMIA gis:load-dataset \"data/Cretedata/EMIII_MMIAsites.shp\"\n  set sitesData_MMIB gis:load-dataset \"data/Cretedata/MMIBsites.shp\"\n\n  set elevationData gis:load-dataset \"data/Cretedata/dem15.asc\"\n  set riversData gis:load-dataset \"data/Cretedata/rivers.shp\"\n\n  ; Set the world envelope to the union of all of our dataset's envelopes\n  gis:set-world-envelope (gis:envelope-of elevationData)\n\nend\nThe files in “data/Cretedata/” were distributed during our in-person session, courtesy of Dr Eleftheria Paliou (University of Cologne). Site coordinates were randomly shifted in QGIS to be published online after the session.\nWe are using:\n\nTwo shape files containing point coordinates of various archaeological sites in the region, corresponding to two aggregated periods (see Minoan Chronology):\n\nEMIII_MMIAsites.shp: sites dating from the Prepalatial Period, specifically the Early Minoan III (EMIII) and Middle Minoan IA (MMIA) Periods\nMMIBsites.shp: sites dating from the Protopalatial Period, specifically the Middle Minoan IB (MMIB) Period\n\nA DEM raster file: dem15.asc (elevation of the terrain with a 15m resolution)\nA third shape file, rivers.shp, contains line data with the rivers within the region.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#readjusting-world-settings",
    "href": "messara-gis.html#readjusting-world-settings",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "24.3 Readjusting world settings",
    "text": "24.3 Readjusting world settings\nThe second step is ensuring that our world and world view in NetLogo fits the data we want to feed into them. In this case, we need to reduce the DEM resolution to handle all patch processes in a reasonable computation time.\nglobals\n[\n  width\n  height\n\n  ;;; GIS data holders\n  sitesData_EMIII-MMIA\n  sitesData_MMIB\n  elevationData\n  riversData\n]\n\nto set-world-dimensions\n\n  ;;; for better performance, we take a multiple fraction of the dimensions of elevationData,\n  ;;; so that patches will get average values or more regular sets of pixels\n\n  let patchXpixelScale 0.1 ;;; keep it less than 0.25\n  let pixelExtentMargin 50\n\n  set width ceiling ((pixelExtentMargin + gis:width-of elevationData) * patchXpixelScale)\n  set height ceiling ((pixelExtentMargin + gis:height-of elevationData) * patchXpixelScale)\n\n  resize-world 0 width 0 height\n\n  set-patch-size 3\n\nend",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#calculating-patch-dimensions-based-on-gis",
    "href": "messara-gis.html#calculating-patch-dimensions-based-on-gis",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "24.4 Calculating patch dimensions based on GIS",
    "text": "24.4 Calculating patch dimensions based on GIS\nBefore applying the GIS data to NetLogo’s entities, we should try to already calculate and keep an important information about the real-world scale of our model: the dimensions of a patch according to the GIS projections.\nWe can extend the code above:\nglobals\n[\n  width\n  height\n\n  areaPerPatch\n  patchWidth\n\n  ;;; GIS data holders\n  sitesData_EMIII-MMIA\n  sitesData_MMIB\n  elevationData\n  riversData\n]\n\nto set-world-dimensions\n\n  ;;; for better performance, we take a multiple fraction of the dimensions of elevationData,\n  ;;; so that patches will get average values or more regular sets of pixels\n\n  let patchXpixelScale 0.1 ;;; keep it less than 0.25\n  let pixelExtentMargin 50\n\n  set width ceiling ((pixelExtentMargin + gis:width-of elevationData) * patchXpixelScale)\n  set height ceiling ((pixelExtentMargin + gis:height-of elevationData) * patchXpixelScale)\n\n  resize-world 0 width 0 height\n\n  set-patch-size 3\n  \n  ; Match NetLogo world to the dataset envelope\n  gis:set-world-envelope gis:envelope-of elevationData\n\n  ; Calculate area equivalent to a patch\n\n  ; if units are in degrees\n  ;set areaPerPatch calculate-patch-area-degrees elevationData\n\n  ; if units are in meters\n  set areaPerPatch calculate-patch-area-meters elevationData\n\n  set patchWidth sqrt (areaPerPatch * 10000) ;;; m = ha * 10,000\n\nend\nWhere calculate-patch-area-meters (and calculate-patch-area-degrees) is a procedure enclosing this simple, yet delicate calculation. GIS files might use projections expressed either in metres or degrees, so we keep both alternative solutions, “commenting out” the one not used in this case. Notice that by defining them separately, we facilitate their use in other models. Here is the code for these procedures:\nto-report calculate-patch-area-degrees [ rasterData ]\n\n  ; Get the envelope: [min-x min-y max-x max-y] in degrees\n  let env gis:envelope-of rasterData\n  let min-lon item 0 env\n  let min-lat item 2 env\n  let max-lon item 1 env\n  let max-lat item 3 env\n\n  ; Calculate central latitude (φ₀)\n  let lat0 (min-lat + max-lat) / 2\n\n  ; Get raster resolution (number of cells)\n  set width gis:width-of rasterData     ; number of columns\n  set height gis:height-of rasterData   ; number of rows\n\n  ; Cell size (in degrees)\n  let dlon (max-lon - min-lon) / width\n  let dlat (max-lat - min-lat) / height\n\n  ; Earth radius (meters)\n  let R 6371000\n\n  ; Area per raster cell in square meters (approximate)\n  let patchArea (R ^ 2) * abs dlon * abs dlat * cos(lat0 * pi / 180) * (pi / 180) ^ 2\n\n  ; Report the result\n;  print (word \"Approximate area per patch: \" patchArea \" m² (\" (patchArea / 10000) \" ha) at latitude \" lat0)\n\n  report patchArea / 10000\n\nend\n\nto-report calculate-patch-area-meters [ gisData ]\n\n  let env gis:envelope-of gisData\n\n  let gis-width item 1 env - item 0 env\n  let gis-height item 3 env - item 2 env\n;  print (word \"width: \" gis-width \", height: \" gis-height)\n\n  let num-patches-x max-pxcor - min-pxcor + 1\n  let num-patches-y max-pycor - min-pycor + 1\n  ;set patch-width gis-width / num-patches-x\n\n  let patchArea (gis-width * gis-height) / (num-patches-x * num-patches-y)\n;  print (word \"area-per-patch=\" area-per-patch)\n  set patchArea patchArea / 10000 ; square meters to hectares\n\n  report patchArea\n\nend\nWhen in doubt about the projection of your file, the values obtained for areaPerPatch (ha) and patchWidth (m) when running both solutions will give you a quick hint. In our case, the calculation should be done in metres and, with this code, we will have patches of approximately 145 x 145 metres.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#applying-gis-data-to-patches",
    "href": "messara-gis.html#applying-gis-data-to-patches",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "24.5 Applying GIS data to patches",
    "text": "24.5 Applying GIS data to patches\nNext, we effectively apply the data to patches using the gis extension primitives:\nglobals\n[\n  patchesWithElevationData\n  noElevationDataTag\n  maxElevation\n\n  width\n  height\n\n  areaPerPatch\n  patchWidth\n\n  ;;; GIS data holders\n  sitesData_EMIII-MMIA\n  sitesData_MMIB\n  elevationData\n  riversData\n]\n\nbreed [ sites site ]\n\nsites-own\n[\n  name\n  siteType\n  period\n]\n\npatches-own\n[\n  elevation\n  isRiver\n]\n\nto setup-patches\n\n  setup-elevation\n\n  setup-rivers\n\nend\n\nto setup-elevation\n\n  gis:apply-raster elevationData elevation\n\n  set patchesWithElevationData patches with [(elevation &lt;= 0) or (elevation &gt;= 0)]\n  \n  ;;; replace NaN values added by the gis extension with noElevationDataTag, so it does not generate problems after\n  set noElevationDataTag -9999\n  ask patches with [not ((elevation &lt;= 0) or (elevation &gt;= 0))] [ set elevation noElevationDataTag ]\n\n  set maxElevation max [elevation] of patchesWithElevationData\n\nend\n\nto setup-rivers\n\n  ask patchesWithElevationData\n  [\n    set isRiver gis:intersects? riversData self\n  ]\n\nend\n\nto setup-sites\n\n  ;;; gis extension will re-use a site, if it was already created in a position,\n  ;;; and modify any values we already set.\n  ;;; In order to avoid this, we cannot use gis:create-turtles-from-points\n  \n  let datasetPeriod \"EMIII-MMIA\"\n  foreach gis:feature-list-of sitesData_EMIII-MMIA \n  [\n    vectorFeature -&gt;\n    \n    create-site-from-feature vectorFeature datasetPeriod\n  ]\n  \n  set datasetPeriod \"MMIB\"\n  foreach gis:feature-list-of sitesData_MMIB \n  [\n    vectorFeature -&gt;\n    \n    create-site-from-feature vectorFeature datasetPeriod\n  ]\n\nend\n\nto create-site-from-feature [ vectorFeature datasetPeriod ]\n  \n  let coordTuple gis:location-of (first (first (gis:vertex-lists-of vectorFeature)))\n  let featureName gis:property-value vectorFeature \"NAME\"\n  let featureType gis:property-value vectorFeature \"TYPE\"\n\n  let long item 0 coordTuple\n  let lat item 1 coordTuple\n\n  create-sites 1\n  [ \n    setxy long lat\n    set name featureName\n    set siteType featureType\n    set period datasetPeriod\n    \n    set shape \"dot\"\n  ]\n  \nend\nNotice that the gis extension generates NaN values on those patches outside the raster data. NetLogo does not handle NaNs, which can become a problem later. To solve this, we create a patch-set variable to filter patches with elevation data (patchesWithElevationData) and use a constant noElevationDataTag with an impossible elevation value to mark those outside the heightmap. From now on, we need to be careful not to use the patches primitive, which will call both kinds of patches.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#higher-level-procedure-create-map",
    "href": "messara-gis.html#higher-level-procedure-create-map",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "24.6 Higher level procedure: create-map",
    "text": "24.6 Higher level procedure: create-map\nWe wrap up everything in a procedure create-map:\nto create-map\n\n  load-gis  ;; load in the GIS data\n\n  set-world-dimensions ;; set world dimensions according to GIS data\n\n  setup-patches ;; use GIS data to set patch variables\n\n  setup-sites ;; create site agents with properties from sitesData\n\nend",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#visualisation",
    "href": "messara-gis.html#visualisation",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "24.7 Visualisation",
    "text": "24.7 Visualisation\nFinally, we need to add some extra code in order to display our data:\nto update-display\n\n  display-rivers\n\n  display-sites\n\n  paint-elevation\n\nend\n\nto display-sites\n\n  ;;; sites dated to EMIII-MMIA: yellow\n  gis:set-drawing-color yellow\n  gis:draw sitesData_EMIII-MMIA 2\n\n  ;;; sites dated to MMIB: red\n  gis:set-drawing-color red\n  gis:draw sitesData_MMIB 2\n\n  ;;; sites dated to both EMIII-MMIA and MMIB: orange\n\nend\n\nto display-rivers\n\n  gis:set-drawing-color blue\n  gis:draw riversData 1\n\nend\n\nto paint-elevation\n\n  ;;; paint patches according to elevation\n  ;;; NOTE: we must filter out those patches outside the DEM\n  ask patchesWithElevationData\n  [\n    let elevationGradient 100 + (155 * (elevation / maxElevation))\n    set pcolor rgb (elevationGradient - 100) elevationGradient 0\n  ]\n\nend",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-gis.html#set-up-procedure-and-testing",
    "href": "messara-gis.html#set-up-procedure-and-testing",
    "title": "24  Importing spatial data: elevation and site data",
    "section": "24.8 Set up procedure and testing",
    "text": "24.8 Set up procedure and testing\nWe then we place both in a higher-level procedure, using the conventional setup (and adding its button):\nto setup\n\n  clear-all\n\n  create-map\n\n  update-display\n\nend\n\nScreenshot of the ‘load-gis-data’ module\nSee the fully implemented version of this module: BlockC_module1_load-gis-data.nlogo.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Importing spatial data: elevation and site data</span>"
    ]
  },
  {
    "objectID": "messara-water-flow.html",
    "href": "messara-water-flow.html",
    "title": "25  Calculating water flow accumulation",
    "section": "",
    "text": "25.1 Water flow algorithm\nTowards our calculation of land productivity, we advance using our GIS data in combination with parts of the Land submodel in the Indus Village model (Angourakis 2021). Our objective in this step is to reach a flow accumulation value for each patch according to their relative elevation within the terrain. This will serve as a proxy of the region hydrology beyond the data we have on rivers.\nThe submodel is based on the algorithm described in Jenson & Domingue (1988) through the implementation used by Huang & Lee (2015).",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Calculating water flow accumulation</span>"
    ]
  },
  {
    "objectID": "messara-water-flow.html#water-flow-algorithm",
    "href": "messara-water-flow.html#water-flow-algorithm",
    "title": "25  Calculating water flow accumulation",
    "section": "",
    "text": "Jenson, S. K., and J. O. Domingue. 1988. ‘Extracting Topographic Structure from Digital Elevation Data for Geographic Information System Analysis’. Photogrammetric Engineering and Remote Sensing 54 (11): 1593–1600.\n\n\nHuang, Pin Chun, and Kwan Tun Lee. 2015. ‘A Simple Depression-Filling Method for Raster and Irregular Elevation Datasets’. Journal of Earth System Science 124 (8): 1653–65. https://doi.org/10.1007/s12040-015-0641-2.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Calculating water flow accumulation</span>"
    ]
  },
  {
    "objectID": "messara-water-flow.html#adding-the-main-procedures",
    "href": "messara-water-flow.html#adding-the-main-procedures",
    "title": "25  Calculating water flow accumulation",
    "section": "25.2 Adding the main procedures",
    "text": "25.2 Adding the main procedures\nThe algorithm uses a numeric codification of the eight neighbour directions and a tag that classifies patches as “start”, “pending”, “done”, progressively converting the formers into the latter. Patches on the edge of the map are directed automatically towards the outside. Because this is an significant piece of code based on a specific reference, we will enclose all related procedures within a especial commentary note:\nglobals\n[\n  ...\n\n  ;;; variables\n  maxFlowAccumulation\n]\n\n...\n\npatches-own\n[\n  elevation ; elevation above sea level [m]\n\n  flow_direction        ; the numeric code for the (main) direction of flow or\n                        ; drainage within the land unit.\n                        ; Following Jenson & Domingue (1988) convention:\n                        ; NW = 64,   N = 128,        NE = 1,\n                        ; W = 32,     &lt;CENTRE&gt;,   E = 2,\n                        ; SW = 16,     S = 8,          SE = 4\n\n  flow_receive          ; Boolean variable stating whether or not the land unit receives\n                        ; the flow of a neighbour.\n\n  flow_accumulation     ; the amount of flow units accumulated in the land unit.\n                        ; A Flow unit is the volume of runoff water flowing from one land unit\n                        ; to another (assumed constant and without losses).\n  flow_accumulationState ; the state of the land unit regarding the calculation of flow\n                        ; accumulation (auxiliary variable).\n\n  isRiver\n]\n\n...\n\n;=======================================================================================================\n;;; START of algorithms based on:\n;;; Jenson, S. K., & Domingue, J. O. (1988).\n;;; Extracting topographic structure from digital elevation data for geographic information system analysis.\n;;; Photogrammetric engineering and remote sensing, 54(11), 1593-1600.\n;;; ===BUT used elsewhere, such as in the algorithms based on:\n;;; Huang, P., Lee, K.T. A simple depression-filling method for raster and irregular elevation datasets.\n;;; J Earth Syst Sci 124, 1653–1665 (2015). https://doi.org/10.1007/s12040-015-0641-2\n;=======================================================================================================\n\nto-report get-drop-from [ aPatch ] ; ego = patch\n\n  ; \"Distance- weighted drop is calculated by subtracting the neighbor’s value from the center cell’s value\n  ; and dividing by the distance from the center cell, √2 for a corner cell and one for a noncorner cell.\" (p. 1594)\n\n  report ([elevation] of aPatch - elevation) / (distance aPatch)\n\nend\n\nto-report is-at-edge ; ego = patch\n\n  report any? neighbors with [elevation = noElevationDataTag]\n\nend\n\nto-report has-flow-direction-code ; ego = patch\n\n  if (member? flow_direction [ 1 2 4 8 16 32 64 128 ]) [ report true ]\n\n  report false\n\nend\n\nto-report flow-direction-is [ centralPatch ]\n\n  if (flow_direction = get-flow-direction-encoding ([pxcor] of centralPatch - pxcor) ([pycor] of centralPatch - pycor))\n  [ report true ]\n\n  report false\n\nend\n\nto-report get-flow-direction-encoding [ x y ]\n\n  if (x = -1 and y = -1) [ report 16 ] ; Southwest\n  if (x = -1 and y = 0) [ report 32 ]  ; West\n  if (x = -1 and y = 1) [ report 64 ]  ; Northwest\n\n  if (x = 0 and y = -1) [ report 8 ]   ; South\n  if (x = 0 and y = 1) [ report 128 ]  ; North\n\n  if (x = 1 and y = -1) [ report 4 ]   ; Southeast\n  if (x = 1 and y = 0) [ report 2 ]    ; East\n  if (x = 1 and y = 1) [ report 1 ]    ; Northeast\n\nend\n\nto-report get-patch-in-flow-direction [ neighborEncoding ] ; ego = patch\n\n  ; 64 128 1\n  ; 32  x  2\n  ; 16  8  4\n\n  if (neighborEncoding = 16) [ report patch (pxcor - 1) (pycor - 1) ]\n  if (neighborEncoding = 32) [ report patch (pxcor - 1) (pycor) ]\n  if (neighborEncoding = 64) [ report patch (pxcor - 1) (pycor + 1) ]\n\n  if (neighborEncoding = 8) [ report patch (pxcor) (pycor - 1) ]\n  if (neighborEncoding = 128) [ report patch (pxcor) (pycor + 1) ]\n\n  if (neighborEncoding = 4) [ report patch (pxcor + 1) (pycor - 1) ]\n  if (neighborEncoding = 2) [ report patch (pxcor + 1) (pycor) ]\n  if (neighborEncoding = 1) [ report patch (pxcor + 1) (pycor + 1) ]\n\n  report nobody\n\nend\n\nto-report flow-direction-is-loop ; ego = patch\n\n  let thisPatch self\n  let dowstreamPatch get-patch-in-flow-direction flow_direction\n  ;print (word \"thisPatch: \" thisPatch \"dowstreamPatch: \" dowstreamPatch)\n\n  if (dowstreamPatch != nobody)\n  [ report [flow-direction-is thisPatch] of dowstreamPatch ]\n\n  report false\n\nend\n\nto set-flow-directions\n\n  ask patchesWithElevationData\n  [\n    ifelse (is-at-edge)\n    [\n      ifelse ( pxcor = min-pxcor )\n      [ set flow_direction 32 ] ; west\n      [\n        ifelse ( pxcor = max-pxcor )\n        [ set flow_direction 2 ] ; east\n        [\n          ifelse ( pycor = min-pycor )\n          [ set flow_direction 8 ] ; south\n          [ set flow_direction 128 ] ; north\n        ]\n      ]\n    ]\n    [\n      set-flow-direction\n    ]\n  ]\n\nend\n\nto set-flow-direction ; ego = patch\n\n  let thisPatch self\n\n  let downstreamPatch max-one-of neighbors with [elevation &gt; noElevationDataTag] [get-drop-from thisPatch]\n  set flow_direction get-flow-direction-encoding ([pxcor] of downstreamPatch - pxcor) ([pycor] of downstreamPatch - pycor)\n\nend\n\nto set-flow-accumulations\n\n  ; From Jenson, S. K., & Domingue, J. O. (1988), p. 1594\n  ; \"FLOW ACCUMULATION DATA SET\n  ; The third procedure of the conditioning phase makes use of the flow direction data set to create the flow accumulation data set,\n  ; where each cell is assigned a value equal to the number of cells that flow to it (O’Callaghan and Mark, 1984).\n  ; Cells having a flow accumulation value of zero (to which no other cells flow) generally correspond to the pattern of ridges.\n  ; Because all cells in a depressionless DEM have a path to the data set edge, the pattern formed by highlighting cells\n  ; with values higher than some threshold delineates a fully connected drainage network.\"\n\n  ; identify patches that receive flow and those that do not (this makes the next step much easier)\n  ask patchesWithElevationData\n  [\n    set flow_receive false\n    set flow_accumulationState \"start\"\n    ;set pcolor red\n  ]\n\n  ask patchesWithElevationData with [has-flow-direction-code]\n  [\n    let patchInFlowDirection get-patch-in-flow-direction flow_direction\n    if (patchInFlowDirection != nobody)\n    [\n      ask patchInFlowDirection\n      [\n        set flow_receive true\n        set flow_accumulationState \"pending\"\n        ;set pcolor yellow\n      ]\n    ]\n  ]\n\n  let maxIterations 100000 ; just as a safety measure, to avoid infinite loop\n  while [count patchesWithElevationData with [flow_accumulationState = \"pending\" and not flow-direction-is-loop] &gt; 0 and maxIterations &gt; 0 and count patchesWithElevationData with [flow_accumulationState = \"start\"] &gt; 0 ]\n  [\n    ask one-of patchesWithElevationData with [flow_accumulationState = \"start\"]\n    [\n      let downstreamPatch get-patch-in-flow-direction flow_direction\n      let nextFlow_accumulation flow_accumulation + 1\n\n      set flow_accumulationState \"done\"\n      ;set pcolor orange\n\n      if (downstreamPatch != nobody)\n      [\n        ask downstreamPatch\n        [\n          set flow_accumulation flow_accumulation + nextFlow_accumulation\n          if (count neighbors with [\n            elevation &gt; noElevationDataTag and\n            get-patch-in-flow-direction flow_direction = downstreamPatch and\n            (flow_accumulationState = \"pending\" or flow_accumulationState = \"start\")\n            ] = 0\n          )\n          [\n            set flow_accumulationState \"start\"\n            ;set pcolor red\n          ]\n        ]\n      ]\n    ]\n\n    set maxIterations maxIterations - 1\n  ]\n\nend\n\n;=======================================================================================================\n;;; END of algorithms based on:\n;;; Jenson, S. K., & Domingue, J. O. (1988).\n;;; Extracting topographic structure from digital elevation data for geographic information system analysis.\n;;; Photogrammetric engineering and remote sensing, 54(11), 1593-1600.\n;;; ===BUT used in the algorithms based on:\n;;; Huang P C and Lee K T 2015\n;;; A simple depression-filling method for raster and irregular elevation datasets\n;;; J. Earth Syst. Sci. 124 1653–65\n;=======================================================================================================\nOutside this enclosed section, we add the two main procedures set-flow-directions and set-flow-accumulations inside a higher level setup-flows:\nto setup-flows\n\n  fill-sinks\n  \n  set-flow-directions\n\n  set-flow-accumulations\n\n  ; set maximum flow accumulation as a reference\n  set maxFlowAccumulation max [flow_accumulation] of patchesWithElevationData\n\nend\nWe add a last step to get maxFlowAccumulation, which we will need for scaling purposes.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Calculating water flow accumulation</span>"
    ]
  },
  {
    "objectID": "messara-water-flow.html#visualisation",
    "href": "messara-water-flow.html#visualisation",
    "title": "25  Calculating water flow accumulation",
    "section": "25.3 Visualisation",
    "text": "25.3 Visualisation\nAs usual, we need to implement some extra code to be able to visualise the outcome. In this case, however, we would like to observe simultaneously flow direction, flow accumulation and elevation. For this, we will use an accessory agent type whose only function is representing the flow of patches on top of its colour.\nbreed [ flowHolders flowHolder ]\n\n...\n\nto display-flows\n\n  if (not any? flowHolders)\n  [\n    ask patchesWithElevationData [ sprout-flowHolders 1 [ set hidden? true ] ]\n  ]\n\n  ifelse (show-flows)\n  [\n    ask patchesWithElevationData\n    [\n      let flow_directionHere flow_direction\n      let nextPatchInFlow get-patch-in-flow-direction flow_direction\n      if (not [((elevation &lt;= 0) or (elevation &gt;= 0))] of nextPatchInFlow) [ set nextPatchInFlow nobody ]\n      let flow_accumulationHere flow_accumulation\n\n      ask one-of flowHolders-here\n      [\n        ifelse (nextPatchInFlow != nobody)\n        [\n          if (link-with one-of [flowHolders-here] of nextPatchInFlow = nobody)\n          [ create-link-with one-of [flowHolders-here] of nextPatchInFlow ]\n\n          ask link-with one-of [flowHolders-here] of nextPatchInFlow\n          [\n            set hidden? false\n            let multiplier 1E100 ^ (1 - flow_accumulationHere / (max [flow_accumulation] of patchesWithElevationData)) / 1E100\n            set color 92 + (5 * multiplier)\n            set thickness 0.4 * ( 1 - ((color - 92) / 5))\n          ]\n        ]\n        [\n          set hidden? false\n          let multiplier 1E100 ^ (1 - flow_accumulationHere / (max [flow_accumulation] of patchesWithElevationData)) / 1E100\n          set color 92 + (5 * multiplier)\n          if (color &lt;= 97) [ set shape \"line half\" ]\n          if (color &lt; 95) [ set shape \"line half 1\" ]\n          if (color &lt; 93) [ set shape \"line half 2\" ]\n          set heading get-angle-in-flow-direction flow_direction\n        ]\n      ]\n    ]\n  ]\n  [\n    ask flowHolders\n    [\n      set hidden? true\n      ask my-links [ set hidden? true ]\n    ]\n  ]\n\nend\n\nto-report get-angle-in-flow-direction [ neighborEncoding ]\n\n  ; 64 128 1\n  ; 32  x  2\n  ; 16  8  4\n\n  if (neighborEncoding = 16) [ report 225 ]\n  if (neighborEncoding = 32) [ report 270 ]\n  if (neighborEncoding = 64) [ report 315 ]\n\n  if (neighborEncoding = 8) [ report 180 ]\n  if (neighborEncoding = 128) [ report 0 ]\n\n  if (neighborEncoding = 4) [ report 135 ]\n  if (neighborEncoding = 2) [ report 90 ]\n  if (neighborEncoding = 1) [ report 45 ]\n\n  report nobody\n\nend\nNow, press “setup”. The calculation of variables is made relatively fast, but displaying all flowHolders will take some time.\n\nView of flow direction and accumulation, calculated with ‘flows’ module",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Calculating water flow accumulation</span>"
    ]
  },
  {
    "objectID": "messara-water-flow.html#assessing-fit",
    "href": "messara-water-flow.html#assessing-fit",
    "title": "25  Calculating water flow accumulation",
    "section": "25.4 Assessing fit",
    "text": "25.4 Assessing fit\nTo better visualise how much flow_accumulation actually gets accumulated, let us run the following “highlight” command directly in the console:\nask patches with [flow_accumulation &gt; 10] [ set pcolor red ]\n\nHighlight of patches with flow accumulation greater than 10\nFocus view on a sample of patches:\n| | | | — | — | | patch 70 145 |  | | patch 179 69 |  | | patch 70 145 |  | | patch 201 108 |  | | patch 125 99 |  | | patch 54 76 |  |\nOur approximation of the region’s hydrological system is definitely not perfect. As a minimum, we want the main river, Lithaíos, to emerge, even if following an approximated path. The problem is most likely generated by our previous step: reducing the resolution of the original DEM. The height map we are using has many “sinks” in it (i.e., patches not at the edge with the lowest elevation among its neighbours).\nWorse, it might be that the roughness of the terrain escapes even the lowest of the resolutions treatable at this scale, to a point where the pathways of rivers cannot be retraced using height maps. Let us work with the first hypothesis and address the sinks in our processed height map.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Calculating water flow accumulation</span>"
    ]
  },
  {
    "objectID": "messara-water-flow.html#improving-fit-with-fill-sink",
    "href": "messara-water-flow.html#improving-fit-with-fill-sink",
    "title": "25  Calculating water flow accumulation",
    "section": "25.5 Improving fit with fill-sink",
    "text": "25.5 Improving fit with fill-sink\nOur result could be improved by using the fill-sink procedure in the original Land model implementation (see code in the Indus Village repository), which is based on Huang & Lee (2015).\nThis procedure fills up the elevation of “sink” patches so flow can continue moving, until it reaches the edge of the map.\nFirst, we can identify sink patches with the following procedure:\nto-report is-sink ; ego = patch\n\n  let thisPatch self\n\n  report (not is-at-edge) and (elevation &lt;= min [elevation] of neighbors with [((elevation &lt;= 0) or (elevation &gt;= 0))])\n\nend\nWe then used it together with our previous “highlight” command in the console:\nask patches with [is-sink] [ set pcolor red ]\n\nHighlight of sink patches\nWe then implement the fill-sinks algorithm:\nto fill-sinks\n\n  while [ count patchesWithElevationData with [is-sink] &gt; 0 ]\n  [\n    ask patchesWithElevationData with [is-sink]\n    [\n      set elevation [elevation] of min-one-of neighbors [elevation] + 1E-1\n    ]\n  ]\n\nend\nAfter running setup again, we obtain a much better result. We can now clearly identify what should be the Lithaíos river and its path is not too far from our original river data.\n\nView of flow direction and accumulation, calculated with ‘flows’ module with the fill-sinks procedure\n\nHighlight of patches with flow accumulation greater than 10, after we include the fill-sinks procedure\nWe should remember that this algorithm modifies our original DEM heightmap and costs more computation resources/time.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Calculating water flow accumulation</span>"
    ]
  },
  {
    "objectID": "messara-water-flow.html#implementing-a-feature-to-export-and-import-world",
    "href": "messara-water-flow.html#implementing-a-feature-to-export-and-import-world",
    "title": "25  Calculating water flow accumulation",
    "section": "25.6 Implementing a feature to export and import world",
    "text": "25.6 Implementing a feature to export and import world\nWe do not want to repeat this every time we initialise a simulation run. Therefore, we will export the entire map configuration to a file for later use. We do this quickly with “File &gt; Export… &gt; Export World” and selecting the data folder. We could write procedures specific for exporting (and importing) a subset of data. Still, this option is much faster, given that this is the initial spatial data we want for all further versions.\nStill, if you need to do this several times and want to keep track of the directory and file you are using, you can add a button to the interface with the following code, which is equivalent to the built-in option in the menu:\nexport-world \"data/terrainWithFlows/BlockC_module2_flows world.csv\"\nThe same can be done to import the same file. Inside a new button, add:\nclear-all\nimport-world \"data/terrainWithFlows/BlockC_module2_flows world.csv\"\nNow, you should be able to export and import your map with flows.\nSee the fully implemented version of this module: BlockC_module2_flows.nlogo.\nFor the sake of this example, we will assume our approximation to be sufficient. Still, tackling this kind of problem exploring other solutions in your own time could be an excellent exercise for improving your skills.",
    "crumbs": [
      "Messara Trade (I): case, design and spatial input data",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Calculating water flow accumulation</span>"
    ]
  },
  {
    "objectID": "messara-weather.html",
    "href": "messara-weather.html",
    "title": "26  Importing time series: weather data",
    "section": "",
    "text": "To compromise model complexity and precision, we will regulate land productivity by combining flow accumulation with the Agricultural reference index of drought (ARID). We will calculate a time-series of ARID for each day-of-year and patch using a modified version of the Soil Water (sub)model, again in the Indus Village model (Angourakis 2021). This submodel is a NetLogo implementation of the model defined by Wallach et al. 2019, which is based on Woli et al. 2012.\n\nWallach, Daniel, David Makowski, James W. Jones, and Francois Brun. 2019. Working with Dynamic Crop Models (Third Edition). Academic Press. https://doi.org/10.1016/C2016-0-01552-8.\n\n\nWoli, Prem, James W. Jones, Keith T. Ingram, and Clyde W. Fraisse. 2012. ‘Agricultural Reference Index for Drought (ARID)’. Agronomy Journal 104 (2): 287. https://doi.org/10.2134/agronj2011.0286.\n\nTo calculate ARID, we will use a point sample of daily weather variables. The dataset metadata is as follows:\nFile name: POWER_Point_Daily_19840101_20201231_035d0309N_024d8335E_LST.csv\nSource: NASA POWER (https://power.larc.nasa.gov/data-access-viewer/; see their sources and methodology at https://power.larc.nasa.gov/docs/methodology/)\nPoint location: Petrokefali (LAT: 35.0309; LON: 24.8335)\nTime extent: 01/01/1984 - 31/12/2020\nVariables: - YEAR, MO, DY: year (number), month (index in year) and day (index in month) of observation/row - PRECTOTCORR: The bias corrected average of total precipitation at the surface of the earth in water mass (includes water content in snow).\n- T2M_MIN, T2M_MAX: The maximum/minimum/average hourly air (dry bulb) temperature at 2 meters above the surface of the earth.\n- ALLSKY_SFC_SW_DWN: The total solar irradiance incident (direct plus diffuse) on a horizontal plane at the surface of the earth under all sky conditions. An alternative term for the total solar irradiance is the “Global Horizontal Irradiance” or GHI.\nBased on code from the Indus Village, we implement the first module only for loading, running, and displaying the dataset as simulation input data.\nThis module uses the data structure list to hold and process the data. The dataset is loaded from the original CSV file into several global variables (using the CSV NetLogo extension). You may need to look at NetLogo’s Dictionary several times to understand every step in this procedure.\nextensions [ csv ]\n\nglobals\n[\n  ;;; weather input data\n  weatherInputData_firstYear\n  weatherInputData_lastYear\n  weatherInputData_YEARS\n  weatherInputData_yearLengthInDays\n  weatherInputData_DOY\n  weatherInputData_YEAR-DOY\n  weatherInputData_solarRadiation\n  weatherInputData_precipitation\n  weatherInputData_temperature\n  weatherInputData_maxTemperature\n  weatherInputData_minTemperature\n\n  ;;;; Solar radiation (MJ/m2)\n  solar_annualMax\n  solar_annualMin\n  solar_meanDailyFluctuation\n\n  ;;; variables\n  ;;;; time tracking\n  currentYear\n  currentDayOfYear\n\n  ;;;; main (these follow a seasonal pattern and apply for all patches)\n\n  T ; average temperature of current day (ºC)\n  T_max ; maximum temperature of current day (ºC)\n  T_min ; minimum temperature of current day (ºC)\n\n  solarRadiation ; solar radiation of current day (MJ m-2)\n\n  RAIN ; precipitation of current day (mm)\n  precipitation_yearSeries\n  precipitation_cumYearSeries\n]\n\n...\n\nto load-weather-input-data-table\n\n  ;;; this procedure loads the values of the weather data input table\n  ;;; the table contains:\n  ;;;   1. 13 lines of metadata, to be ignored\n  ;;;   2. one line with the headers of the table\n  ;;;   3. remaining rows containing row name and values\n\n  let weatherTable csv:from-file \"data/POWER_Point_Daily_19840101_20201231_035d0309N_024d8335E_LST.csv\"\n\n  ;;;==================================================================================================================\n  ;;; mapping coordinates (row or columns) from headings (line 14 == index 13 -----------------------------------------\n  ;;; NOTE: always correct raw mapping coordinates (start at 1) into list indexes (start at 0)\n  let variableNames item (14 - 1) weatherTable\n\n  let yearColumn position \"YEAR\" variableNames\n\n  let solarRadiationColumn position \"ALLSKY_SFC_SW_DWN\" variableNames\n\n  let precipitationColumn position \"PRECTOTCORR\" variableNames\n\n  let temperatureColumn position \"T2M\" variableNames\n\n  let temperatureMaxColumn position \"T2M_MAX\" variableNames\n\n  let temperatureMinColumn position \"T2M_MIN\" variableNames\n\n  ;;;==================================================================================================================\n  ;;; extract data---------------------------------------------------------------------------------------\n\n  ;;; read variables per year and day (list of lists, matrix: year-day x variables)\n  let weatherData sublist weatherTable (15 - 1) (length weatherTable) ; select only those row corresponding to variable data, if there is anything else\n\n  ;;; extract year-day of year pairs from the third and fourth columns\n  set weatherInputData_YEARS map [row -&gt; item yearColumn row ] weatherData\n\n  ;;; NASA-POWER data uses year, month, day of month, instead of day of year,\n  ;;; so we need to calculate day of year of each row ourselves\n  set weatherInputData_DOY []\n  set weatherInputData_yearLengthInDays []\n  foreach (remove-duplicates weatherInputData_YEARS)\n  [\n    aYear -&gt;\n    let aDoy 1\n    let lengthOfThisYear length (filter [i -&gt; i = aYear] weatherInputData_YEARS)\n    set weatherInputData_yearLengthInDays lput lengthOfThisYear weatherInputData_yearLengthInDays\n    repeat lengthOfThisYear\n    [\n      set weatherInputData_DOY lput aDoy weatherInputData_DOY\n      set aDoy aDoy + 1\n    ]\n  ]\n  set weatherInputData_YEAR-DOY (map [[i j] -&gt; (word i \"-\" j)] weatherInputData_YEARS weatherInputData_DOY)\n\n  ;;; extract first and last year\n  set weatherInputData_firstYear first weatherInputData_YEARS\n\n  set weatherInputData_lastYear last weatherInputData_YEARS\n\n  ;;; extract parameter values from the given column\n  ;;; NOTE: read-from-string is required because the original file is formated in a way that NetLogo interprets values as strings.\n\n  set weatherInputData_solarRadiation map [row -&gt; item solarRadiationColumn row ] weatherData\n\n  set weatherInputData_precipitation map [row -&gt; item precipitationColumn row ] weatherData\n\n  set weatherInputData_temperature map [row -&gt; item temperatureColumn row ] weatherData\n\n  set weatherInputData_maxTemperature map [row -&gt; item temperatureMaxColumn row ] weatherData\n\n  set weatherInputData_minTemperature map [row -&gt; item temperatureMinColumn row ] weatherData\n\nend\nThere are other ways of doing this in NetLogo and many possible variations within this specific approach. The most important things here are to make sure that variable names are intelligible and all references to the internal structure of the CSV file are kept updated if any changes are made directly to the file. Abundant comments are also welcomed in this type of procedure.\nThis module also introduces an aspect that may be relevant when inputting or generating time series: calendar time keeping. This may seem trivial, but it has often been a weak point in models relying on input data.\nto advance-time\n\n  set currentDayOfYear currentDayOfYear + 1\n  \n  if (currentDayOfYear &gt; item (currentYear - weatherInputData_firstYear) weatherInputData_yearLengthInDays)\n  [\n    set currentYear currentYear + 1\n    set currentDayOfYear 1\n  ]\n\nend\nPress “setup” and then “go” (continuous run). NetLogo will run until it reaches the last day of the last year included in the dataset. This is because we have added in go a stop condition.\nto go\n\n  advance-time\n  \n  ;;; values are taken from input data\n  set-day-weather-from-input-data currentDayOfYear currentYear\n\n  tick\n\n  ; --- stop conditions -------------------------\n  \n  if (currentYear = weatherInputData_lastYear and currentDayOfYear = last weatherInputData_yearLengthInDays) [stop]\n\nend\n\nScreenshot of the ‘load-weather-data’ module\nSee the fully implemented version of this module: BlockC_module3_load-weather-data.nlogo.",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Importing time series: weather data</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html",
    "href": "messara-soil-water.html",
    "title": "27  Integrating a submodel",
    "section": "",
    "text": "27.1 Module variables\nLet us build the next module, ARID, over what we just implemented in the load-weather-data module.\nBesides the weather variables we have on our dataset, ARID requires several other variables related to soil properties and cover. We will make an exception to our code legibility rule and use the notation from the original implementation (Wallach et al. 2019).",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#module-variables",
    "href": "messara-soil-water.html#module-variables",
    "title": "27  Integrating a submodel",
    "section": "",
    "text": "globals\n[\n  ...\n\n  ;;; default constants\n\n  MUF ; Water Uptake coefficient (mm^3.mm^-3)\n  WP ; Water content at wilting Point (cm^3.cm^-3)\n\n  ;;;; ETr\n  albedo_min\n  albedo_max\n\n  ;;;; Soil Water Balance model global parameters\n  WHC_min\n  WHC_max\n  DC_min\n  DC_max\n  z_min\n  z_max\n  CN_min\n  CN_max\n\n  ...\n]\n\n...\n\npatches-own\n[\n  ...\n\n  ;;;; soil\n  DC ; Drainage coefficient (mm^3 mm^-3).\n  z ; root zone depth (mm).\n  CN ; Runoff curve number.\n  FC ; Water content at field capacity (cm^3.cm^-3)\n  WHC ; Water Holding Capacity of the soil (cm^3.cm^-3). Typical range from 0.05 to 0.25\n\n  ARID ; ARID index after Woli et al. 2012, ranging form 0 (no water shortage) to 1 (extreme water shortage)\n  WAT ; Water content in the soil profile for the rooting depth (mm)\n  WATp ; Volumetric Soil Water content (fraction : mm.mm-1). calculated as WAT/z\n\n  ;;;; cover\n  albedo ; canopy reflection or albedo\n  netSolarRadiation ; net solar radiation discount canopy reflection or albedo\n  ETr ; reference evapotranspiration\n]",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#module-parameters",
    "href": "messara-soil-water.html#module-parameters",
    "title": "27  Integrating a submodel",
    "section": "27.2 Module parameters",
    "text": "27.2 Module parameters\nWe will use a randomised configuration of most of these patch variables using hyperparameters giving the envelope of variation. The Indus Village eventually escapes this initial solution by calculating these variables based on various datasets and submodels. We will, however, use it for the sake of simplicity. As Wallach et al. (2019), we will use two global variables as constants (MUF and WP) and create some extra procedures that will help us register and apply a default configuration of the hyperparameters (parameters-check and parameters-to-default).\nto set-constants\n\n  ; \"constants\" are variables that will not be explored as parameters\n  ; and may be used during a simulation.\n\n  ; MUF : Water Uptake coefficient (mm^3 mm^-3)\n  set MUF 0.096\n\n  ; WP : Water content at wilting Point (cm^3.cm^-3)\n  set WP 0.06\n\nend\n\nto set-parameters\n\n  ; set random seed\n  random-seed seed\n\n  ;;; load weather input data from file\n  load-weather-input-data-table\n\n  parameters-check\n\n  ;;; weather parameters are left with default values, but effectively ignored given that input weather is used.\n\n  set albedo_min 1E-6 + random-float 0.3\n  set albedo_max albedo_min + random-float 0.3\n\n  ;;; Soil Water Balance model\n  set WHC_min random-float 0.1\n  set WHC_max WHC_min + random-float 0.1\n  set DC_min 1E-6 + random-float 0.45\n  set DC_max DC_min + random-float 0.45\n  set z_min random-float 1000\n  set z_max z_min + random-float 1000\n  set CN_min random-float 40\n  set CN_max CN_min + random-float 50\n\nend\n\nto parameters-check\n\n  ;;; check if values were reset to 0 (NetLogo does that from time to time...!)\n  ;;; and set default values (assuming they are not 0)\n\n  if (par_albedo_min = 0)                                        [ set par_albedo_min                              0.1 ]\n  if (par_albedo_max = 0)                                        [ set par_albedo_max                              0.5 ]\n\n  if (water-holding-capacity_min = 0)                            [ set water-holding-capacity_min                    0.05 ]\n  if (water-holding-capacity_max = 0)                            [ set water-holding-capacity_max                    0.25 ]\n  if (drainage-coefficient_min = 0)                              [ set drainage-coefficient_min                      0.3 ]\n  if (drainage-coefficient_max = 0)                              [ set drainage-coefficient_max                      0.7 ]\n  if (root-zone-depth_min = 0)                                   [ set root-zone-depth_min                         200 ]\n  if (root-zone-depth_max = 0)                                   [ set root-zone-depth_max                        2000 ]\n  if (runoff-curve_min = 0)                                      [ set runoff-curve_min                             30 ]\n  if (runoff-curve_max = 0)                                      [ set runoff-curve_max                             80 ]\n\nend\n\nto parameters-to-default\n\n  ;;; set parameters to a default value\n  set par_albedo_min                                            0.1\n  set par_albedo_max                                            0.5\n\n  set water-holding-capacity_min                                0.05\n  set water-holding-capacity_max                                0.25\n  set drainage-coefficient_min                                  0.3\n  set drainage-coefficient_max                                  0.7\n  set root-zone-depth_min                                     200\n  set root-zone-depth_max                                    2000\n  set runoff-curve_min                                         30\n  set runoff-curve_max                                         80\n\nend\n\n...\n\nto setup-soil-water-properties\n\n  ask patchesWithElevationData\n  [\n    set albedo albedo_min + random-float (albedo_max - albedo_min)\n\n    ; Water Holding Capacity of the soil (cm^3 cm^-3).\n    set WHC WHC_min + random-float (WHC_max - WHC_min)\n    ; DC :  Drainage coefficient (mm^3 mm^-3)\n    set DC DC_min + random-float (DC_max - DC_min)\n    ; z : root zone depth (mm)\n    set z z_min + random (z_max - z_min)\n    ; CN : Runoff curve number\n    set CN CN_min + random (CN_max - CN_max)\n\n    ; FC : Water content at field capacity (cm^3.cm^-3)\n    set FC WP + WHC\n    ; WAT0 : Initial Water content (mm)\n    set WAT z * FC\n  ]\n\nend",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#connector-variables-and-procedures",
    "href": "messara-soil-water.html#connector-variables-and-procedures",
    "title": "27  Integrating a submodel",
    "section": "27.3 Connector variables and procedures",
    "text": "27.3 Connector variables and procedures\nIn our previous implementation of set-day-weather-from-input-data, we must now add a new final step, where netSolarRadiation and ETr (reference evapotranspiration) are set for each patch. We also need to implement a procedure to estimate ETr based on an FAO standard (Allen et al. 1998).\n\nAllen, Richard G., Luis S. Pereira, Dirk Raes, and Martin Smith. 1998. Crop Evapotranspiration - FAO Irrigation and Drainage Paper No. 56. Rome: FAO. http://www.fao.org/3/X0490E/x0490e00.htm.\n\n\nto set-day-weather-from-input-data [ dayOfYear year ]\n\n  ...\n\n  ask patchesWithElevationData\n  [\n    set netSolarRadiation (1 - albedo) * solarRadiation\n    set ETr get-ETr\n  ]\n\nend\n\n...\n\nto-report get-ETr\n\n  ;;; useful references:\n  ;;; Suleiman A A and Hoogenboom G 2007\n  ;;; Comparison of Priestley-Taylor and FAO-56 Penman-Monteith for Daily Reference Evapotranspiration Estimation in Georgia\n  ;;; J. Irrig. Drain. Eng. 133 175–82 Online: http://ascelibrary.org/doi/10.1061/%28ASCE%290733-9437%282007%29133%3A2%28175%29\n  ;;; also: Jia et al. 2013 - doi:10.4172/2168-9768.1000112\n  ;;; Allen, R. G., Pereira, L. A., Raes, D., and Smith, M. 1998.\n  ;;; “Crop evapotranspiration.”FAO irrigation and  drainage paper 56, FAO, Rome.\n  ;;; also: http://www.fao.org/3/X0490E/x0490e07.htm\n  ;;; constants found in: http://www.fao.org/3/X0490E/x0490e07.htm\n  ;;; see also r package: Evapotranspiration (consult source code)\n\n  let windSpeed 2 ; as recommended by: http://www.fao.org/3/X0490E/x0490e07.htm#estimating%20missing%20climatic%20data\n\n  ;;; estimation of saturated vapour pressure (e_s) and actual vapour pressure (e_a)\n  let e_s (get-vapour-pressure T_max + get-vapour-pressure T_min) / 2\n  let e_a get-vapour-pressure T_min\n  ; ... in absence of dew point temperature, as recommended by\n  ; http://www.fao.org/3/X0490E/x0490e07.htm#estimating%20missing%20climatic%20data\n  ; however, possibly min temp &gt; dew temp under arid conditions\n\n  ;;; slope of  the  vapor  pressure-temperature  curve (kPa ºC−1)\n  let DELTA 4098 * (get-vapour-pressure T) / (T + 237.3) ^ 2\n\n  ;;; latent heat of vaporisation = 2.45 MJ.kg^-1\n  let lambda 2.45\n\n  ;;; specific heat at constant pressure, 1.013 10-3 [MJ kg-1 °C-1]\n  let c_p 1.013 * 10 ^ -3\n  ;;; ratio molecular weight of water vapour/dry air\n  let epsilon 0.622\n  ;;; atmospheric pressure (kPa)\n  let P 101.3 * ((293 - 0.0065 * elevation) / 293) ^ 5.26\n  ;;; psychometric constant (kPa ºC−1)\n  let gamma c_p * P / (epsilon * lambda)\n\n  ;;; Penman-Monteith equation from: fao.org/3/X0490E/x0490e0 ; and from: weap21.org/WebHelp/Mabia_Alg ETRef.htm\n\n  ; 900 and 0.34 for the grass reference; 1600 and 0.38 for the alfalfa reference\n  let C_n 900\n  let C_d 0.34\n\n  let ETr_temp (0.408 * DELTA * netSolarRadiation + gamma * (C_n / (T + 273)) * windSpeed * (e_s - e_a)) / (DELTA + gamma * (1 + C_d * windSpeed))\n\n  report ETr_temp\n\nend\n\nto-report get-vapour-pressure [ temp ]\n\n  report (0.6108 * exp(17.27 * temp / (temp + 237.3)))\n\nend",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#implementing-the-main-algorithm",
    "href": "messara-soil-water.html#implementing-the-main-algorithm",
    "title": "27  Integrating a submodel",
    "section": "27.4 Implementing the main algorithm",
    "text": "27.4 Implementing the main algorithm\nNext, we add update-WAT, which contains the calculations that finally outputs ARID.\nto update-WAT\n\n  ; Soil Water Balance model\n  ; Using the approach of:\n  ; 'Working with dynamic crop models: Methods, tools, and examples for agriculture and enviromnent'\n  ;  Daniel Wallach, David Makowski, James W. Jones, François Brun (2006, 2014, 2019)\n  ;  Model description in p. 24-28, R code example in p. 138-144.\n  ;  see also https://github.com/cran/ZeBook/blob/master/R/watbal.model.r\n  ; Some additional info about run off at: https://engineering.purdue.edu/mapserve/LTHIA7/documentation/scs.htm\n  ; and at: https://en.wikipedia.org/wiki/Runoff_curve_number\n\n  ; Maximum abstraction (mm; for run off)\n  let S 25400 / CN - 254\n  ; Initial Abstraction (mm; for run off)\n  let IA 0.2 * S\n  ; WATfc : Maximum Water content at field capacity (mm)\n  let WATfc FC * z\n  ; WATwp : Water content at wilting Point (mm)\n  let WATwp WP * z\n\n  ; Change in Water Before Drainage (Precipitation - Runoff)\n  let RO 0\n  if (RAIN &gt; IA)\n  [ set RO ((RAIN - 0.2 * S) ^ 2) / (RAIN + 0.8 * S) ]\n  ; Calculating the amount of deep drainage\n  let DR 0\n  if (WAT + RAIN - RO &gt; WATfc)\n  [ set DR DC * (WAT + RAIN - RO - WATfc) ]\n\n  ; Calculate rate of change of state variable WAT\n  ; Compute maximum water uptake by plant roots on a day, RWUM\n  let RWUM MUF * (WAT + RAIN - RO - DR - WATwp)\n  ; Calculate the amount of water lost through transpiration (TR)\n  let TR min (list RWUM ETr)\n\n  let dWAT RAIN - RO - DR - TR\n  set WAT WAT + dWAT\n\n  set WATp WAT / z\n\n  set ARID 0\n  if (TR &lt; ETr)\n  [ set ARID 1 - TR / ETr ]\n\nend",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#merging-with-spatial-data-module",
    "href": "messara-soil-water.html#merging-with-spatial-data-module",
    "title": "27  Integrating a submodel",
    "section": "27.5 Merging with spatial data module",
    "text": "27.5 Merging with spatial data module\nUntil this point, we are still lacking our spatial data. Let us implement the necessary code to be able to import the processed data we output from the flows module.\nextensions [ csv gis ]\n\n...\n\nbreed [ sites site ]\n\nbreed [ flowHolders flowHolder ]\n\n...\n\nglobals\n[\n  patchesWithElevationData\n  noElevationDataTag\n  maxElevation\n\n  width\n  height\n\n  ;;; GIS data holders\n  sitesData_EMIII-MMIA\n  sitesData_MMIB\n  elevationData\n  riversData\n\n  ...\n]\n\nsites-own\n[\n  name\n  siteType\n  period\n]\n\npatches-own\n[\n  elevation ; elevation above sea level [m]\n\n  flow_direction        ; the numeric code for the (main) direction of flow or\n                        ; drainage within the land unit.\n                        ; Following Jenson & Domingue (1988) convention:\n                        ; NW = 64,   N = 128,        NE = 1,\n                        ; W = 32,     &lt;CENTRE&gt;,   E = 2,\n                        ; SW = 16,     S = 8,          SE = 4\n\n  flow_receive          ; Boolean variable stating whether or not the land unit receives\n                        ; the flow of a neighbour.\n\n  flow_accumulation     ; the amount of flow units accumulated in the land unit.\n                        ; A Flow unit is the volume of runoff water flowing from one land unit\n                        ; to another (assumed constant and without losses).\n  flow_accumulationState ; the state of the land unit regarding the calculation of flow\n                        ; accumulation (auxiliary variable).\n\n  isRiver\n\n  ...\n]\n\n...\n\n\nto import-map-with-flows\n  \n  import-world \"data/terrainWithFlows/BlockC_module2_flows world.csv\"\n  \n  ;;; reduce patch size in pixels\n  set-patch-size 3\n  \nend\n\n...",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#visualisation",
    "href": "messara-soil-water.html#visualisation",
    "title": "27  Integrating a submodel",
    "section": "27.6 Visualisation",
    "text": "27.6 Visualisation\nBefore advancing, we can implement a display procedure expanding it also to be able to paint patches according to the new patch variables, using the “chooser” parameter display-mode:\n\nto refresh-view\n  \n  if (display-mode = \"elevation\")\n  [\n    ask patchesWithElevationData [ display-elevation ]\n  ]\n\n  if (display-mode = \"albedo\")\n  [\n    ask patchesWithElevationData [ display-albedo ]\n  ]\n\n  if (display-mode = \"ETr\")\n  [\n    let maxETr max [ETr] of patchesWithElevationData\n    ask patchesWithElevationData [ display-ETr maxETr ]\n  ]\n\n  if (display-mode = \"drainage coefficient (DC)\")\n  [\n    ask patchesWithElevationData [ display-DC ]\n  ]\n\n  if (display-mode = \"root zone depth (z)\")\n  [\n    let maxZ max [z] of patchesWithElevationData\n    ask patchesWithElevationData [ display-z maxZ ]\n  ]\n\n  if (display-mode = \"runoff curve number (CN)\")\n  [\n    let maxCN max [CN] of patchesWithElevationData\n    ask patchesWithElevationData [ display-CN maxCN ]\n  ]\n\n  if (display-mode = \"water content at field capacity (FC)\")\n  [\n    let maxFC max [FC] of patchesWithElevationData\n    ask patchesWithElevationData [ display-FC maxFC ]\n  ]\n\n  if (display-mode = \"water holding Capacity (WHC)\")\n  [\n    let maxWHC max [WHC] of patchesWithElevationData\n    ask patchesWithElevationData [ display-WHC maxWHC ]\n  ]\n\n  if (display-mode = \"soil water content (WATp)\")\n  [\n    let maxWATp max [WATp] of patchesWithElevationData\n    ask patchesWithElevationData [ display-WATp maxWATp ]\n  ]\n\n  if (display-mode = \"ARID coefficient\")\n  [\n    ask patchesWithElevationData [ display-arid ]\n  ]\n\nend\n\nto display-elevation\n\n  let elevationGradient 100 + (155 * (elevation / maxElevation))\n  set pcolor rgb (elevationGradient - 100) elevationGradient 0\n\nend\n\nto display-albedo\n\n  set pcolor 1 + 9 * albedo\n\nend\n\nto display-ETr [ maxETr ]\n\n  ifelse (maxETr = 0)\n  [ set pcolor 25 ]\n  [ set pcolor 22 + 6 * (1 - ETr / maxETr) ]\n\nend\n\nto display-DC\n\n  set pcolor 112 + 6 * (1 - DC)\n\nend\n\nto display-z [ maxZ ]\n\n  set pcolor 42 + 8 * (1 - z / maxZ)\n\nend\n\nto display-CN [ maxCN ]\n\n  set pcolor 72 + 6 * (1 - CN / maxCN)\n\nend\n\nto display-FC [ maxFC ]\n\n  set pcolor 82 + 6 * (1 - FC / maxFC)\n\nend\n\nto display-WHC [ maxWHC ]\n\n  set pcolor 92 + 6 * (1 - WHC / maxWHC)\n\nend\n\nto display-WATp [ maxWATp ]\n\n  set pcolor 102 + 6 * (1 - WATp / maxWATp)\n\nend\n\nto display-ARID\n\n  set pcolor 12 + 6 * ARID\n\nend",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#combining-with-flow-accumulation-algorithm",
    "href": "messara-soil-water.html#combining-with-flow-accumulation-algorithm",
    "title": "27  Integrating a submodel",
    "section": "27.7 Combining with flow accumulation algorithm",
    "text": "27.7 Combining with flow accumulation algorithm\nLast, we finalise this module by implementing a solution that uses flow_accumulation to modulate the variation in ARID, as a proxy of the effect of the regional hydrology on the local soil water balance. The solution use the patch variable ARID_modifier, set during setup according to the parameter ARID-decrease-per-flow-accumulation and the local relative flow accumulation (flow_accumulation / maxFlowAccumulation). It then modifies ARID each day as a simple scalar.\npatches-own\n[\n  ...\n\n  ARID_modifier ; modifier coefficient based on the relative value of flow_accumulation\n]\n\n...\n\nto setup\n\n  clear-all\n\n  ; --- loading/testing parameters -----------\n\n  import-map-with-flows ; import-world must be the first step\n\n  set-constants\n\n  set-parameters\n\n  setup-patches\n\n  ; --- core procedures ----------------------\n\n  set currentYear weatherInputData_firstYear\n  set currentDayOfYear 1\n\n  ;;; values are taken from input data\n  set-day-weather-from-input-data currentDayOfYear currentYear\n\n  ask patchesWithElevationData [ update-WAT ]\n\n  ; --- display & output handling ------------------------\n\n  refresh-view\n\n  ; -- time -------------------------------------\n\n  reset-ticks\n\nend\n\n...\n\nto setup-patches\n\n  setup-soil-water-properties\n  \n  setup-ARID-modifier\n\nend\n\n...\n\nto setup-ARID-modifier\n  \n  ask patchesWithElevationData\n  [\n    set ARID_modifier (1 - ARID-decrease-per-flow-accumulation * (flow_accumulation / maxFlowAccumulation))\n  ]\n  \nend\n\n...\n\nto go\n\n  ; --- core procedures -------------------------\n\n  ;;; values are taken from input data\n  set-day-weather-from-input-data currentDayOfYear currentYear\n\n  ask patchesWithElevationData [ update-WAT modify-ARID ]\n\n  ; --- output handling ------------------------\n\n  refresh-view\n\n  ; -- time -------------------------------------\n\n  advance-time\n\n  tick\n\n  ; --- stop conditions -------------------------\n\n  if (currentYear = weatherInputData_lastYear and currentDayOfYear = last weatherInputData_yearLengthInDays) [stop]\n\nend\n\n...\n\nto modify-ARID\n\n  set ARID ARID * ARID_modifier\n\nend",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-soil-water.html#test",
    "href": "messara-soil-water.html#test",
    "title": "27  Integrating a submodel",
    "section": "27.8 Test",
    "text": "27.8 Test\nOur solution to link flow_accumulation and ARID is undoubtedly arbitrary. Such solutions should always be temporary and prompt further research and coding excursions. For the tutorial, however, we are good enough to go forward.\n\nScreenshot of the ‘ARID’ module (tick 100)\n\nScreenshot of the ‘ARID’ module (tick 150)\n\nScreenshot of the ‘ARID’ module (tick 200)\nSee the fully implemented version of this module: BlockC_module3_ARID.nlogo.",
    "crumbs": [
      "Messara Trade (II): time-series input data and plugging modules",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Integrating a submodel</span>"
    ]
  },
  {
    "objectID": "messara-routes.html",
    "href": "messara-routes.html",
    "title": "28  Scaling up route calculation",
    "section": "",
    "text": "28.1 Adapting A* to use a path cost gradient\nBefore finally implementing a grounded productivity in Pond Trade, we must stop and consider the consequences of applying A* to a quite different terrain.\nFirst and most obviously, unlike our initial “pond” terrain, the GIS data we are using has no water patches and land patches have different elevation values. We went from having a binary height map (land/water) to a continuous height map strictly covering dry land.\nWe adapt the original implementation of assign-path-cost to handle elevation values in a more refined way. We will use a simple approach that equates the path cost in a patch to the standard deviation of the elevation of all neighbours and of itself. This gives the algorithm a rough notion of terrain roughness, awarding those plain sectors of terrain with the least path cost for routes.\nAnother, possibly more rigorous, solution would be to precalculate routes from a least path cost analysis using specialised GIS software and import it as a GIS dataset.",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Scaling up route calculation</span>"
    ]
  },
  {
    "objectID": "messara-routes.html#adapting-a-to-use-a-path-cost-gradient",
    "href": "messara-routes.html#adapting-a-to-use-a-path-cost-gradient",
    "title": "28  Scaling up route calculation",
    "section": "",
    "text": "to assign-path-cost\n\n  ask patches with [elevation = noElevationDataTag] [ set pathCost 9999 ] ;;; this makes routes crossing patches with no elevation data extremely unlikely\n\n  ask patchesWithElevationData\n  [\n    let myValidNeighborsAndI (patch-set self (neighbors with [elevation &gt; noElevationDataTag]))\n\n    ifelse (count myValidNeighborsAndI &gt; 1)\n    [\n      set pathCost standard-deviation [elevation] of myValidNeighborsAndI\n    ]\n    [\n      set pathCost 1\n    ]\n  ]\n\nend",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Scaling up route calculation</span>"
    ]
  },
  {
    "objectID": "messara-routes.html#implementing-file-export-import-procedures-a-solution-to-handle-a-larger-grid",
    "href": "messara-routes.html#implementing-file-export-import-procedures-a-solution-to-handle-a-larger-grid",
    "title": "28  Scaling up route calculation",
    "section": "28.2 Implementing file export-import procedures: a solution to handle a larger grid",
    "text": "28.2 Implementing file export-import procedures: a solution to handle a larger grid\nWith the large size of the map and the higher number of settlements, we expect A* calculation of routes to take significant computation time. For this reason, we are highly motivated to make of route calculation the subject of a module, which is able to export the variable routes to a file that can be stored and imported later.\nAs we are already using export-world to save our height map with flows, we implement procedures that can manage the export and import of the routes variable specifically.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;; DATA LOAD AND PREPARATION ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\nto export-routes-to-file\n\n  ;;; build a unique file name to identify current setting\n  let filePath (word \"data/routes/routes_\" simulation-period \"_w=\" world-width \"_h=\" world-height \"_randomSeed=\" randomSeed \".txt\")\n\n  file-open filePath\n\n  foreach routes\n  [\n    aRoute -&gt;\n\n    file-print aRoute\n  ]\n\n  file-close\n\nend\n\nto import-routes-from-file\n\n  ;;; get unique file name corresponding to the current setting\n  let filePath (word \"data/routes/routes_\" simulation-period \"_w=\" world-width \"_h=\" world-height \"_randomSeed=0.txt\")\n\n  ifelse (not file-exists? filePath)\n  [ print (word \"WARNING: could not find '\" filePath \"'\") stop ] ;;; unfortunately the stop command doesn't stop the setup procedure\n  [\n    file-open filePath\n\n    set routes []\n\n    while [not file-at-end?]\n    [\n      let lineString file-read-line\n      set lineString remove-item 0 lineString\n      set lineString remove-item (length lineString - 1) lineString\n      set lineString (word \"(list \" lineString \" )\")\n\n      set routes lput (run-result lineString) routes\n    ]\n  ]\n\n  file-close\n\nend",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Scaling up route calculation</span>"
    ]
  },
  {
    "objectID": "messara-routes.html#run-and-export-routes",
    "href": "messara-routes.html#run-and-export-routes",
    "title": "28  Scaling up route calculation",
    "section": "28.3 Run and export routes",
    "text": "28.3 Run and export routes\nIf you wish to test this step, you may now execute setup and export-routes-to-file using the sites of each period (simulation-period). Because the routes file is already present in the repository, a test must be executed with import-routes switched off. Beware, the process can take hours. If you started the process and want to stop it, go to “Tools &gt; Halt”.\nAlternatively, you may simply execute setup with import-routes switched on, and visualise the routes calculated for each pair of sites in each period. This should take around 1-2 minutes.\n\nScreenshot of the ‘routes’ module displaying routes between EMIII-MMIA sites\n\nScreenshot of the ‘routes’ module displaying routes between MMIB sites\nRelying on the tint of routes, we can immediately see that most paths are used by more than one route (bright red), which could be hinting a relatively stable road structure. A more interesting, but less obvious insight is that",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Scaling up route calculation</span>"
    ]
  },
  {
    "objectID": "messara-routes.html#conclusion",
    "href": "messara-routes.html#conclusion",
    "title": "28  Scaling up route calculation",
    "section": "28.4 Conclusion",
    "text": "28.4 Conclusion\nNote that the routes calculated with our implementation of A* generally agrees with Paliou and Bevan (Paliou and Bevan 2016) analysis using other techniques. Routes are distinctively different between periods, with a minimal overlap during the Prepalatial (EMIII-MMIA) period and the Protopalatial (MMIB) period marked with a much higher centrality in the lower valley, where Phaistos is located.\nHowever, do remember that this result is obtained only by combining elevation and site distributions using a least path cost algorithm. A* is a procedural algorithm, which contains explicative elements, but is not a simulation in the strict sense (i.e. the aim is finding an optimal path, not the representation of real instance of path walking). We are yet to observe what effects the Pond Trade mechanism have over the economical size of each site, given the routes available in each period.\n\n\n\n\nPaliou, Eleftheria, and Andrew Bevan. 2016. “Evolving Settlement Patterns, Spatial Interaction and the Socio-Political Organisation of Late Prepalatial South-Central Crete.” Journal of Anthropological Archaeology 42 (June): 184–97. https://doi.org/10.1016/j.jaa.2016.04.006.",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Scaling up route calculation</span>"
    ]
  },
  {
    "objectID": "messara-integrations.html",
    "href": "messara-integrations.html",
    "title": "29  Integrating complex submodels",
    "section": "",
    "text": "29.1 Integrating module 4 (ARID) and 5 (routes)\nFinally, after much of the modelling equivalent of blood and sweat, we reach the point where we can combine the contribution of all our modules with the full implementation of the Pond Trade model (step 13).\nWe use module 4 - ARID as the starting template and add import-routes-from-file and all route related procedures. We should be able to import the routes data saved before and load it during set up, as the last step before setup-patches:",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Integrating complex submodels</span>"
    ]
  },
  {
    "objectID": "messara-integrations.html#integrating-module-4-arid-and-5-routes",
    "href": "messara-integrations.html#integrating-module-4-arid-and-5-routes",
    "title": "29  Integrating complex submodels",
    "section": "",
    "text": "globals\n[\n  ...\n\n  routes\n\n  ...\n]\n\n...\n\nto setup\n\n  clear-all\n\n  ; --- loading/testing parameters -----------\n\n  import-map-with-flows ; import-world must be the first step\n\n  set-constants\n\n  set-parameters\n\n  import-routes-from-file\n\n  ; --- core procedures ----------------------\n\n  set currentYear weatherInputData_firstYear\n  set currentDayOfYear 1\n\n  ;;; values are taken from input data\n  set-day-weather-from-input-data currentDayOfYear currentYear\n\n  ask patchesWithElevationData [ update-WAT ]\n\n  ; --- display & output handling ------------------------\n\n  update-output\n  \n  refresh-view\n\n  paint-routes\n\n  ; -- time -------------------------------------\n\n  reset-ticks\n\nend\n\n...\n\nto refresh-view\n\n  ...\n\n  paint-routes\n  paint-active-routes\n\nend\n\n\nto paint-routes\n\n  ;;; define list of shades of red in NetLogo\n  let redShades (list 11 12 13 14 15 16 17 18 19)\n  ;;; NOTE: this is needed because rgb colors based on elevation are a list\n  ;;; while NetLogo color are numbers\n\n  ; resets route patches to the terrain color\n  foreach routes\n  [ ?1 -&gt;\n    let aRoute ?1\n\n    foreach aRoute\n    [ ??1 -&gt;\n      ask ??1 [ display-elevation ]\n    ]\n  ]\n\n  ; paint route patches in shades of red depending on route frequency\n  foreach routes\n  [ ?1 -&gt;\n    let aRoute ?1\n\n    foreach aRoute\n    [ ??1 -&gt;\n      ask ??1\n      [\n        if (showRoutes)\n        [\n          ifelse (not member? pcolor redShades) ; if its the first route crossing the patch\n          [\n            set pcolor 11\n          ]\n          [\n            set pcolor min (list (pcolor + 1) (19)) ; sets a maximum at 19 (the brightest)\n          ]\n        ]\n      ]\n    ]\n  ]\n\nend\n\nto paint-active-routes\n\n  ask traders\n  [\n    foreach route\n    [ ?1 -&gt;\n      ask ?1\n      [\n        ifelse (showActiveRoutes)\n        [\n          set pcolor yellow\n        ]\n        [\n          if (not showRoutes) ; if not displaying all routes\n          [\n            ; resets to the patch terrain color\n            display-elevation\n          ]\n        ]\n      ]\n    ]\n  ]\n\nend",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Integrating complex submodels</span>"
    ]
  },
  {
    "objectID": "messara-integrations.html#integrating-pond-trade-step-13",
    "href": "messara-integrations.html#integrating-pond-trade-step-13",
    "title": "29  Integrating complex submodels",
    "section": "29.2 Integrating Pond Trade (step 13)",
    "text": "29.2 Integrating Pond Trade (step 13)\nNext, we bring all the extra code and interface objects present in Pond Trade (step 13). Most procedures require no modifications. The exceptions are:\n\nThere is no isLand variable here and, given that there is no water patches, we should simply erase the code that distinguishes it.\nSince there is only land patches and we are using the standard deviation of elevations to assign pathCost, there are no relativePathCostInLand or relativePathCostInPort. We can erase all reference to these two parameters, which will leave the corresponding cultural traits of transport technology as the sole modifiers of pathCost.\n\nWe carefully organise the scheduling of calls in setup and go:\nto setup\n\n  clear-all\n  reset-ticks\n\n  ; set the random seed so we can reproduce the same experiment\n  random-seed seed\n  set patchesCount count patches\n\n  create-map\n\n  create-coastal-settlements\n\n  set-routes\n\n  create-traders-per-settlement\n\n  update-output\n\n  update-display\n\n  update-plots\n\nend\n\n...\n\nto go\n\n  tick\n\n  if (ticks = 10000 or count turtles &gt; 500) [ stop ]\n\n  update-traders\n\n  update-settlements\n\n  update-output\n\n  update-display\n\nend",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Integrating complex submodels</span>"
    ]
  },
  {
    "objectID": "messara-integrations.html#extension-arid-as-a-factor-of-settlement-productivity",
    "href": "messara-integrations.html#extension-arid-as-a-factor-of-settlement-productivity",
    "title": "29  Integrating complex submodels",
    "section": "29.3 Extension: ARID as a factor of settlement productivity",
    "text": "29.3 Extension: ARID as a factor of settlement productivity\nLast, we need to connect ARID to settlement productivity.\nWe first calculate the value of two new settlement variables, catchmentArea and ARIDinCatchmentArea. The latter is the average ARID within the settlement catchment area. In turn, the catchment area is calculated using a gradient decay function, dependent on sizeLevel and two parameters, catchmentSlope and catchmentRadiusMaximum. This is a very preliminary solution, but will suffice for us to observe the dynamics of Pond Trade playing out over the Mesara Valley.\nsettlements-own\n[\n  ...\n  catchmentArea\n  ARIDinCatchmentArea\n]\n\n...\n\nto update-ARIDinCatchmentArea\n  \n  let patchesInCatchmentArea patches in-radius catchmentArea\n  \n  ifelse (count patchesInCatchmentArea = 1)\n  [ set ARIDinCatchmentArea [ARID] of patch-here ]\n  [ set ARIDinCatchmentArea mean [ARID] of patchesInCatchmentArea]\n  \nend\n\nto update-catchmentArea\n  \n  set catchmentArea get-value-in-gradient sizeLevel catchmentSlope catchmentRadiusMaximum\n  \nend\n\nto-report get-value-in-gradient [ input gradient maximum ]\n\n  report e ^ ( - input / ((gradient / 100) * maximum) )\n\nend\nAnd voilà! We can now run our boosted Pond Trade model within the context of our case study.\n\nView of MesaraTrade after set up\n\nView of MesaraTrade interface",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Integrating complex submodels</span>"
    ]
  },
  {
    "objectID": "messara-verification-and-improvement.html",
    "href": "messara-verification-and-improvement.html",
    "title": "30  Verifying and improving",
    "section": "",
    "text": "30.1 Margins to improve and explore\nThere are many other points to refactor, explore alternatives and expand. Just remember to first give it a think and then start writing code.\nFor example:\n- Can we visualise catchmentArea of settlements in the NetLogo View, instead of sizeLevel? - Could we find a way to calibrate the speed of traders to the same daily rhythm of the weather variables?\n- Could rivers also affect patchCost?",
    "crumbs": [
      "Messara Trade (III): integrating complex parts",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Verifying and improving</span>"
    ]
  },
  {
    "objectID": "sim-behavior-space.html",
    "href": "sim-behavior-space.html",
    "title": "31  Using NetLogo’s Behaviour Space",
    "section": "",
    "text": "31.1 Introduction",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Using NetLogo's Behaviour Space</span>"
    ]
  },
  {
    "objectID": "sim-behavior-space.html#introduction",
    "href": "sim-behavior-space.html#introduction",
    "title": "31  Using NetLogo’s Behaviour Space",
    "section": "",
    "text": "⚙️ Model setup: NetLogo model ready\n        ↓\n🎛️ Define experiment: BehaviorSpace parameters & setting\n        ↓\n▶️ Run experiments: Multiple model runs with varied parameters\n        ↓\n💾 Export results: CSV output files\n        ↓\n📊 Analyse results: R scripts for plots & statistics\n        ↓\n🧩 Interpret results: Compare to hypotheses or data\n        ↺\n🔁 Refine model or experiment: Adjust parameters, mechanisms",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Using NetLogo's Behaviour Space</span>"
    ]
  },
  {
    "objectID": "sim-behavior-space.html#single-simulation-run",
    "href": "sim-behavior-space.html#single-simulation-run",
    "title": "31  Using NetLogo’s Behaviour Space",
    "section": "31.2 Single simulation run",
    "text": "31.2 Single simulation run",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Using NetLogo's Behaviour Space</span>"
    ]
  },
  {
    "objectID": "sim-behavior-space.html#repetitions-under-the-same-parameter-configuration",
    "href": "sim-behavior-space.html#repetitions-under-the-same-parameter-configuration",
    "title": "31  Using NetLogo’s Behaviour Space",
    "section": "31.3 Repetitions under the same parameter configuration",
    "text": "31.3 Repetitions under the same parameter configuration",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Using NetLogo's Behaviour Space</span>"
    ]
  },
  {
    "objectID": "sim-behavior-space.html#varying-parameters",
    "href": "sim-behavior-space.html#varying-parameters",
    "title": "31  Using NetLogo’s Behaviour Space",
    "section": "31.4 Varying parameters",
    "text": "31.4 Varying parameters",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Using NetLogo's Behaviour Space</span>"
    ]
  },
  {
    "objectID": "sim-behavior-space.html#selecting-output-variables",
    "href": "sim-behavior-space.html#selecting-output-variables",
    "title": "31  Using NetLogo’s Behaviour Space",
    "section": "31.5 selecting output variables",
    "text": "31.5 selecting output variables",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Using NetLogo's Behaviour Space</span>"
    ]
  },
  {
    "objectID": "sim-behavior-space.html#advanced-workflows",
    "href": "sim-behavior-space.html#advanced-workflows",
    "title": "31  Using NetLogo’s Behaviour Space",
    "section": "31.6 Advanced workflows",
    "text": "31.6 Advanced workflows\n\n31.6.1 Using special procedures\n\n\n31.6.2 output extra files\n\n\n31.6.3 Running settings from file",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Using NetLogo's Behaviour Space</span>"
    ]
  },
  {
    "objectID": "sim-param-exploration.html",
    "href": "sim-param-exploration.html",
    "title": "32  Simulation experiments for parameter exploration",
    "section": "",
    "text": "32.1 Different parameter configurations",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Simulation experiments for parameter exploration</span>"
    ]
  },
  {
    "objectID": "sim-param-exploration.html#alternative-designs",
    "href": "sim-param-exploration.html#alternative-designs",
    "title": "32  Simulation experiments for parameter exploration",
    "section": "32.2 Alternative designs",
    "text": "32.2 Alternative designs",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Simulation experiments for parameter exploration</span>"
    ]
  },
  {
    "objectID": "sim-param-exploration.html#stochastic-exploration-for-sensitivity-analysis",
    "href": "sim-param-exploration.html#stochastic-exploration-for-sensitivity-analysis",
    "title": "32  Simulation experiments for parameter exploration",
    "section": "32.3 Stochastic exploration for sensitivity analysis",
    "text": "32.3 Stochastic exploration for sensitivity analysis\nTo perform sensitivity analysis in a simulation model, we need to sample parameter values more efficiently than using regular intervals. There are three common sampling methods: Random Sampling, Latin Hypercube Sampling (LHS), and Sobol Sampling. Below is an explanation of how to obtain parameter samples using each method in R.\n\n32.3.1 Random Sampling\nRandom sampling is the simplest method, where parameter values are drawn independently from a given probability distribution (e.g., uniform, normal). This method may not cover the parameter space as efficiently as structured sampling methods.\nImplementation in R\nset.seed(123)  # For reproducibility\nn &lt;- 100  # Number of samples\nparam1 &lt;- runif(n, min = 0, max = 1)  # Uniform distribution\nparam2 &lt;- rnorm(n, mean = 0, sd = 1)  # Normal distribution\n\n# Combine into a data frame\nsamples_random &lt;- data.frame(param1, param2)\nhead(samples_random)\n📌 Pros: Simple and easy to implement\n📌 Cons: Potential clustering of samples, leading to inefficient coverage of the parameter space.\n\n\n32.3.2 Latin Hypercube Sampling (LHS)\nLatin Hypercube Sampling ensures that each parameter is sampled more uniformly across its range. It divides the range of each parameter into equal intervals and ensures that each interval is sampled exactly once (Chalom and Prado 2015).\nImplementation in R Using the lhs package:\nlibrary(lhs)\nset.seed(123)\nn &lt;- 100  # Number of samples\nk &lt;- 2  # Number of parameters\n\n# Generate LHS sample in [0,1] range\nsamples_lhs &lt;- randomLHS(n, k)\n\n# Transform to specific distributions\nparam1 &lt;- qunif(samples_lhs[,1], min = 0, max = 1)  # Uniform\nparam2 &lt;- qnorm(samples_lhs[,2], mean = 0, sd = 1)  # Normal\n\n# Combine into a data frame\nsamples_lhs &lt;- data.frame(param1, param2)\nhead(samples_lhs)\n📌 Pros: More uniform coverage of the space than random sampling\n📌 Cons: Does not account for interactions between parameters explicitly\n\n\n32.3.3 Sobol Sampling\nSobol sampling is a quasi-random low-discrepancy sequence designed for global sensitivity analysis. It provides better uniformity across the space than both random and LHS methods (Renardy et al. 2021).\nImplementation in R Using the randtoolbox package:\nlibrary(randtoolbox)\nset.seed(123)\nn &lt;- 100  # Number of samples\nk &lt;- 2  # Number of parameters\n\n# Generate Sobol sequence\nsamples_sobol &lt;- sobol(n, dim = k, scrambling = 3)\n\n# Transform to specific distributions\nparam1 &lt;- qunif(samples_sobol[,1], min = 0, max = 1)  # Uniform\nparam2 &lt;- qnorm(samples_sobol[,2], mean = 0, sd = 1)  # Normal\n\n# Combine into a data frame\nsamples_sobol &lt;- data.frame(param1, param2)\nhead(samples_sobol)\n📌 Pros: Highly efficient, low-discrepancy sequence for sensitivity analysis\n📌 Cons: Requires specialized libraries, and might not be ideal for small sample sizes\n\n\n32.3.4 Comparison of Methods\n\n\n\n\n\n\n\n\n\nSampling Method\nUniform Coverage\nComputational Efficiency\nBest Use Case\n\n\n\n\nRandom\nPoor\nFast\nBasic sensitivity analysis\n\n\nLatin Hypercube (LHS)\nGood\nModerate\nOptimized space-filling with no interaction control\n\n\nSobol\nExcellent\nModerate\nGlobal sensitivity analysis\n\n\n\n\n\n32.3.5 Conclusion\n\nUse random sampling when simplicity is preferred.\n\nUse LHS when uniform coverage of individual parameters is important.\n\nUse Sobol sampling for high-dimensional sensitivity analysis.\n\n\n\n\n\nChalom, André, and Paulo Inácio de Knegt López de Prado. 2015. “Parameter Space Exploration of Ecological Models.” arXiv. https://doi.org/10.48550/arXiv.1210.6278.\n\n\nRenardy, Marissa, Louis R. Joslyn, Jess A. Millar, and Denise E. Kirschner. 2021. “To Sobol or Not to Sobol? The Effects of Sampling Schemes in Systems Biology Applications.” Mathematical Biosciences 337 (July): 108593. https://doi.org/10.1016/j.mbs.2021.108593.",
    "crumbs": [
      "Designing and running Simulation experiments",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Simulation experiments for parameter exploration</span>"
    ]
  },
  {
    "objectID": "analysis-preprocessing.html",
    "href": "analysis-preprocessing.html",
    "title": "34  Loading and preparing simulation results",
    "section": "",
    "text": "34.1 📊 Analysis Pipeline for Simulation Results",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Loading and preparing simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-preprocessing.html#analysis-pipeline-for-simulation-results",
    "href": "analysis-preprocessing.html#analysis-pipeline-for-simulation-results",
    "title": "34  Loading and preparing simulation results",
    "section": "",
    "text": "💾 Simulation outputs: BehaviorSpace CSV files\n        ↓\n📥 Import data: R, tidyverse\n        ↓\n🧹 Clean & prepare: Data wrangling, filtering, reshaping\n        ↓\n📈 Explore: Descriptive plots, distributions, correlations\n        ↓\n📊 Analyse: Statistical models, sensitivity analysis\n        ↓\n🖼️ Visualise: Publication-ready plots, dashboard\n        ↓\n🧩 Interpret: Compare with hypotheses, archaeological data\n        ↓\n📘 Report & share: RMarkdown, GitHub, Zenodo DOI\n        ↺\n🔁 Refine model or experiment design",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Loading and preparing simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-preprocessing.html#setting-up-our-script-environment",
    "href": "analysis-preprocessing.html#setting-up-our-script-environment",
    "title": "34  Loading and preparing simulation results",
    "section": "34.2 Setting up our script environment",
    "text": "34.2 Setting up our script environment\n\nlibrary(ggplot2)\nlibrary(readr)\n\n\nexperiments_path &lt;- \"assets/netlogo/experiments/Artificial Anasazi_experiments \"\n\n\ncolor_mapping &lt;- c(\"historical households\" = \"blue\", \n                   \"simulation households\" = \"darkred\")",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Loading and preparing simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-preprocessing.html#single-run",
    "href": "analysis-preprocessing.html#single-run",
    "title": "34  Loading and preparing simulation results",
    "section": "34.3 Single run",
    "text": "34.3 Single run\n\nexpname &lt;- \"experiment single run\"\n\nRead output:\n\nresults_single &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 552 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nPlot trajectories of metrics:\n\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_single) +  \n  geom_line(aes(x = `[step]`, y = `historical-total-households`, color = \"historical data\"),\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `total-households`, color = \"simulation households\"),\n            linewidth = 1.2) +\n  labs(x = \"steps\", y = \"households\") +\n  scale_color_manual(name = \"\", values = color_mapping) +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2 \n\n\n\nknitr::include_graphics(plot_name)",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Loading and preparing simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-preprocessing.html#multiple-runs-in-single-configuration",
    "href": "analysis-preprocessing.html#multiple-runs-in-single-configuration",
    "title": "34  Loading and preparing simulation results",
    "section": "34.4 Multiple runs in single configuration",
    "text": "34.4 Multiple runs in single configuration\n\nexpname &lt;- \"experiment multiple runs\"\n\nRead output:\n\nresults_single &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 5520 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nPlot trajectories of metrics:\n\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_single) +  \n  geom_line(aes(x = `[step]`, y = `total-households`, color = `[run number]`, group = `[run number]`),\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `historical-total-households`), \n            color = color_mapping[\"historical households\"],\n            linewidth = 1.2, linetype = 2) +\n  labs(x = \"steps\", y = \"households\") +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2 \n\n\n\nknitr::include_graphics(plot_name)",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Loading and preparing simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-preprocessing.html#parameter-exploration---regular-intervals",
    "href": "analysis-preprocessing.html#parameter-exploration---regular-intervals",
    "title": "34  Loading and preparing simulation results",
    "section": "34.5 Parameter exploration - regular intervals",
    "text": "34.5 Parameter exploration - regular intervals\n\n34.5.1 One parameter\n\nexpname &lt;- \"experiment harvest adjustment\"\n\nRead output:\n\nresults_harvest_adj &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 104880 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nPlot trajectories of metrics:\n\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_harvest_adj) +  \n  geom_line(aes(x = `[step]`, y = `total-households`, color = `harvest-adjustment`, group = `[run number]`),\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `historical-total-households`), color = \"black\",\n            linewidth = 1.2, linetype = 2) +\n  labs(x = \"steps\", y = \"households\") +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2 \n\n\n\nknitr::include_graphics(plot_name)\n\n\n\n\n\n\n\n\n\n\n34.5.2 Two parameter\n\nexpname &lt;- \"experiment harvest adjustment variance\"\n\nRead output:\n\nresults_harvest_adj &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 441600 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nPlot trajectories of metrics:\n\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_harvest_adj) +  \n  geom_line(aes(x = `[step]`, y = `total-households`, group = `[run number]`),\n            color = color_mapping[\"simulation households\"],\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `historical-total-households`), \n            color = color_mapping[\"historical households\"],\n            linewidth = 1.2, linetype = 2) +\n  facet_grid(`harvest-adjustment` ~ `harvest-variance`) +\n  labs(x = \"steps\", y = \"households\") +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2 \n\n\n\nknitr::include_graphics(plot_name)",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Loading and preparing simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-visualisation.html",
    "href": "analysis-visualisation.html",
    "title": "35  Visualisation of simulation results",
    "section": "",
    "text": "35.1 Single run\nexpname &lt;- \"experiment single run\"\nRead output:\nresults_single &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 552 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nPlot trajectories of metrics:\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_single) +  \n  geom_line(aes(x = `[step]`, y = `historical-total-households`, color = \"historical data\"),\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `total-households`, color = \"simulation households\"),\n            linewidth = 1.2) +\n  labs(x = \"steps\", y = \"households\") +\n  scale_color_manual(name = \"\", values = color_mapping) +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2\nknitr::include_graphics(plot_name)",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Visualisation of simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-visualisation.html#multiple-runs-in-single-configuration",
    "href": "analysis-visualisation.html#multiple-runs-in-single-configuration",
    "title": "35  Visualisation of simulation results",
    "section": "35.2 Multiple runs in single configuration",
    "text": "35.2 Multiple runs in single configuration\n\nexpname &lt;- \"experiment multiple runs\"\n\nRead output:\n\nresults_single &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 5520 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nPlot trajectories of metrics:\n\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_single) +  \n  geom_line(aes(x = `[step]`, y = `total-households`, color = `[run number]`, group = `[run number]`),\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `historical-total-households`), \n            color = color_mapping[\"historical households\"],\n            linewidth = 1.2, linetype = 2) +\n  labs(x = \"steps\", y = \"households\") +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2 \n\n\n\nknitr::include_graphics(plot_name)",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Visualisation of simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-visualisation.html#parameter-exploration---regular-intervals",
    "href": "analysis-visualisation.html#parameter-exploration---regular-intervals",
    "title": "35  Visualisation of simulation results",
    "section": "35.3 Parameter exploration - regular intervals",
    "text": "35.3 Parameter exploration - regular intervals\n\n35.3.1 One parameter\n\nexpname &lt;- \"experiment harvest adjustment\"\n\nRead output:\n\nresults_harvest_adj &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 104880 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nPlot trajectories of metrics:\n\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_harvest_adj) +  \n  geom_line(aes(x = `[step]`, y = `total-households`, color = `harvest-adjustment`, group = `[run number]`),\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `historical-total-households`), color = \"black\",\n            linewidth = 1.2, linetype = 2) +\n  labs(x = \"steps\", y = \"households\") +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2 \n\n\n\nknitr::include_graphics(plot_name)\n\n\n\n\n\n\n\n\n\n\n35.3.2 Two parameter\n\nexpname &lt;- \"experiment harvest adjustment variance\"\n\nRead output:\n\nresults_harvest_adj &lt;- readr::read_csv(paste0(experiments_path, expname, \"-table.csv\"), skip = 6)\n\nRows: 441600 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): map-view\ndbl (9): [run number], fertility, death-age, harvest-variance, fertility-end...\nlgl (1): historic-view?\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nPlot trajectories of metrics:\n\nplot_name &lt;- paste0(experiments_path, expname, \"-trajectories.png\")\n\npng(plot_name, width = 840, height = 540)\n\nggplot(results_harvest_adj) +  \n  geom_line(aes(x = `[step]`, y = `total-households`, group = `[run number]`),\n            color = color_mapping[\"simulation households\"],\n            linewidth = 1.2) +\n  geom_line(aes(x = `[step]`, y = `historical-total-households`), \n            color = color_mapping[\"historical households\"],\n            linewidth = 1.2, linetype = 2) +\n  facet_grid(`harvest-adjustment` ~ `harvest-variance`) +\n  labs(x = \"steps\", y = \"households\") +\n  theme(legend.position = \"right\")\n\ndev.off()\n\nsvg \n  2 \n\n\n\nknitr::include_graphics(plot_name)",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Visualisation of simulation results</span>"
    ]
  },
  {
    "objectID": "analysis-sensitivity-analysis.html",
    "href": "analysis-sensitivity-analysis.html",
    "title": "36  Sensitivity analysis of simulation models",
    "section": "",
    "text": "36.1 Bifurcation plots",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Sensitivity analysis of simulation models</span>"
    ]
  },
  {
    "objectID": "analysis-sensitivity-analysis.html#use-of-machine-learning-for-sensitivity-analysis",
    "href": "analysis-sensitivity-analysis.html#use-of-machine-learning-for-sensitivity-analysis",
    "title": "36  Sensitivity analysis of simulation models",
    "section": "36.2 Use of machine learning for sensitivity analysis",
    "text": "36.2 Use of machine learning for sensitivity analysis\nTo evaluate the importance of each parameter in a simulation model, Random Forest (RF) can be used as a feature importance estimator. This involves training an RF model on simulation results and then analyzing the impact of each input parameter on the output.\n\n36.2.1 Step-by-Step Guide to Using Random Forest for Parameter Importance\n1. Generate Simulation Data The first step is to generate simulation results by systematically sampling multiple parameters using methods like Random Sampling, Latin Hypercube Sampling (LHS), or Sobol Sampling.\nExample: Generating Simulation Data in R\n# Load required libraries\nlibrary(lhs)        # For Latin Hypercube Sampling\nlibrary(randtoolbox) # For Sobol Sampling\n\nset.seed(123)\nn &lt;- 500  # Number of samples\nk &lt;- 5    # Number of parameters\n\n# Generate Latin Hypercube sampled input parameters\nparam_samples &lt;- randomLHS(n, k)\ncolnames(param_samples) &lt;- paste0(\"param\", 1:k)\n\n# Assume a simple simulation model (e.g., sum of squared params)\nsimulation_results &lt;- rowSums(param_samples^2)\n\n# Convert to data frame\nsim_data &lt;- data.frame(param_samples, Output = simulation_results)\n\nhead(sim_data)\n📌 Note: Replace simulation_results with the actual simulation output.\n2. Train a Random Forest Model\nOnce the data is prepared, an RF model can be trained using randomForest in R.\nTrain the RF Model\nlibrary(randomForest)\n\n# Train Random Forest to predict simulation output\nset.seed(123)\nrf_model &lt;- randomForest(Output ~ ., data = sim_data, importance = TRUE, ntree = 500)\n\n# Print model summary\nprint(rf_model)\n📌 Explanation:\n\nOutput ~ . means the RF model uses all parameters to predict the output.\n\nimportance = TRUE ensures that feature importance is computed.\n\nntree = 500 sets the number of trees in the forest.\n\n3. Extract Parameter Importance\nAfter training, RF provides two types of feature importance: 1. Mean Decrease in Accuracy (MDA) – Measures how much accuracy drops when a parameter is randomly shuffled. 2. Mean Decrease in Gini (MDG) – Measures how much each variable contributes to reducing node impurity in the decision trees.\nPlot Feature Importance\n# Extract importance values\nimportance_values &lt;- importance(rf_model)\n\n# Convert to a data frame\nimportance_df &lt;- data.frame(Parameter = rownames(importance_values),\n                            MDA = importance_values[, 1], \n                            MDG = importance_values[, 2])\n\n# Print importance scores\nprint(importance_df)\n\n# Plot feature importance\nlibrary(ggplot2)\nggplot(importance_df, aes(x = reorder(Parameter, -MDA), y = MDA)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  labs(title = \"Feature Importance (Mean Decrease in Accuracy)\",\n       x = \"Parameter\", y = \"Importance\") +\n  theme_minimal()\n📌 Interpretation: - Higher MDA values indicate more important parameters (greater accuracy drop when shuffled). - Higher MDG values mean stronger contributions to splitting decisions in trees.\n4. Interpret the Results\nAfter analysing feature importance: - Key parameters can be identified for further refinement. - Unimportant parameters can be removed to simplify the model. - Interactions between parameters can be explored.\n\nSummary | Step | Action | |——|——–| | 1 | Generate parameter samples using LHS, Sobol, or Random Sampling | | 2 | Run simulations to obtain output values | | 3 | Train a Random Forest model using randomForest | | 4 | Extract feature importance using importance() | | 5 | Interpret and visualize the results |\nExample: (Angourakis et al. 2022)\n\n\n\n\nAngourakis, Andreas, Jonas Alcaina-Mateos, Marco Madella, and Debora Zurro. 2022. “Human-Plant Coevolution: A Modelling Framework for Theory-Building on the Origins of Agriculture.” PLOS ONE 17 (9): e0260904. https://doi.org/10.1371/journal.pone.0260904.",
    "crumbs": [
      "Analysis of simulation results",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Sensitivity analysis of simulation models</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Acerbi, Alberto, Alex Mesoudi, and Marco Smolla. 2020.\n“Individual-Based Models of Cultural Evolution. A\nStep-by-Step Guide Using R.” OSF. https://doi.org/10.31219/osf.io/32v6a.\n\n\nAltaweel, Mark, Alessio Palmisano, and Carrie Hritz. 2015.\n“Evaluating Settlement Structures in the\nAncient Near East Using\nSpatial Interaction Entropy\nMaximization.” Structure and Dynamics: eJournal\nof Anthropological and Related Sciences 8 (1). https://doi.org/10.5070/SD981028281.\n\n\nAltaweel, Mark, and Chikako Watanabe. 2012a. “Salinization\nMASS Model Version.” https://doi.pangaea.de/10.1594/PANGAEA.778611.\n\n\nAltaweel, Mark, and Chikako E. Watanabe. 2012b. “Assessing the\nResilience of Irrigation Agriculture: Applying a Social–Ecological Model\nfor Understanding the Mitigation of Salinization.” Journal of\nArchaeological Science 39 (4): 1160–71. https://doi.org/10.1016/j.jas.2011.12.020.\n\n\nAngourakis, Andreas. 2021.\n“Two-Rains/Indus-Village-Model: The\nIndus Village Model Development Files\n(May 2021).” Zenodo. https://doi.org/10.5281/zenodo.4814255.\n\n\nAngourakis, Andreas, Jonas Alcaina-Mateos, Marco Madella, and Debora\nZurro. 2022. “Human-Plant Coevolution:\nA Modelling Framework for Theory-Building on the Origins of\nAgriculture.” PLOS ONE 17 (9): e0260904. https://doi.org/10.1371/journal.pone.0260904.\n\n\nAngourakis, Andreas, Jennifer Bates, Jean-Philippe Baudouin, Alena\nGiesche, M Cemre Ustunkaya, Nathan Wright, Ravindra N Singh, and Cameron\nA Petrie. 2020. “How to ‘Downsize’ a Complex Society:\nAn Agent-Based Modelling Approach to Assess the Resilience of\nIndus Civilisation Settlements to Past Climate\nChange.” Environmental Research Letters 15 (11): 115004.\nhttps://doi.org/10.1088/1748-9326/abacf9.\n\n\nAngourakis, Andreas, Jennifer Bates, Jean-Philippe Baudouin, Alena\nGiesche, Joanna R. Walker, M. Cemre Ustunkaya, Nathan Wright, Ravindra\nNath Singh, and Cameron A. Petrie. 2022. “Weather,\nLand and Crops in the Indus\nVillage Model: A\nSimulation Framework for Crop\nDynamics Under Environmental\nVariability and Climate Change in\nthe Indus Civilisation.”\nQuaternary 5 (2): 25. https://doi.org/10.3390/quat5020025.\n\n\nAngourakis, Andreas, Jean-Philippe Baudouin, and Cameron A. Petrie.\n2025. “The Weather Model (Indus\nVillage): Procedural Generation of Daily\nWeather for the Simulation of Small-Scale Socioecological\nSystems.” Environmental Modelling & Software 193\n(September): 106634. https://doi.org/10.1016/j.envsoft.2025.106634.\n\n\nAngourakis, Andreas, Bernardo Rondelli, Sebastian Stride, Xavier\nRubio-Campillo, Andrea L. Balbo, Alexis Torrano, Verònica Martinez,\nMarco Madella, and Josep M. Gurt. 2014. “Land Use\nPatterns in Central Asia.\nStep 1: The Musical\nChairs Model.” Journal of\nArchaeological Method and Theory 21 (2): 405–25. https://doi.org/10.1007/s10816-013-9197-0.\n\n\nAngourakis, Andreas, Matthieu Salpeteur, Verònica Martínez Ferreras,\nJosep Maria Gurt Esparraguera, Verònica Martínez Ferreras, and Josep\nMaria Gurt Esparraguera. 2017. “The Nice\nMusical Chairs Model:\nExploring the Role of Competition\nand Cooperation Between Farming\nand Herding in the Formation of\nLand Use Patterns in\nArid Afro-Eurasia.”\nJournal of Archaeological Method and Theory 24 (4): 1177–1202.\nhttps://doi.org/10.1007/s10816-016-9309-8.\n\n\nAngourakis, Andreas, José Ignacio Santos, José Manuel Galán, and Andrea\nL. Balbo. 2015. “Food for All: An Agent-Based Model\nto Explore the Emergence and Implications of Cooperation for Food\nStorage.” Environmental Archaeology 20 (4): 349–63. https://doi.org/10.1179/1749631414Y.0000000041.\n\n\n“Automatically Generated Release Notes.” n.d. GitHub\nDocs. Accessed October 11, 2024. https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes.\n\n\nAxtell, Robert L., Joshua M. Epstein, Jeffrey S. Dean, George J.\nGumerman, Alan C. Swedlund, Jason Harburger, Shubha Chakravarty, Ross\nHammond, Jon Parker, and Miles Parker. 2002. “Population Growth\nand Collapse in a Multiagent Model of the Kayenta\nAnasazi in Long House\nValley.” Proceedings of the National Academy of\nSciences 99 (Supplement 3): 7275–79. https://doi.org/10.1073/pnas.092080799.\n\n\nBarton, C. Michael, Isaac I. T. Ullah, Sean M. Bergin, Helena Mitasova,\nand Hessam Sarjoughian. 2012. “Looking for the Future in the Past:\nLong-Term Change in Socioecological Systems.”\nEcological Modelling 241 (August): 42–53. https://doi.org/10.1016/J.ECOLMODEL.2012.02.010.\n\n\nBaum, Tilman, Claas Nendel, Stefanie Jacomet, Miquel Colobran, and\nRenate Ebersbach. 2016. “‘Slash and\nBurn’ or ‘Weed and Manure’? A Modelling\nApproach to Explore Hypotheses of Late Neolithic Crop\nCultivation in Pre-Alpine Wetland Sites.” Vegetation History\nand Archaeobotany 25 (6): 611–27. https://doi.org/10.1007/s00334-016-0583-x.\n\n\nBocquet-Appel, Jean-Pierre, Jérôme Dubouloz, Richard Moussa,\nJean-François Berger, Anne Tresset, Elena Ortu, Jean-Denis Vigne, et al.\n2014. “Multi-Agent Modelling of the\nTrajectory of the LBK Neolithic:\nA Study in Progress.” In\nEarly Farmers: The View from\nArchaeology and Science, edited by\nAlasdair Whittle and Penny Bickle, 0. British Academy. https://doi.org/10.5871/bacad/9780197265758.003.0004.\n\n\nBoogers, Stef, and Dries Daems. 2022. “SAGAscape:\nSimulating Resource Exploitation\nStrategies in Iron Age to\nHellenistic Communities in\nSouthwest Anatolia.” Journal of\nComputer Applications in Archaeology 5 (1): 169–87. https://doi.org/10.5334/jcaa.90.\n\n\nBrantingham, P. Jeffrey. 2006. “Measuring Forager\nMobility.” Current Anthropology 47 (3):\n435–59. https://doi.org/10.1086/503062.\n\n\nCallegari, Simone, John David Weissmann, Natalie Tkachenko, Wesley P.\nPetersen, George Lake, Marcia Ponce De León, and Christoph P. E.\nZollikofer. 2013. “An Agent-Based Model of Human Dispersals at a\nGlobal Scale.” Advances in Complex Systems 16 (04n05):\n1350023. https://doi.org/10.1142/S0219525913500239.\n\n\nCarrignon, Simon, Tom Brughmans, and Iza Romanowska. 2020.\n“Tableware Trade in the Roman East:\nExploring Cultural and Economic Transmission with\nAgent-Based Modelling and Approximate Bayesian\nComputation.” Edited by Sergi Lozano. PLOS ONE 15 (11):\ne0240414. https://doi.org/10.1371/journal.pone.0240414.\n\n\nChalom, André, and Paulo Inácio de Knegt López de Prado. 2015.\n“Parameter Space Exploration of Ecological Models.” arXiv.\nhttps://doi.org/10.48550/arXiv.1210.6278.\n\n\nChliaoutakis, Angelos, and Georgios Chalkiadakis. 2020. “An\nAgent-Based Model for Simulating Intersettlement Trade in Past\nSocieties.” JASSS 23 (3). https://doi.org/10.18564/jasss.4341.\n\n\nChristiansen, John H., and Mark R Altaweel. 2006. “Simulation of\nNatural and Social Process\nInteractions.” Social Science Computer\nReview 24 (2): 209–26. https://doi.org/10.1177/0894439305281500.\n\n\nCioara, Andrei. 2018. “How I Organize My\nGitHub Repositories.” Medium.\nhttps://andreicioara.com/how-i-organize-my-github-repositories-ce877db2e8b6.\n\n\nCioffi-Revilla, Claudio, William Honeychurch, and J. Daniel Rogers.\n2015. “MASON Hierarchies: A Long-Range Agent Model of\nPower, Conflict, and Environment in Inner\nAsia.” In The Complexity of\nInteraction Along the Eurasian\nSteppe Zone in the First\nMillennium AD: Empires,\nCities, Nomads and Farmers,\n39–63. Bonn: Bonn University Press. http://krasnow.gmu.edu/socialcomplexity/files/2015/09/Cioffi-Revilla-et-al.Hierarchies-2015.pdf.\n\n\n“Cloning and Forking a Repository —\nPythia Foundations.” n.d. Accessed\nOctober 28, 2024. https://foundations.projectpythia.org/foundations/github/github-cloning-forking.html.\n\n\n“Created New Organization in GitHub and\nZenodo Did Not Send a Request for Accessing It ·\nIssue #1596 · Zenodo/Zenodo.” n.d. GitHub.\nAccessed October 11, 2024. https://github.com/zenodo/zenodo/issues/1596.\n\n\n“Creating GitHub Releases Automatically\non Tags.” 2024. https://jacobtomlinson.dev/posts/2024/creating-github-releases-automatically-on-tags/.\n\n\nCrema, Enrico R. 2014. “A Simulation\nModel of Fission-Fusion\nDynamics and Long-Term\nSettlement Change.” Journal of\nArchaeological Method and Theory 21 (2): 385–404. https://doi.org/10.1007/s10816-013-9185-4.\n\n\ndanijar. 2019. “Can I Arrange Repositories into\nFolders on Github?” Forum post. Stack\nOverflow. https://stackoverflow.com/q/11852982/6199967.\n\n\nDavies, Benjamin, Simon J Holdaway, and Patricia C Fanning. 2016.\n“Modelling the Palimpsest: An Exploratory Agent-Based\nModel of Surface Archaeological Deposit Formation in a Fluvial Arid\nAustralian Landscape.” The Holocene 26 (3):\n450–63. https://doi.org/10.1177/0959683615609754.\n\n\n“Difference Between Fork and Clone in\nGitHub.” 2021. GeeksforGeeks. https://www.geeksforgeeks.org/difference-between-fork-and-clone-in-github/.\n\n\nDrost, Cornelis J., and Marc Vander Linden. 2018. “Toy\nStory: Homophily, Transmission\nand the Use of Simple Simulation\nModels for Assessing Variability\nin the Archaeological Record.”\nJournal of Archaeological Method and Theory 25 (4): 1087–1108.\nhttps://doi.org/10.1007/s10816-018-9394-y.\n\n\n“Git - Reference.” n.d. Accessed October 9,\n2024. https://git-scm.com/docs.\n\n\n“Git Definitions and Terminology\nCheat Sheet.” n.d. Accessed October 11,\n2024. https://www.pluralsight.com/resources/blog/cloud/git-terms-explained.\n\n\n“GitHub Glossary.” n.d. GitHub Docs.\nAccessed October 28, 2024. https://docs.github.com/en/get-started/learning-about-github/github-glossary.\n\n\nGower-Winter, Brandon. 2022. “Self-Adapting\nSimulated Artificial\nSocieties.” Master’s thesis, Cape Town: University\nof Cape Town. https://sit.uct.ac.za/sites/default/files/media/documents/sit_uct_ac_za/2591/2022-self-adapting_simulated_artificial_societies.pdf.\n\n\nGraham, Shawn. 2009. “Behaviour Space:\nSimulating Roman Social\nLife and Civil Violence.”\nDigital Studies / Le Champ Numérique 1 (2). https://doi.org/10.16995/dscn.109.\n\n\nGraham, Shawn, and J. Steiner. 2008. “TravellerSim:\nGrowing Settlement Structures and\nTerritories with Agent-Based\nModeling.” In Digital Discovery:\nExploring New Frontiers in\nHuman Heritage. CAA 2006.\nComputer Applications and\nQuantitative Methods in\nArchaeology. Proceedings of the 34th\nConference, Fargo, United\nStates, April 2006, edited by Jeffrey T.\nClark and Emily M. Hagemeister. Budapest: Archaeolingua. https://electricarchaeology.ca/2009/10/16/travellersim-growing-settlement-structures-and-territories-with-agent-based-modeling-full-text/.\n\n\nGravel-Miguel, Claudine, and Colin D. Wren. 2018. “Agent-Based\nLeast-Cost Path Analysis and the Diffusion of Cantabrian\nLower Magdalenian Engraved Scapulae.”\nJournal of Archaeological Science 99 (November): 1–9. https://doi.org/10.1016/j.jas.2018.08.014.\n\n\nGriffith, Cameron S., Byron L. Long, and Jeanne M. Sept. 2010.\n“HOMINIDS: An Agent-Based Spatial\nSimulation Model to Evaluate Behavioral Patterns of Early\nPleistocene Hominids.” Ecological Modelling\n221 (5): 738–60. https://doi.org/10.1016/j.ecolmodel.2009.11.009.\n\n\nGrimm, Volker, Uta Berger, Finn Bastiansen, Sigrunn Eliassen, Vincent\nGinot, Jarl Giske, John Goss-Custard, et al. 2006. “A Standard\nProtocol for Describing Individual-Based and Agent-Based Models.”\nEcological Modelling 198 (1-2): 115–26. https://doi.org/10.1016/J.ECOLMODEL.2006.04.023.\n\n\nGrimm, Volker, Uta Berger, Donald L. DeAngelis, J. Gary Polhill, Jarl\nGiske, and Steven F. Railsback. 2010. “The ODD\nProtocol: A Review and First Update.” Ecological\nModelling 221 (23): 2760–68. https://doi.org/10.1016/J.ECOLMODEL.2010.08.019.\n\n\nGrimm, Volker, Steven F. Railsback, Christian E. Vincenot, Uta Berger,\nCara Gallagher, Donald L. DeAngelis, Bruce Edmonds, et al. 2020.\n“The ODD Protocol for\nDescribing Agent-Based and\nOther Simulation Models:\nA Second Update to\nImprove Clarity, Replication, and\nStructural Realism.” Journal of\nArtificial Societies and Social Simulation 23 (2): 7.\n\n\nGünther, Gerrit, Thomas Clemen, Rainer Duttmann, Brigitta Schütt, and\nDaniel Knitter. 2021. “Of Animal\nHusbandry and Food\nProduction—A First\nStep Towards a Modular\nAgent-Based Modelling\nPlatform for Socio-Ecological\nDynamics.” Land 10 (12): 1366. https://doi.org/10.3390/land10121366.\n\n\nHeckbert, Scott. 2013. “MayaSim.” Journal\nof Artificial Societies & Social Simulation 16 (4): 11. http://jasss.soc.surrey.ac.uk/16/4/11.html.\n\n\n“How to Get Familiar with Forking &\nCloning GitHub Repos.” 2023. DEV\nCommunity. https://dev.to/joshhortt/how-to-get-familiar-with-forking-cloning-github-repos-46nc.\n\n\n“Issue a Doi with Zenodo.” n.d. Github for\nCollaborative Documentation. Accessed October 11, 2024. https://cassgvp.github.io/github-for-collaborative-documentation/docs/tut/6-Zenodo-integration.html.\n\n\nJanssen, Marco A. 2009. “Understanding Artificial\nAnasazi.” Jasss 12 (4): 13. https://doi.org/13.\n\n\njimmy. 2022. “How to Organize GitHub\nRepositories.” Backrightup. https://backrightup.com/blog/how-to-organize-github-repositories/.\n\n\nJoyce, James A. 2019. “Farming Along the Limes: Using\nAgent-Based Modelling to Investigate Possibilities for Subsistence and\nSurplus-Based Agricultural Production in the Lower\nRhine Delta Between 12BCE and\n270CE.” Ph.{D}., Vrije Universiteit Amsterdam. http://dare.ubvu.vu.nl/handle/1871/55924.\n\n\nKabora, T. K., D. Stump, and J. Wainwright. 2020. “How Did That\nGet There? Understanding Sediment Transport and\nAccumulation Rates in Agricultural Landscapes Using the\nESTTraP Agent-Based Model.” Journal of\nArchaeological Science: Reports 29 (February): 102115. https://doi.org/10.1016/j.jasrep.2019.102115.\n\n\nKohler, Timothy A., and Mark D. Varien. 2012. Emergence and\nCollapse of Early Villages:\nModels of Central Mesa\nVerde Archaeology. University of\nCalifornia Press.\n\n\nKovacevic, Mirna, Stephen Shennan, Marian Vanhaeren, Francesco d’Errico,\nand Mark G. Thomas. 2015. “Simulating Geographical\nVariation in Material Culture:\nWere Early Modern\nHumans in Europe Ethnically\nStructured?” In Learning Strategies\nand Cultural Evolution During the\nPalaeolithic, edited by Alex Mesoudi and Kenichi Aoki,\n103–20. Replacement of Neanderthals by Modern\nHumans Series. Tokyo: Springer Japan. https://doi.org/10.1007/978-4-431-55363-2_8.\n\n\nLake, Mark. 2001. “The Use of Pedestrian\nModelling in Archaeology, with an\nExample from the Study of\nCultural Learning.” Environment and\nPlanning B: Planning and Design 28 (3): 385–403. https://doi.org/10.1068/b2726.\n\n\nLake, Mark W., and Enrico R. Crema. 2012. “The Cultural Evolution\nof Adaptive-Trait Diversity When Resources Are Uncertain and\nFinite.” Advances in Complex Systems 15 (01n02):\n1150013. https://doi.org/10.1142/S0219525911003323.\n\n\nLawall, Mark L., and Shawn Graham. 2018. “Netlogo Simulations and\nthe Use of Transport Amphoras in Antiquity.” In\nMaritime Networks in the Ancient\nMediterranean World, edited by Leidwanger\nand Carl Knappett, 163–83. Cambridge: Cambridge University Press.\n\n\nMcAnany, Patricia A., Jeremy A. Sabloff, M. Lamoureux St-Hilaire, and\nGyles Iannone. 2015. “Leaving Classic\nMaya Cities: Agent-Based Modeling and the Dynamics of\nDiaspora.” In Social Theory in Archaeology and Ancient\nHistory: The Present and Future of Counternarratives., edited by\nEmberling, 13:231–58. Cambridge: Cambridge University Press. https://www.cambridge.org/core/books/social-theory-in-archaeology-and-ancient-history/leaving-classic-maya-cities-agentbased-modeling-and-the-dynamics-of-diaspora/F068BF029E6359205F9321A114157F54?utm_campaign=shareaholic&utm_medium=copy_link&utm_source=bookmark.\n\n\nMokom, Felicitas. 2015. “Modeling the Evolution of\nArtifact Capabilities in\nMulti-Agent Based\nSimulations.” Electronic Theses and\nDissertations, January. https://scholar.uwindsor.ca/etd/5711.\n\n\nMorrison, Alex E., and Melinda S. Allen. 2017. “Agent-Based\nModelling, Molluscan Population Dynamics, and Archaeomalacology.”\nQuaternary International 427 (January): 170–83. https://doi.org/10.1016/j.quaint.2015.09.004.\n\n\nMüller, Birgit, Friedrich Bohn, Gunnar Dreßler, Jürgen Groeneveld,\nChristian Klassert, Romina Martin, Maja Schlüter, Jule Schulze, Hanna\nWeise, and Nina Schwarz. 2013. “Describing Human Decisions in\nAgent-Based Models – ODD + D, an Extension of\nthe ODD Protocol.” Environmental Modelling &\nSoftware 48 (October): 37–48. https://doi.org/10.1016/J.ENVSOFT.2013.06.003.\n\n\nNikulina, Anastasia, Katharine MacDonald, Anhelina Zapolska, Maria\nAntonia Serge, Didier M. Roche, Florence Mazier, Marco Davoli, et al.\n2024. “Hunter-Gatherer Impact on European\nInterglacial Vegetation: A Modelling Approach.”\nQuaternary Science Reviews 324 (January): 108439. https://doi.org/10.1016/j.quascirev.2023.108439.\n\n\nOestmo, Simen, Marco A. Janssen, and Curtis W. Marean. 2016.\n“Testing Brantingham’s Neutral\nModel: The Effect of\nSpatial Clustering on Stone\nRaw Material Procurement.”\nIn Simulating Prehistoric and Ancient\nWorlds, edited by Juan A. Barceló and Florencia Del\nCastillo, 175–88. Cham: Springer International Publishing. https://doi.org/10.1007/978-3-319-31481-5_4.\n\n\nOrtega, David, Juan José Ibañez, Lamya Khalidi, Vicenç Méndez, Daniel\nCampos, and Luís Teira. 2014. “Towards a\nMulti-Agent-Based\nModelling of Obsidian Exchange in\nthe Neolithic Near East.”\nJournal of Archaeological Method and Theory 21 (2): 461–85. https://doi.org/10.1007/s10816-013-9196-1.\n\n\nPaliou, Eleftheria, and Andrew Bevan. 2016. “Evolving Settlement\nPatterns, Spatial Interaction and the Socio-Political Organisation of\nLate Prepalatial South-Central Crete.”\nJournal of Anthropological Archaeology 42 (June): 184–97. https://doi.org/10.1016/j.jaa.2016.04.006.\n\n\nPremo, L. S., and Gilbert B. Tostevin. 2016. “Cultural\nTransmission on the Taskscape:\nExploring the Effects of\nTaskscape Visibility on Cultural\nDiversity.” PLOS ONE 11 (9): e0161766. https://doi.org/10.1371/journal.pone.0161766.\n\n\nRenardy, Marissa, Louis R. Joslyn, Jess A. Millar, and Denise E.\nKirschner. 2021. “To Sobol or Not to\nSobol? The Effects of Sampling Schemes in\nSystems Biology Applications.” Mathematical Biosciences\n337 (July): 108593. https://doi.org/10.1016/j.mbs.2021.108593.\n\n\nRihll, T. E., and A. G. Wilson. 1991. “Modelling Settlement\nStructures in Ancient Greece: New Approaches\nto the Polis.” In City and Country in the\nAncient World. Routledge. https://www.taylorfrancis.com/chapters/edit/10.4324/9780203418703-9/modelling-settlement-structures-ancient-greece-new-approaches-polis-rihll-wilson.\n\n\nRobinson, Derek T., Alan Di Vittorio, Peter Alexander, Almut Arneth, C.\nMichael Barton, Daniel G. Brown, Albert Kettner, et al. 2018.\n“Modelling Feedbacks Between Human and Natural Processes in the\nLand System.” Earth System Dynamics 9 (2): 895–914. https://doi.org/10.5194/esd-9-895-2018.\n\n\nRogers, J. Daniel. 2013. “Pastoralist Mobility and\nSocial Controls In\nInner Asia: Experiments\nUsing Agent-Based\nModeling.” Structure and Dynamics: eJournal of\nAnthropological and Related Sciences 6 (2). https://escholarship.org/uc/item/7rg669rm.\n\n\nRogers, J. Daniel, Teresa Nichols, Theresa Emmerich, Maciej Latek, and\nClaudio Cioffi-Revilla. 2012. “Modeling Scale and Variability in\nHuman-Environmental Interactions in Inner\nAsia.” Ecological Modelling 241: 5–14. https://doi.org/10.1016/j.ecolmodel.2011.11.025.\n\n\nRomanowska, Iza, Colin D. Wren, and Stefani A. Crabtree. 2021.\nAgent-Based Modeling for\nArchaeology. Electronic. SFI Press. https://doi.org/10.37911/9781947864382.\n\n\nRubio Campillo, Xavier, Jose María Cela, and Francesc Xavier Hernàndez\nCardona. 2012. “Simulating Archaeologists? Using\nAgent-Based Modelling to Improve Battlefield Excavations.”\nJournal of Archaeological Science 39 (2): 347–56. https://doi.org/10.1016/j.jas.2011.09.020.\n\n\nRubio-Campillo, X., J. M. Cela, and F. X. H. Cardona. 2014. “The\nDevelopment of New Infantry Tactics During the Early Eighteenth Century:\nA Computer Simulation Approach to Modern Military History.” In\nAgent-Based Modeling and\nSimulation, edited by Simon J. E. Taylor, 208–30. The\nOR Essentials Series. London: Palgrave\nMacmillan UK. https://doi.org/10.1057/9781137453648_11.\n\n\nSakahira, Fumihiro, Yuji Yamaguchi, Ryoya Osawa, Toshifumi Kishimoto,\nTaka’aki Okubo, Takao Terano, and Hiro’omi Tsumura. 2021.\n“Generating Hypotheses on Prehistoric Cultural Transformation with\nAgent-Based Evolutionary Simulation.” In Proceedings of the\nWinter Simulation\nConference, 194–205. WSC ’20. Orlando,\nFlorida: IEEE Press.\n\n\nSantos, José Ignacio, María Pereda, Débora Zurro, Myrian Álvarez, Jorge\nCaro, José Manuel Galán, and Ivan Briz i Godino. 2015. “Effect of\nResource Spatial Correlation and Hunter-Fisher-Gatherer Mobility on\nSocial Cooperation in Tierra Del\nFuego.” PloS One 10 (4): e0121888. https://doi.org/10.1371/journal.pone.0121888.\n\n\nSignell, Rich. 2013. “How to Handle Releases of Markdown Document\non Github.” Forum post. Stack Overflow. https://stackoverflow.com/q/19727632/6199967.\n\n\nSnitker, Grant. 2018. “Identifying Natural and Anthropogenic\nDrivers of Prehistoric Fire Regimes Through Simulated Charcoal\nRecords.” Journal of Archaeological Science 95 (July):\n1–15. https://doi.org/10.1016/j.jas.2018.04.009.\n\n\n———. 2021. “Evaluating the Influence of\nNeolithic Agropastoral Land\nUse on Holocene Fire\nRegimes Through Simulated\nSedimentary Charcoal\nRecords.” In Simulating Transitions\nto Agriculture in Prehistory, edited by\nSalvador Pardo-Gordó and Sean Bergin, 165–93. Computational\nSocial Sciences. Cham: Springer International\nPublishing. https://doi.org/10.1007/978-3-030-83643-6_9.\n\n\nSorensen, Andrew C., and Fulco Scherjon. 2018. “fiReproxies: A Computational Model\nProviding Insight into Heat-Affected Archaeological Lithic\nAssemblages.” PLOS ONE 13 (5): e0196777. https://doi.org/10.1371/journal.pone.0196777.\n\n\nSousa, David Naves, Luís Correia, and Leonel Garcia-marques. 2019.\n“The Importance of Memory for the Success of Cooperation Under\nEcological Adversity.” Adaptive Behavior 28 (4): 1–4. https://doi.org/10.1177/1059712319872518.\n\n\nSuhail, Muhammad Ahmed. 2024. “Structuring and\nOrganizing My Github: A\nDeveloper’s Guide.” Medium. https://medium.com/@muhammadahmedsuhail007/structuring-and-organizing-my-github-a-developers-guide-7353610f04fd.\n\n\nTurchin, Peter. 2018. Historical Dynamics:\nWhy States Rise and\nFall. Princeton University Press. https://doi.org/10.1515/9781400889310.\n\n\nUllah, Isaac I. T., Claudia Chang, and Perry Tourtellotte. 2019.\n“Water, Dust, and Agro-Pastoralism: Modeling\nSocio-Ecological Co-Evolution of Landscapes, Farming, and Human Society\nin Southeast Kazakhstan During the Mid to Late\nHolocene.” Journal of Anthropological\nArchaeology 55 (September): 101067. https://doi.org/10.1016/j.jaa.2019.101067.\n\n\nVerhagen, Philip. 2019. “Modelling the Dynamics of\nDemography in the Dutch Roman\nLimes Zone: A\nRevised Model.” In Finding the\nLimits of the Limes: Modelling\nDemography, Economy and Transport\non the Edge of the Roman\nEmpire, edited by Philip Verhagen, Jamie Joyce, and\nMark R. Groenhuijzen, 43–59. Computational Social\nSciences. Cham: Springer International Publishing. https://doi.org/10.1007/978-3-030-04576-0_3.\n\n\nWhite, Andrew A. 2013. “Subsistence Economics, Family Size, and\nthe Emergence of Social Complexity in Hunter–Gatherer Systems in Eastern\nNorth America.” Journal of\nAnthropological Archaeology 32 (1): 122–63. https://doi.org/10.1016/j.jaa.2012.12.003.\n\n\nZestyclose-Low-6403. 2023. “How to Organize Repos Within an\n’Organization’?” Reddit {Post}. R/Github. www.reddit.com/r/github/comments/188d324/how_to_organize_repos_within_an_organization/.",
    "crumbs": [
      "References"
    ]
  }
]